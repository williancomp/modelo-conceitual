<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Modelagem Conceitual – Nova Era</title>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
  <style>
    body {
      font-family: 'Poppins', sans-serif;
      margin: 0;
      padding: 0;
      background: linear-gradient(to bottom right, #1f2937, #374151, #1e3a8a);
      overflow: hidden;
      color: #ffffff;
    }
    #sidebar {
      position: fixed;
      left: 0;
      top: 0;
      width: 100px;
      height: 100vh;         /* Garante que o sidebar tenha a altura total da viewport */
      background: #111827;
      padding: 20px 10px;
      transition: width 0.3s;
      z-index: 100;
      overflow-y: auto;      /* Permite scroll se o conteúdo ultrapassar a altura */
    }
    #sidebar.expanded {
      width: 200px;
    }
    #hamburger {
      display: none;
      cursor: pointer;
    }
    .toolbar-button {
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      width: 80px;
      height: 80px;
      margin: 10px 0;
      border-radius: 8px; 
      transition: transform 0.2s, box-shadow 0.2s;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
    }
    .toolbar-button:hover {
      transform: scale(1.1);
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
    }
    .toolbar-button span {
      margin-top: 5px;
      font-size: 12px;           /* ou ajuste se quiser menor */
      color: #ffffff;
      text-align: center;
      white-space: normal;       /* permite quebra de linha */
      word-wrap: break-word;     /* quebra a palavra se necessário */
      overflow-wrap: break-word; /* fallback para navegadores diferentes */
      display: block;
      max-width: 80%;            /* limita a largura do texto dentro do botão */
      margin-left: auto;
      margin-right: auto;
    }
    canvas {
      display: block;
      margin-left: 100px;
      background: #ffffff;
      border-radius: 10px;
    }
    .submenu {
      position: absolute;
      background: linear-gradient(to right, #374151, #1f2937);
      border: 1px solid #4b5563;
      border-radius: 8px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
      padding: 8px;
      z-index: 1000;
      display: flex;
      gap: 10px;
    }
    .submenu-item {
      display: flex;
      align-items: center;
      padding: 6px 12px;
      cursor: pointer;
      border-radius: 4px;
      transition: background 0.2s;
    }
    .submenu-item:active::after {
      content: '';
      position: absolute;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background: rgba(255, 255, 255, 0.3);
      border-radius: 4px;
      transform: scale(0);
      animation: ripple 0.6s linear;
    }
    .submenu-item:hover {
      background: #4b5563;
    }

    /* Cursor especial para indicar arrastar */
    #menuRelate {
      cursor: grab;
    }

    #menuRelate:active {
      cursor: grabbing;
    }

    /* Efeito de feedback visual quando o mouse está sobre um alvo válido */
    .hover-target {
      box-shadow: 0 0 0 2px #60a5fa, 0 0 10px 4px rgba(96, 165, 250, 0.5);
      transition: box-shadow 0.2s ease;
    }

    /* Estilo para a linha de conexão durante o arraste */
    .dragging-connection-line {
      stroke: #3b82f6;
      stroke-width: 2.5;
      stroke-dasharray: 5,3;
      animation: dash 1s linear infinite;
    }

    @keyframes dash {
      to {
        stroke-dashoffset: -8;
      }
    }


    @keyframes ripple {
      to {
        transform: scale(4);
        opacity: 0;
      }
    }
    
    @media (max-width: 768px) {
      #sidebar {
        width: 0;
        padding: 0;
      }
      #sidebar.expanded {
        width: 100px;
      }
      #hamburger {
        display: block;
        position: fixed;
        top: 10px;
        left: 10px;
        z-index: 101;
      }
      canvas {
        margin-left: 0;
      }
    }

    /* Estilo para quando arrastar um arquivo sobre o canvas */
    #canvas.border-dashed {
      transition: all 0.3s;
    }

    /* Melhoria para o indicador de autosave */
    #autosave-indicator {
      transition: opacity 0.3s ease;
      backdrop-filter: blur(4px);
      -webkit-backdrop-filter: blur(4px);
    }

    /* Animação de pulsação para os botões da barra de ferramentas no hover */
    .toolbar-button:hover {
      transform: scale(1.1);
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
      animation: pulse 1.5s infinite;
    }

    @keyframes pulse {
      0% {
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
      }
      50% {
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
      }
      100% {
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
      }
    }

    /* Transição suave para o modal */
    #loadModal {
      transition: opacity 0.3s ease;
    }

    #loadModal.hidden {
      opacity: 0;
      pointer-events: none;
    }

    #loadModal:not(.hidden) {
      opacity: 1;
    }

    /* Melhorias nos botões do modal */
    #loadCancelBtn, #loadConfirmBtn {
      transition: background-color 0.2s, transform 0.2s;
    }

    #loadCancelBtn:hover, #loadConfirmBtn:hover {
      transform: translateY(-2px);
    }

    #loadCancelBtn:active, #loadConfirmBtn:active {
      transform: translateY(1px);
    }

    
  </style>
</head>
<body class="flex h-screen">

  <!-- Barra Lateral -->
  <aside id="sidebar" class="flex flex-col items-center">
    <div id="hamburger" class="p-2">
      <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16m-7 6h7" />
      </svg>
    </div>
    <div id="toolbar" class="flex flex-col items-center">
      <!-- Botão Entidade -->
      <button id="btnEntity" class="toolbar-button bg-gradient-to-br from-blue-500 to-blue-700">
        <svg class="w-8 h-8 text-white" fill="none" stroke="currentColor" stroke-width="3" viewBox="0 0 24 24">
          <rect x="4" y="6" width="16" height="12" rx="2" />
        </svg>
        <span>Entidade</span>
      </button>
      <!-- Botão Atributo -->
      <button id="btnAttribute" class="toolbar-button bg-gradient-to-br from-green-500 to-green-700">
        <svg class="w-8 h-8 text-white" fill="none" stroke="currentColor" stroke-width="3" viewBox="0 0 24 24">
          <ellipse cx="12" cy="12" rx="8" ry="4" />
        </svg>
        <span>Atributo</span>
      </button>
      <!-- Botão Atributo Derivado -->
      <button id="btnDerivedAttribute" class="toolbar-button bg-gradient-to-br from-yellow-500 to-yellow-700">
        <svg class="w-8 h-8 text-white" fill="none" stroke="currentColor" stroke-dasharray="4" stroke-width="3" viewBox="0 0 24 24">
          <ellipse cx="12" cy="12" rx="8" ry="4" />
        </svg>
        <span>Derivado</span>
      </button>
      <!-- Botão Relacionamento -->
      <button id="btnRelationship" class="toolbar-button bg-gradient-to-br from-pink-500 to-purple-600">
        <svg class="w-8 h-8 text-white" fill="none" stroke="currentColor" stroke-width="3" viewBox="0 0 24 24">
          <polygon points="12 4 20 12 12 20 4 12" />
        </svg>
        <span>Relacionamento</span>
      </button>
      <!-- Botão Especialização -->
      <button id="btnSpecialization" class="toolbar-button bg-gradient-to-br from-yellow-400 to-yellow-600">
        <svg class="w-8 h-8 text-white" fill="none" stroke="currentColor" stroke-width="3" viewBox="0 0 24 24">
          <polygon points="12 4 4 20 20 20" />
        </svg>
        <span>Esp./Gen.</span>
      </button>
      <!-- Botão Aumentar Fonte -->
      <button id="btnIncreaseFont" class="toolbar-button bg-gradient-to-br from-gray-500 to-gray-700">
        <svg class="w-8 h-8 text-white" fill="none" stroke="currentColor" stroke-width="3" viewBox="0 0 24 24">
          <path d="M12 4v16m-8-8h16" />
        </svg>
        <span>Aumentar</span>
      </button>
      <!-- Botão Diminuir Fonte -->
      <button id="btnDecreaseFont" class="toolbar-button bg-gradient-to-br from-gray-500 to-gray-700">
        <svg class="w-8 h-8 text-white" fill="none" stroke="currentColor" stroke-width="3" viewBox="0 0 24 24">
          <path d="M4 12h16" />
        </svg>
        <span>Diminuir</span>
      </button>
      <!-- Botão Limpar -->
      <button id="btnClear" class="toolbar-button bg-gradient-to-br from-red-500 to-red-700">
        <svg class="w-8 h-8 text-white" fill="none" stroke="currentColor" stroke-width="3" viewBox="0 0 24 24">
          <path d="M6 18L18 6M6 6l12 12" />
        </svg>
        <span>Limpar</span>
      </button>
      <!-- Botão Exportar -->
      <button id="btnExport" class="toolbar-button bg-gradient-to-br from-blue-500 to-blue-700">
        <svg class="w-8 h-8 text-white" fill="none" stroke="currentColor" stroke-width="3" viewBox="0 0 24 24">
          <path d="M4 16l8-8 8 8m-8-8v12" />
        </svg>
        <span>Exportar</span>
      </button>
      <!-- Botão Desfazer -->
      <button id="btnUndo" class="toolbar-button bg-gradient-to-br from-yellow-500 to-yellow-700">
        <svg class="w-8 h-8 text-white" fill="none" stroke="currentColor" stroke-width="3" viewBox="0 0 24 24">
          <path d="M15 4l-8 8 8 8" />
        </svg>
        <span>Desfazer</span>
      </button>
      <!-- Botão Refazer -->
      <button id="btnRedo" class="toolbar-button bg-gradient-to-br from-yellow-500 to-yellow-700">
        <svg class="w-8 h-8 text-white" fill="none" stroke="currentColor" stroke-width="3" viewBox="0 0 24 24">
          <path d="M9 4l8 8-8 8" />
        </svg>
        <span>Refazer</span>
      </button>
      <!-- Botão Salvar Arquivo -->
      <button id="btnSaveFile" class="toolbar-button bg-gradient-to-br from-green-500 to-green-700">
        <svg class="w-8 h-8 text-white" fill="none" stroke="currentColor" stroke-width="3" viewBox="0 0 24 24">
          <path d="M8 7H5a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3m-1 4l-3 3m0 0l-3-3m3 3V4" />
        </svg>
        <span>Salvar Arquivo</span>
      </button>
      <!-- Botão Abrir Arquivo -->
      <button id="btnOpenFile" class="toolbar-button bg-gradient-to-br from-blue-500 to-blue-700">
        <svg class="w-8 h-8 text-white" fill="none" stroke="currentColor" stroke-width="3" viewBox="0 0 24 24">
          <path d="M5 19a2 2 0 0 1-2-2V7a2 2 0 0 1 2-2h4l2 2h4a2 2 0 0 1 2 2v1M5 19h14a2 2 0 0 0 2-2v-5a2 2 0 0 0-2-2H9a2 2 0 0 0-2 2v5a2 2 0 0 0 2 2z" />
        </svg>
        <span>Abrir Arquivo</span>
      </button>
      <!-- Input de arquivo oculto para o botão de abrir arquivo -->
      <input type="file" id="fileInput" accept=".merdb" style="display: none;" />

      <!-- Modal de confirmação para carregar arquivo -->
      <div id="loadModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden z-50">
        <div class="bg-gray-800 p-6 rounded-lg shadow-lg max-w-md w-full">
          <h3 class="text-xl font-bold text-white mb-4">Carregar diagrama</h3>
          <p class="text-white mb-6">Tem certeza que deseja carregar um novo diagrama? O diagrama atual será substituído.</p>
          <div class="flex justify-end gap-3">
            <button id="loadCancelBtn" class="px-4 py-2 bg-gray-700 text-white rounded hover:bg-gray-600 transition">Cancelar</button>
            <button id="loadConfirmBtn" class="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-500 transition">Carregar</button>
          </div>
        </div>
      </div>
    </div>
  </aside>

  <!-- Canvas -->
  <main class="flex-grow" style="position: relative;">
    <canvas id="canvas"></canvas>
    
    <!-- Adicione este elemento ao final da tag <main> (antes de </main>) -->
    <div id="autosave-indicator" class="fixed bottom-4 right-4 bg-gray-800 text-green-400 px-4 py-2 rounded-lg shadow-lg z-50 opacity-0 transition-opacity duration-300">
      Salvando...
    </div>
  </main>

  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const sidebar = document.getElementById("sidebar");

    

    // Fator de zoom global (inicial = 1)
    let zoom = 1;

    let panOffset = { x: 0, y: 0 };
    let isPanning = false;
    let panStart = { x: 0, y: 0 };
    let panOffsetStart = { x: 0, y: 0 };
    let isSpacePressed = false;

    

    let breakpointTimeout = null;
    let isDraggingBreakpoint = false;
    let activeBreakpoint = null;  // Guarda { connection, index } do breakpoint atual
    let pendingConnectionHit = null; // Guarda o hit de conexão para diferenciar click curto de longo

    // Variável para controlar se há mudanças não salvas
    let hasUnsavedChanges = false;

      

    document.addEventListener('mousedown', function(e) {
      if (inlineInput && !$(e.target).is(inlineInput) && $(e.target).closest(inlineInput).length === 0) {
        inlineInput.blur();
      }
      if (inlineSelect && !$(e.target).is(inlineSelect) && $(e.target).closest(inlineSelect).length === 0) {
        $(inlineSelect).blur();
      }
      if (inlineSpecSelect && !$(e.target).is(inlineSpecSelect) && $(e.target).closest(inlineSpecSelect).length === 0) {
        $(inlineSpecSelect).blur();
      }
    });

    document.addEventListener('keydown', (e) => {
      // Se estiver editando (input ou select ativo), não intercepta a tecla espaço
      if (document.activeElement &&
          (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'SELECT')) {
        return;
      }
      if (e.code === 'Space') {
        isSpacePressed = true;
        e.preventDefault();
      }
    });
    document.addEventListener('keyup', (e) => {
      if (e.code === 'Space') {
        isSpacePressed = false;
        isPanning = false;
      }
    });

    let mainWidth, mainHeight;
    function resizeCanvas() {
      canvas.width = window.innerWidth - (sidebar.offsetWidth || 0);
      canvas.height = window.innerHeight;
      mainWidth = canvas.width;
      mainHeight = canvas.height;
      draw();
    }

    let handleSize = window.innerWidth < 768 ? 16 : 8;
    let globalIconSize = window.innerWidth < 768 ? 32 : 24;

    window.addEventListener("resize", () => {
      handleSize = window.innerWidth < 768 ? 16 : 8;
      globalIconSize = window.innerWidth < 768 ? 32 : 24;
      resizeCanvas();
    });

    let entities = [], attributes = [], relationships = [], specializations = [];
    let entityIdCounter = 0, attributeIdCounter = 0, relationshipIdCounter = 0, specializationIdCounter = 0;
    let undoStack = [], redoStack = [];
    const defaultEntityWidth = 160, defaultEntityHeight = 80;
    const defaultAttributeRadiusX = 40, defaultAttributeRadiusY = 20, relationshipSize = 120, defaultSpecializationSize = 100;
    let fontSize = 16;

    let selectedConnection = null, selectedSpecConnection = null;
    let draggingToolbarType = null, draggingNewObj = null, clickPlacementMode = false, toolbarDrag = null;
    let isDraggingObject = false, dragObject = null, dragOffset = { x: 0, y: 0 };
    let isDraggingGroup = false, groupDragData = [], groupMouseStart = { x: 0, y: 0 };
    let isResizing = false, resizingObject = null, resizeHandleIndex = null, resizeStartMouse = { x: 0, y: 0 }, resizingInitial = {};
    let isSelecting = false, selectionStart = { x: 0, y: 0 }, selectionRect = null;
    let isDraggingConnection = false, draggingConnection = null;
    let submenu = null, submenuRect = null, submenuTimeout = null;
    let justSelectedConnection = false;
    // Array global para armazenar info de breakpoints durante o arraste em grupo
    let groupBreakpointsData = [];

    // Variáveis para controlar o arraste de relacionamento a partir do menu
    let draggingRelationFromMenu = false;
    let relationMenuSource = null;

    const normalColors = {
      entity: { fill: "#3b82f6", stroke: "#1e40af" },
      attribute: { fill: "#10b981", stroke: "#065f46" },
      derived: { fill: "#fcd34d", stroke: "#d97706" },
      relationship: { fill: "#ec4899", stroke: "#7e22ce" },
      specialization: { fill: "#facc15", stroke: "#ca8a04" }
    };

    
    // Adicione um flag para verificar se o localStorage está disponível
    function isLocalStorageAvailable() {
      try {
        const test = 'test';
        localStorage.setItem(test, test);
        localStorage.removeItem(test);
        return true;
      } catch(e) {
        console.error("LocalStorage não está disponível:", e);
        return false;
      }
    }



  // Método para salvar antes de fechar a página
  window.addEventListener('beforeunload', (e) => {
    if (hasUnsavedChanges) {
      saveToLocalStorage();
    }
  });


  // Adicionando auto-save a cada 30 segundos
  const autoSaveInterval = 30000; // 30 segundos
  setInterval(() => {
    if (hasUnsavedChanges) {
      saveToLocalStorage();
    }
  }, autoSaveInterval);



     // Adapte sua restoreState (usada para Undo/Redo) para chamar draw() ao final
    function restoreState(state) {
      entities = JSON.parse(JSON.stringify(state.entities));
      attributes = JSON.parse(JSON.stringify(state.attributes));
      relationships = JSON.parse(JSON.stringify(state.relationships));
      specializations = JSON.parse(JSON.stringify(state.specializations));
      draw();
    }

  // Corrija a sequência de inicialização na função que carrega quando a página inicia
  window.addEventListener("DOMContentLoaded", () => {
    // 1) Primeiro, ajusta o canvas
    resizeCanvas();

    // 2) Carrega do localStorage - está sendo feito corretamente
    loadFromLocalStorage();

    // 3) IMPORTANTE: Remova este trecho que pode estar apagando os dados carregados!
    // REMOVER ou COMENTAR este bloco:
    /*
    if (entities.length === 0 && attributes.length === 0 &&
        relationships.length === 0 && specializations.length === 0) {
      saveState(); // estado inicial vazio - este saveState() com arrays vazios pode estar sobreescrevendo seu localStorage!
    }
    */

    // 4) Finalmente, desenha
    draw();
  });



  // Event Listeners para os novos botões
document.addEventListener("DOMContentLoaded", function() {
  // Adiciona listeners para os botões de salvar/abrir
  document.getElementById("btnSaveFile").addEventListener("click", saveDiagramToFile);
  document.getElementById("btnOpenFile").addEventListener("click", openFileSelector);
  
  // Configura o input de arquivo
  const fileInput = document.getElementById("fileInput");
  fileInput.addEventListener("change", function(event) {
    if (event.target.files.length > 0) {
      const file = event.target.files[0];
      loadDiagramFromFile(file);
      // Limpa o valor para permitir selecionar o mesmo arquivo novamente
      fileInput.value = "";
    }
  });
  
  // Adiciona suporte para arrastar e soltar arquivos
  const canvas = document.getElementById("canvas");
  
  canvas.addEventListener("dragover", function(event) {
    event.preventDefault();
    canvas.classList.add("border-4", "border-blue-500", "border-dashed");
  });
  
  canvas.addEventListener("dragleave", function() {
    canvas.classList.remove("border-4", "border-blue-500", "border-dashed");
  });
  
  canvas.addEventListener("drop", function(event) {
    event.preventDefault();
    canvas.classList.remove("border-4", "border-blue-500", "border-dashed");
    
    if (event.dataTransfer.files.length > 0) {
      const file = event.dataTransfer.files[0];
      if (file.name.endsWith('.merdb')) {
        loadDiagramFromFile(file);
      } else {
        showNotification("Formato de arquivo não suportado. Use arquivos .merdb", "error");
      }
    }
  });
});




  // Versão melhorada de loadFromLocalStorage para garantir o debug
function loadFromLocalStorage() {
  console.log("Tentando carregar dados do localStorage...");
  
  try {
    const dataStr = localStorage.getItem("diagramData");
    
    // Log para debug - ver se há dados
    console.log("Dados encontrados no localStorage:", dataStr ? "Sim" : "Não");
    
    if (!dataStr) {
      console.log("Nenhum diagrama encontrado no localStorage");
      return; // não tem nada salvo ainda
    }

    const data = JSON.parse(dataStr);
    console.log("Carregando diagrama do localStorage, conteúdo:", data);

    // Carrega somente se realmente houver dados
    if (data.entities && Array.isArray(data.entities)) {
      // Restaura arrays
      entities = data.entities || [];
      attributes = data.attributes || [];
      relationships = data.relationships || [];
      specializations = data.specializations || [];

      // Restaura contadores - importante garantir que sejam números!
      entityIdCounter = typeof data.entityIdCounter === 'number' ? data.entityIdCounter : 0;
      attributeIdCounter = typeof data.attributeIdCounter === 'number' ? data.attributeIdCounter : 0;
      relationshipIdCounter = typeof data.relationshipIdCounter === 'number' ? data.relationshipIdCounter : 0;
      specializationIdCounter = typeof data.specializationIdCounter === 'number' ? data.specializationIdCounter : 0;
      
      // Restaura configurações visuais
      if (data.fontSize) fontSize = data.fontSize;
      if (data.panOffset) panOffset = data.panOffset;
      
      console.log("Diagrama carregado com sucesso:", {
        entidades: entities.length,
        atributos: attributes.length,
        relacionamentos: relationships.length,
        especializacoes: specializations.length
      });

      return true; // indica que carregou com sucesso
    } else {
      console.warn("Dados encontrados no localStorage, mas sem entidades válidas");
      return false;
    }
  } catch (err) {
    console.error("Falha ao carregar do localStorage:", err);
    return false;
  }
}

// Versão melhorada de saveToLocalStorage para garantir o sucesso
function saveToLocalStorage() {
  try {
    const currentData = {
      entities,
      attributes,
      relationships,
      specializations,
      entityIdCounter,
      attributeIdCounter,
      relationshipIdCounter,
      specializationIdCounter,
      fontSize,
      panOffset
    };
    
    // Log para debug antes de salvar
    console.log("Salvando no localStorage, dados:", {
      entidades: entities.length,
      atributos: attributes.length,
      relacionamentos: relationships.length,
      especializacoes: specializations.length
    });
    
    const jsonData = JSON.stringify(currentData);
    localStorage.setItem("diagramData", jsonData);
    
    // Verificação de que foi salvo corretamente
    const savedData = localStorage.getItem("diagramData");
    const savedSuccess = savedData === jsonData;
    
    // Mostra indicador de autosave
    const indicator = document.getElementById("autosave-indicator");
    if (indicator) {
      indicator.textContent = savedSuccess ? 
        "Salvo " + new Date().toLocaleTimeString() : 
        "Erro de verificação ao salvar";
      
      indicator.classList.remove("opacity-0");
      indicator.classList.add("opacity-100");
      
      // Esconde o indicador após 2 segundos
      setTimeout(() => {
        indicator.classList.remove("opacity-100");
        indicator.classList.add("opacity-0");
      }, 2000);
    }
    
    console.log("Diagrama salvo no localStorage:", new Date().toLocaleTimeString(), savedSuccess ? "✓" : "✗");
    return savedSuccess;
  } catch (err) {
    console.error("Erro ao salvar no localStorage:", err);
    
    // Mostra erro no indicador
    const indicator = document.getElementById("autosave-indicator");
    if (indicator) {
      indicator.classList.remove("opacity-0");
      indicator.classList.add("opacity-100");
      indicator.classList.remove("text-green-400");
      indicator.classList.add("text-red-500");
      indicator.textContent = "Erro ao salvar: " + err.message;
      
      // Esconde após 3 segundos
      setTimeout(() => {
        indicator.classList.remove("opacity-100");
        indicator.classList.add("opacity-0");
        indicator.classList.add("text-green-400");
        indicator.classList.remove("text-red-500");
      }, 3000);
    }
    return false;
  }
}

// Importante: Garante que não salvamos um estado vazio se o carregamento falhar
function saveState() {
  // Não salva um estado vazio se não houver operações reais
  if (entities.length === 0 && attributes.length === 0 &&
      relationships.length === 0 && specializations.length === 0 &&
      undoStack.length === 0) {
    console.log("Ignorando salvar estado vazio inicial");
    return;
  }

  // Salva no stack de Undo/Redo
  const state = {
    entities: JSON.parse(JSON.stringify(entities)),
    attributes: JSON.parse(JSON.stringify(attributes)),
    relationships: JSON.parse(JSON.stringify(relationships)),
    specializations: JSON.parse(JSON.stringify(specializations))
  };
  undoStack.push(state);
  redoStack = [];

  // Marca que há mudanças não salvas
  hasUnsavedChanges = true;
  
  // Salva imediatamente no localStorage
  saveToLocalStorage();
}


// Função para salvar o diagrama em um arquivo
function saveDiagramToFile() {
  try {
    // Cria um objeto com todos os dados do diagrama
    const diagramData = {
      entities,
      attributes,
      relationships,
      specializations,
      entityIdCounter,
      attributeIdCounter,
      relationshipIdCounter,
      specializationIdCounter,
      fontSize,
      panOffset,
      version: "1.0" // Útil para compatibilidade futura
    };
    
    // Converte para JSON e cria um Blob
    const jsonData = JSON.stringify(diagramData, null, 2);
    const blob = new Blob([jsonData], { type: "application/json" });
    
    // Cria um link para download e dispara o clique
    const link = document.createElement("a");
    link.href = URL.createObjectURL(blob);
    
    // Gera um nome de arquivo baseado na data e hora atual
    const now = new Date();
    const dateStr = now.toISOString().slice(0, 10).replace(/-/g, "");
    const timeStr = now.toTimeString().slice(0, 8).replace(/:/g, "");
    link.download = `diagrama_er_${dateStr}_${timeStr}.merdb`; // .merdb = Modelagem ER DataBase
    
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    // Mostra uma mensagem de sucesso
    showNotification("Diagrama salvo com sucesso!", "success");
  } catch (err) {
    console.error("Erro ao salvar diagrama em arquivo:", err);
    showNotification("Erro ao salvar o arquivo: " + err.message, "error");
  }
}


// Função para abrir o seletor de arquivos
function openFileSelector() {
  document.getElementById("fileInput").click();
}

// Função para carregar um diagrama de um arquivo
function loadDiagramFromFile(file) {
  const reader = new FileReader();
  
  reader.onload = function(event) {
    try {
      const jsonData = event.target.result;
      const diagramData = JSON.parse(jsonData);
      
      // Verifica se o arquivo tem o formato esperado
      if (!diagramData.entities || !Array.isArray(diagramData.entities)) {
        throw new Error("Formato de arquivo inválido");
      }
      
      // Abre o modal de confirmação
      const modal = document.getElementById("loadModal");
      modal.classList.remove("hidden");
      
      // Configura os botões do modal
      document.getElementById("loadCancelBtn").onclick = function() {
        modal.classList.add("hidden");
      };
      
      document.getElementById("loadConfirmBtn").onclick = function() {
        // Carrega os dados do arquivo
        entities = diagramData.entities || [];
        attributes = diagramData.attributes || [];
        relationships = diagramData.relationships || [];
        specializations = diagramData.specializations || [];
        
        // Carrega os contadores
        entityIdCounter = diagramData.entityIdCounter || 0;
        attributeIdCounter = diagramData.attributeIdCounter || 0;
        relationshipIdCounter = diagramData.relationshipIdCounter || 0;
        specializationIdCounter = diagramData.specializationIdCounter || 0;
        
        // Carrega as configurações visuais
        if (diagramData.fontSize) fontSize = diagramData.fontSize;
        if (diagramData.panOffset) panOffset = diagramData.panOffset;
        
        // Salva no localStorage também
        saveToLocalStorage();
        
        // Atualiza o desenho
        draw();
        
        // Fecha o modal
        modal.classList.add("hidden");
        
        // Mostra uma mensagem de sucesso
        showNotification("Diagrama carregado com sucesso!", "success");
      };
    } catch (err) {
      console.error("Erro ao carregar arquivo:", err);
      showNotification("Erro ao carregar o arquivo: " + err.message, "error");
    }
  };
  
  reader.onerror = function() {
    showNotification("Erro ao ler o arquivo", "error");
  };
  
  reader.readAsText(file);
}


// Função para mostrar notificações
function showNotification(message, type = "info") {
  const indicator = document.getElementById("autosave-indicator");
  if (!indicator) return;
  
  // Configura a cor baseada no tipo
  indicator.classList.remove("text-green-400", "text-red-500", "text-blue-400");
  
  if (type === "success") {
    indicator.classList.add("text-green-400");
  } else if (type === "error") {
    indicator.classList.add("text-red-500");
  } else {
    indicator.classList.add("text-blue-400");
  }
  
  // Define a mensagem e mostra
  indicator.textContent = message;
  indicator.classList.remove("opacity-0");
  indicator.classList.add("opacity-100");
  
  // Esconde após 3 segundos
  setTimeout(() => {
    indicator.classList.remove("opacity-100");
    indicator.classList.add("opacity-0");
  }, 3000);
}



  function undo() {
    if (undoStack.length > 0) {
      const currentState = {
        entities: JSON.parse(JSON.stringify(entities)),
        attributes: JSON.parse(JSON.stringify(attributes)),
        relationships: JSON.parse(JSON.stringify(relationships)),
        specializations: JSON.parse(JSON.stringify(specializations))
      };
      redoStack.push(currentState);
      const prevState = undoStack.pop();
      restoreState(prevState);
    }
  }


  function redo() {
    if (redoStack.length > 0) {
      const currentState = {
        entities: JSON.parse(JSON.stringify(entities)),
        attributes: JSON.parse(JSON.stringify(attributes)),
        relationships: JSON.parse(JSON.stringify(relationships)),
        specializations: JSON.parse(JSON.stringify(specializations))
      };
      undoStack.push(currentState);
      const nextState = redoStack.pop();
      restoreState(nextState);
    }
  }

    function breakLongWord(word, maxWidth, context) {
      let lines = [], current = "";
      for (let i = 0; i < word.length; i++) {
        let test = current + word[i];
        if (context.measureText(test).width > maxWidth && current !== "") {
          lines.push(current);
          current = word[i];
        } else {
          current = test;
        }
      }
      if (current !== "") lines.push(current);
      return lines;
    }
    function wrapText(context, text, maxWidth) {
      let words = text.split(" "), processed = [];
      for (let w of words) {
        if (context.measureText(w).width > maxWidth) {
          processed.push(...breakLongWord(w, maxWidth, context));
        } else {
          processed.push(w);
        }
      }
      let lines = [], currentLine = processed[0] || "";
      for (let i = 1; i < processed.length; i++) {
        let testLine = currentLine + " " + processed[i];
        if (context.measureText(testLine).width <= maxWidth) {
          currentLine = testLine;
        } else {
          lines.push(currentLine);
          currentLine = processed[i];
        }
      }
      if (currentLine !== "") lines.push(currentLine);
      return lines;
    }
    function drawWrappedText(context, text, centerX, centerY, maxWidth, isPrimary) {
      context.textAlign = "center";
      context.textBaseline = "middle";
      const lines = wrapText(context, text, maxWidth);
      const lineHeight = fontSize * 1.2;
      const totalHeight = lines.length * lineHeight;
      let y = centerY - totalHeight / 2 + lineHeight / 2;
      for (let i = 0; i < lines.length; i++) {
        let line = lines[i];
        context.fillText(line, centerX, y);
        if (isPrimary && i === 0) {
          const textWidth = context.measureText(line).width;
          context.fillRect(centerX - textWidth/2, y + fontSize*0.4, textWidth, 1);
        }
        y += lineHeight;
      }
      return lines;
    }
    function getRectBorderPoint(cx, cy, dx, dy, hw, hh) {
      if (dx === 0 && dy === 0) return { x: cx, y: cy };
      const scaleX = hw / Math.abs(dx);
      const scaleY = hh / Math.abs(dy);
      const f = Math.min(scaleX, scaleY);
      return { x: cx + dx * f, y: cy + dy * f };
    }
    function getCircleBorderPoint(cx, cy, dx, dy, radiusX, radiusY) {
      const angle = Math.atan2(dy, dx);
      const rx = radiusX || defaultAttributeRadiusX;
      const ry = radiusY || defaultAttributeRadiusY;
      return {
        x: cx + rx * Math.cos(angle),
        y: cy + ry * Math.sin(angle)
      };
    }
    function getDiamondBorderPoint(cx, cy, dx, dy, half) {
      const denom = Math.abs(dx) + Math.abs(dy);
      if (denom === 0) return { x: cx, y: cy };
      const f = half / denom;
      return { x: cx + dx * f, y: cy + dy * f };
    }
    function getSpecializationVertices(spec) {
      let side = spec.size || defaultSpecializationSize;
      let cx = spec.x, cy = spec.y;
      let v1 = { x: cx, y: cy - (Math.sqrt(3)/3)*side };
      let v2 = { x: cx - side/2, y: cy + (Math.sqrt(3)/6)*side };
      let v3 = { x: cx + side/2, y: cy + (Math.sqrt(3)/6)*side };
      return [v1, v2, v3];
    }
    // Calcula a interseção entre a linha e os lados do triângulo (especialização)
    function getTriangleBorderPoint(spec, mousePos) {
      let vertices = getSpecializationVertices(spec);
      let center = { x: spec.x, y: spec.y };
      let dx = mousePos.x - center.x;
      let dy = mousePos.y - center.y;
      let intersections = [];
      for (let i = 0; i < 3; i++) {
        let v1 = vertices[i];
        let v2 = vertices[(i+1)%3];
        let inter = getLineIntersection(center, { x: center.x + dx, y: center.y + dy }, v1, v2);
        if (inter) {
          if ((inter.x - center.x)*dx + (inter.y - center.y)*dy >= 0) {
            intersections.push(inter);
          }
        }
      }
      if (intersections.length > 0) {
        let minDist = Infinity, chosen = null;
        for (let p of intersections) {
          let d = Math.hypot(p.x - center.x, p.y - center.y);
          if (d < minDist) { minDist = d; chosen = p; }
        }
        return chosen;
      }
      return center;
    }
    function getLineIntersection(p0, p1, p2, p3) {
      let s1_x = p1.x - p0.x;
      let s1_y = p1.y - p0.y;
      let s2_x = p3.x - p2.x;
      let s2_y = p3.y - p2.y;
      let denom = (-s2_x * s1_y + s1_x * s2_y);
      if (denom === 0) return null;
      let s = (-s1_y * (p0.x - p2.x) + s1_x * (p0.y - p2.y)) / denom;
      let t = ( s2_x * (p0.y - p2.y) - s2_y * (p0.x - p2.x)) / denom;
      if (s >= 0 && s <= 1 && t >= 0 && t <= 1) {
          return { x: p0.x + (t * s1_x), y: p0.y + (t * s1_y) };
      }
      return null;
    }

    function isInsideRect(pos, rect) {
      // Transforma as coordenadas do rect para o espaço da tela
      let screenRectX = (rect.x + panOffset.x) * zoom;
      let screenRectY = (rect.y + panOffset.y) * zoom;
      let screenRectWidth = rect.width * zoom;
      let screenRectHeight = rect.height * zoom;

      // Transforma as coordenadas do clique para o espaço da tela
      let screenPosX = (pos.x + panOffset.x) * zoom;
      let screenPosY = (pos.y + panOffset.y) * zoom;

      return screenPosX >= screenRectX && 
            screenPosX <= screenRectX + screenRectWidth && 
            screenPosY >= screenRectY && 
            screenPosY <= screenRectY + screenRectHeight;
    }

// Certifique-se de que getMousePos() está consistente com estas alterações
function getMousePos(evt) {
  const rect = canvas.getBoundingClientRect();
  let clientX = evt.clientX, clientY = evt.clientY;
  if (evt.touches && evt.touches.length > 0) {
    clientX = evt.touches[0].clientX;
    clientY = evt.touches[0].clientY;
  }
  return { 
    x: (clientX - rect.left) / zoom - panOffset.x, 
    y: (clientY - rect.top) / zoom - panOffset.y 
  };
}

    function distancePointToSegment(p, a, b) {
      const A = p.x - a.x, B = p.y - a.y;
      const C = b.x - a.x, D = b.y - a.y;
      const dot = A * C + B * D;
      const len_sq = C * C + D * D;
      let param = (len_sq !== 0) ? dot / len_sq : -1;
      let xx, yy;
      if (param < 0) { xx = a.x; yy = a.y; }
      else if (param > 1) { xx = b.x; yy = b.y; }
      else { xx = a.x + param * C; yy = a.y + param * D; }
      let dx = p.x - xx, dy = p.y - yy;
      return Math.sqrt(dx * dx + dy * dy);
    }

    function drawAll(context) {
      context.clearRect(0, 0, mainWidth, mainHeight);
      context.font = `${fontSize}px Poppins`;

      attributes.forEach(a => {
        if (a.parentType && a.parentId != null) {
          context.strokeStyle = "#000000";
          context.lineWidth = 2;
          if (a.parentType === "entity") {
            const e = entities.find(en => en.id === a.parentId);
            if (e) {
              const eCenter = { x: e.x + e.width/2, y: e.y + e.height/2 };
              const aBorder = getCircleBorderPoint(a.x, a.y, eCenter.x - a.x, eCenter.y - a.y, a.radiusX, a.radiusY);
              const eBorder = getRectBorderPoint(eCenter.x, eCenter.y, a.x - eCenter.x, a.y - eCenter.y, e.width/2, e.height/2);
              context.beginPath();
              context.moveTo(eBorder.x, eBorder.y);
              context.lineTo(aBorder.x, aBorder.y);
              context.stroke();
            }
          } else if (a.parentType === "relationship") {
            const r = relationships.find(rr => rr.id === a.parentId);
            if (r) {
              const rBorder = getDiamondBorderPoint(r.x, r.y, a.x - r.x, a.y - r.y, r.size/2);
              const aBorder = getCircleBorderPoint(a.x, a.y, r.x - a.x, r.y - a.y, a.radiusX, a.radiusY);
              context.beginPath();
              context.moveTo(rBorder.x, rBorder.y);
              context.lineTo(aBorder.x, aBorder.y);
              context.stroke();
            }
          } else if (a.parentType === "attribute") {
            const pA = attributes.find(at => at.id === a.parentId);
            if (pA) {
              const dx = a.x - pA.x, dy = a.y - pA.y;
              const pBorder = getCircleBorderPoint(pA.x, pA.y, dx, dy, pA.radiusX, pA.radiusY);
              const cBorder = getCircleBorderPoint(a.x, a.y, -dx, -dy, a.radiusX, a.radiusY);
              context.beginPath();
              context.moveTo(pBorder.x, pBorder.y);
              context.lineTo(cBorder.x, cBorder.y);
              context.stroke();
            }
          }
        }
      });

      relationships.forEach(r => {
        r.connections.forEach(conn => {
          const e = entities.find(en => en.id === conn.entityId);
          if (e) drawConnectionLine(context, r, conn, e);
        });
      });

      specializations.forEach(spec => {
        if (spec.connections) {
          spec.connections.forEach(conn => {
            const e = entities.find(en => en.id === conn.entityId);
            if (e) drawSpecConnectionLine(context, spec, conn, e);
          });
        }
      });

      entities.forEach(e => {
        context.save();
        context.shadowColor = "rgba(0,0,0,0.5)";
        context.shadowBlur = 10;
        context.fillStyle = normalColors.entity.fill;
        context.strokeStyle = e.selected ? "#60a5fa" : normalColors.entity.stroke;
        context.lineWidth = e.selected ? 3 : 2;
        const margin = 16;
        let w = e.width || defaultEntityWidth;
        let h = e.height || defaultEntityHeight;
        const lines = wrapText(context, e.name, w - margin);
        let maxLineWidth = 0;
        lines.forEach(line => {
          let tw = context.measureText(line).width;
          if (tw > maxLineWidth) maxLineWidth = tw;
        });
        let lineHeight = fontSize * 1.2;
        let neededH = lines.length * lineHeight + margin;
        let neededW = maxLineWidth + margin;
        e.width = Math.max(w, neededW);
        e.height = Math.max(h, neededH);
        context.beginPath();
        context.roundRect(e.x, e.y, e.width, e.height, 8);
        context.fill();
        context.stroke();
        context.fillStyle = "#ffffff";
        drawWrappedText(context, e.name, e.x + e.width/2, e.y + e.height/2, e.width - margin, false);
        if (e.selected) {
          e.resizeHandles = [
            { x: e.x - handleSize/2, y: e.y - handleSize/2, width: handleSize, height: handleSize },
            { x: e.x + e.width - handleSize/2, y: e.y - handleSize/2, width: handleSize, height: handleSize },
            { x: e.x - handleSize/2, y: e.y + e.height - handleSize/2, width: handleSize, height: handleSize },
            { x: e.x + e.width - handleSize/2, y: e.y + e.height - handleSize/2, width: handleSize, height: handleSize }
          ];
          e.resizeHandles.forEach(handle => {
            context.fillStyle = "#ffffff";
            context.strokeStyle = "#000000";
            context.fillRect(handle.x, handle.y, handle.width, handle.height);
            context.strokeRect(handle.x, handle.y, handle.width, handle.height);
          });
        } else {
          e.resizeHandles = [];
        }
        context.restore();
      });

      attributes.forEach(a => {
        context.save();
        context.shadowColor = "rgba(0,0,0,0.5)";
        context.shadowBlur = 10;
        context.fillStyle = a.derived ? normalColors.derived.fill : normalColors.attribute.fill;
        context.strokeStyle = a.selected ? "#60a5fa" : (a.derived ? normalColors.derived.stroke : normalColors.attribute.stroke);
        context.lineWidth = a.selected ? 3 : 2;
        if (a.derived) context.setLineDash([4, 2]);
        const margin = 12;
        let rx = a.radiusX || defaultAttributeRadiusX;
        let ry = a.radiusY || defaultAttributeRadiusY;
        const lines = wrapText(context, a.name, rx*2 - margin);
        let maxLineWidth = 0;
        lines.forEach(line => {
          let tw = context.measureText(line).width;
          if (tw > maxLineWidth) maxLineWidth = tw;
        });
        let neededWidth = maxLineWidth + margin;
        let neededHeight = lines.length*(fontSize*1.2) + margin;
        rx = Math.max(rx, neededWidth / 2);
        ry = Math.max(ry, neededHeight / 2);
        a.radiusX = rx;
        a.radiusY = ry;
        context.beginPath();
        context.ellipse(a.x, a.y, rx, ry, 0, 0, 2*Math.PI);
        context.fill();
        context.stroke();
        context.setLineDash([]);
        context.fillStyle = "#ffffff";
        drawWrappedText(context, a.name, a.x, a.y, rx*2 - margin, a.primary);
        if (a.selected) {
          a.resizeHandles = [
            { x: a.x - rx - handleSize/2, y: a.y - handleSize/2, width: handleSize, height: handleSize },
            { x: a.x + rx - handleSize/2, y: a.y - handleSize/2, width: handleSize, height: handleSize },
            { x: a.x - handleSize/2, y: a.y - ry - handleSize/2, width: handleSize, height: handleSize },
            { x: a.x - handleSize/2, y: a.y + ry - handleSize/2, width: handleSize, height: handleSize }
          ];
          a.resizeHandles.forEach(handle => {
            context.fillStyle = "#ffffff";
            context.strokeStyle = "#000000";
            context.fillRect(handle.x, handle.y, handle.width, handle.height);
            context.strokeRect(handle.x, handle.y, handle.width, handle.height);
          });
        } else {
          a.resizeHandles = [];
        }
        context.restore();
      });

      relationships.forEach(r => {
        context.save();
        context.shadowColor = "rgba(0,0,0,0.5)";
        context.shadowBlur = 10;
        context.fillStyle = normalColors.relationship.fill;
        context.strokeStyle = r.selected ? "#60a5fa" : normalColors.relationship.stroke;
        context.lineWidth = r.selected ? 3 : 2;
        const half = (r.size || relationshipSize)/2;
        context.beginPath();
        context.moveTo(r.x, r.y - half);
        context.lineTo(r.x + half, r.y);
        context.lineTo(r.x, r.y + half);
        context.lineTo(r.x - half, r.y);
        context.closePath();
        context.fill();
        context.stroke();
        // Desenha o texto do relacionamento por cima (não interfere nas conexões)
        context.fillStyle = "#ffffff";
        drawWrappedText(context, r.name, r.x, r.y, r.size - 20, false);
        if (r.selected) {
          r.resizeHandles = [
            { x: r.x - half - handleSize/2, y: r.y - handleSize/2, width: handleSize, height: handleSize },
            { x: r.x + half - handleSize/2, y: r.y - handleSize/2, width: handleSize, height: handleSize },
            { x: r.x - handleSize/2, y: r.y - half - handleSize/2, width: handleSize, height: handleSize },
            { x: r.x - handleSize/2, y: r.y + half - handleSize/2, width: handleSize, height: handleSize }
          ];
          r.resizeHandles.forEach(handle => {
            context.fillStyle = "#ffffff";
            context.strokeStyle = "#000000";
            context.fillRect(handle.x, handle.y, handle.width, handle.height);
            context.strokeRect(handle.x, handle.y, handle.width, handle.height);
          });
        } else {
          r.resizeHandles = [];
        }
        context.restore();
      });

      specializations.forEach(spec => {
        context.save();
        context.shadowColor = "rgba(0,0,0,0.5)";
        context.shadowBlur = 10;
        context.fillStyle = normalColors.specialization.fill;
        context.strokeStyle = spec.selected ? "#60a5fa" : normalColors.specialization.stroke;
        context.lineWidth = spec.selected ? 3 : 2;
        const vertices = getSpecializationVertices(spec);
        context.beginPath();
        context.moveTo(vertices[0].x, vertices[0].y);
        context.lineTo(vertices[1].x, vertices[1].y);
        context.lineTo(vertices[2].x, vertices[2].y);
        context.closePath();
        context.fill();
        context.stroke();
        context.fillStyle = "#ffffff";
        drawWrappedText(context, spec.genType || "", spec.x, spec.y, spec.size - 20, false);
        if (spec.selected) {
          spec.resizeHandles = vertices.map(v => ({
            x: v.x - handleSize/2,
            y: v.y - handleSize/2,
            width: handleSize,
            height: handleSize
          }));
          spec.resizeHandles.forEach(handle => {
            context.fillStyle = "#ffffff";
            context.strokeStyle = "#000000";
            context.fillRect(handle.x, handle.y, handle.width, handle.height);
            context.strokeRect(handle.x, handle.y, handle.width, handle.height);
          });
        } else {
          spec.resizeHandles = [];
        }
        context.restore();
      });

      if (isSelecting && selectionRect) {
        context.save();
        context.setLineDash([4,2]);
        context.strokeStyle = "rgba(96,165,250,0.7)";
        context.strokeRect(selectionRect.x, selectionRect.y, selectionRect.width, selectionRect.height);
        context.restore();
      }
    }


    function drawDeletionIconForConnection(context, r, conn) {
  // Calcule os pontos da polyline
  const rCenter = { x: r.x, y: r.y };
  const e = entities.find(en => en.id === conn.entityId);
  if (!e) return;
  const eCenter = { x: e.x + e.width / 2, y: e.y + e.height / 2 };
  let points = [rCenter];
  if (conn.breakpoints) {
    points.push(...conn.breakpoints);
  }
  points.push(eCenter);
  
  // Para posicionar o ícone, use uma fração do primeiro segmento (por exemplo, 35%)
  let fraction = 0.35;
  let start = points[0];
  let next = points[1]; // garante que há pelo menos dois pontos
  let iconPos = {
    x: start.x + (next.x - start.x) * fraction,
    y: start.y + (next.y - start.y) * fraction
  };

  let iconSize = globalIconSize + 4;
  
  // Desenha o ícone (X)
  context.save();
  context.fillStyle = "#b91c1c";
  context.beginPath();
  context.arc(iconPos.x, iconPos.y, iconSize / 2, 0, 2 * Math.PI);
  context.fill();
  context.strokeStyle = "#ffffff";
  context.lineWidth = 2;
  context.beginPath();
  context.moveTo(iconPos.x - iconSize/4, iconPos.y - iconSize/4);
  context.lineTo(iconPos.x + iconSize/4, iconPos.y + iconSize/4);
  context.moveTo(iconPos.x + iconSize/4, iconPos.y - iconSize/4);
  context.lineTo(iconPos.x - iconSize/4, iconPos.y + iconSize/4);
  context.stroke();
  context.restore();

  // Armazena a posição para detecção de clique
  conn.iconRect = {
    x: iconPos.x - iconSize/2,
    y: iconPos.y - iconSize/2,
    width: iconSize,
    height: iconSize
  };
}


function drawDeletionIconForSpecConnection(context, spec, conn) {
  const vertex = getSpecializationVertices(spec)[conn.vertex];
  const e = entities.find(en => en.id === conn.entityId);
  if (!e) return;
  const eCenter = { x: e.x + e.width / 2, y: e.y + e.height / 2 };
  let points = [vertex];
  if (conn.breakpoints && conn.breakpoints.length > 0) {
    points.push(...conn.breakpoints);
  }
  let eBoundary = getRectBorderPoint(
    eCenter.x, eCenter.y,
    points[points.length - 1].x - eCenter.x,
    points[points.length - 1].y - eCenter.y,
    e.width / 2, e.height / 2
  );
  points.push(eBoundary);
  
  // Para especialização, use uma fração menor (por exemplo, 20%)
  let fraction = 0.2;
  let start = points[0];
  let next = points[1];
  let iconPos = {
    x: start.x + (next.x - start.x) * fraction,
    y: start.y + (next.y - start.y) * fraction
  };

  let iconSize = globalIconSize + 4;
  
  context.save();
  context.fillStyle = "#b91c1c";
  context.beginPath();
  context.arc(iconPos.x, iconPos.y, iconSize / 2, 0, 2 * Math.PI);
  context.fill();
  context.strokeStyle = "#ffffff";
  context.lineWidth = 2;
  context.beginPath();
  context.moveTo(iconPos.x - iconSize/4, iconPos.y - iconSize/4);
  context.lineTo(iconPos.x + iconSize/4, iconPos.y + iconSize/4);
  context.moveTo(iconPos.x + iconSize/4, iconPos.y - iconSize/4);
  context.lineTo(iconPos.x - iconSize/4, iconPos.y + iconSize/4);
  context.stroke();
  context.restore();

  conn.iconRect = {
    x: iconPos.x - iconSize/2,
    y: iconPos.y - iconSize/2,
    width: iconSize,
    height: iconSize
  };
}


function drawDeletionIcons(context) {
  // Para conexões de relacionamento:
  relationships.forEach(r => {
    r.connections.forEach(conn => {
      if (selectedConnection &&
          selectedConnection.relationshipId === r.id &&
          selectedConnection.entityId === conn.entityId) {
        drawDeletionIconForConnection(context, r, conn);
      }
    });
  });
  
  // Para conexões de especialização:
  specializations.forEach(spec => {
    if (spec.connections) {
      spec.connections.forEach(conn => {
        if (selectedSpecConnection &&
            selectedSpecConnection.specializationId === spec.id &&
            selectedSpecConnection.vertex === conn.vertex &&
            selectedSpecConnection.entityId === conn.entityId) {
          drawDeletionIconForSpecConnection(context, spec, conn);
        }
      });
    }
  });
}

    
    function drawConnectionLine(context, r, conn, e) {
  const rCenter = { x: r.x, y: r.y };
  const eCenter = { x: e.x + e.width / 2, y: e.y + e.height / 2 };
  let points = [rCenter];
  if (conn.breakpoints) {
    points.push(...conn.breakpoints);
  }
  points.push(eCenter);

  // Desenho da polilinha
  context.beginPath();
  context.moveTo(points[0].x, points[0].y);
  for (let i = 1; i < points.length; i++) {
    context.lineTo(points[i].x, points[i].y);
  }
  context.lineWidth = (selectedConnection && 
                       selectedConnection.relationshipId === r.id && 
                       selectedConnection.entityId === conn.entityId) ? 4 : 2;
  context.strokeStyle = "#000000";
  context.stroke();

  // Desenho dos breakpoints
  if (conn.breakpoints) {
    for (let bp of conn.breakpoints) {
      context.beginPath();
      context.arc(bp.x, bp.y, 5, 0, 2*Math.PI);
      context.fillStyle = "#000000";
      context.fill();
    }
  }

  // Calcula o ponto médio e desenha a cardinalidade
  let labelPos = getPolylineMidpoint(points);
  context.fillStyle = "#000000";
  context.fillText(conn.cardinality, labelPos.x, labelPos.y - 5);

  let textWidth = context.measureText(conn.cardinality).width;
  conn.labelRect = {
    x: labelPos.x - textWidth / 2,
    y: (labelPos.y - 5) - fontSize,
    width: textWidth,
    height: fontSize
  };

  // Desenha o ícone de exclusão
  if (selectedConnection && 
      selectedConnection.relationshipId === r.id && 
      selectedConnection.entityId === conn.entityId) {
    // Calcula a posição do ícone de exclusão
  let iconPos;
  if (points.length === 2) {
    // Sem breakpoints: ponto médio da linha reta
    iconPos = {
      x: (points[0].x + points[1].x) / 2,
      y: (points[0].y + points[1].y) / 2
    };
  } else {
    // Com breakpoints: usa getPolylineMidpoint
    iconPos = getPolylineMidpoint(points);
  }

  let iconSize = globalIconSize + 4;
  // Calcula o ponto de ícone a 35% do primeiro segmento
  let fraction = 0.35;
    let start = points[0];
    let next = points[1]; // Garantido pois a polyline tem pelo menos 2 pontos
    iconPos = {
      x: start.x + (next.x - start.x) * fraction,
      y: start.y + (next.y - start.y) * fraction
    };
    let delX = iconPos.x;
    let delY = iconPos.y;

    context.save();
    context.fillStyle = "#b91c1c";
    context.beginPath();
    context.arc(delX, delY, iconSize / 2, 0, 2*Math.PI);
    context.fill();
    context.strokeStyle = "#ffffff";
    context.lineWidth = 2;
    context.beginPath();
    context.moveTo(delX - iconSize/4, delY - iconSize/4);
    context.lineTo(delX + iconSize/4, delY + iconSize/4);
    context.moveTo(delX + iconSize/4, delY - iconSize/4);
    context.lineTo(delX - iconSize/4, delY + iconSize/4);
    context.stroke();
    context.restore();

    selectedConnection.iconRect = {
      x: delX - iconSize/2,
      y: delY - iconSize/2,
      width: iconSize,
      height: iconSize
    };
  }
}

function drawSpecConnectionLine(context, spec, conn, e) {
  const vertex = getSpecializationVertices(spec)[conn.vertex];
  const eCenter = { x: e.x + e.width / 2, y: e.y + e.height / 2 };
  let points = [vertex];
  if (conn.breakpoints && conn.breakpoints.length > 0) {
    points.push(...conn.breakpoints);
  }
  let eBoundary = getRectBorderPoint(
    eCenter.x, eCenter.y, 
    points[points.length - 1].x - eCenter.x, 
    points[points.length - 1].y - eCenter.y, 
    e.width / 2, e.height / 2
  );
  points.push(eBoundary);

  // Desenho da polilinha
  context.beginPath();
  context.moveTo(points[0].x, points[0].y);
  for (let i = 1; i < points.length; i++) {
    context.lineTo(points[i].x, points[i].y);
  }
  context.lineWidth = (selectedSpecConnection &&
    selectedSpecConnection.specializationId === spec.id &&
    selectedSpecConnection.vertex === conn.vertex &&
    selectedSpecConnection.entityId === conn.entityId) ? 4 : 2;
  context.strokeStyle = "#000000";
  context.stroke();

  // Desenho dos breakpoints
  if (conn.breakpoints && conn.breakpoints.length > 0) {
    for (let bp of conn.breakpoints) {
      context.beginPath();
      context.arc(bp.x, bp.y, 5, 0, 2 * Math.PI);
      context.fillStyle = "#000000";
      context.fill();
    }
  }

  // Calcula a posição do ícone de exclusão
  let iconPos;
  if (points.length === 2) {
    // Sem breakpoints: ponto médio da linha reta
    iconPos = {
      x: (points[0].x + points[1].x) / 2,
      y: (points[0].y + points[1].y) / 2
    };
  } else {
    // Com breakpoints: usa getPolylineMidpoint
    iconPos = getPolylineMidpoint(points);
  }

  let iconSize = globalIconSize + 4;
  // Calcula o ponto de ícone a 20% do primeiro segmento
  let fraction = 0.2;
    let start = points[0];
    let next = points[1]; // Garantido pois a polyline tem pelo menos 2 pontos
    iconPos = {
      x: start.x + (next.x - start.x) * fraction,
      y: start.y + (next.y - start.y) * fraction
    };
    let delX = iconPos.x;
    let delY = iconPos.y;

  if (selectedSpecConnection &&
      selectedSpecConnection.specializationId === spec.id &&
      selectedSpecConnection.vertex === conn.vertex &&
      selectedSpecConnection.entityId === conn.entityId) {
    context.save();
    context.fillStyle = "#b91c1c";
    context.beginPath();
    context.arc(delX, delY, iconSize / 2, 0, 2 * Math.PI);
    context.fill();
    context.strokeStyle = "#ffffff";
    context.lineWidth = 2;
    context.beginPath();
    context.moveTo(delX - iconSize / 4, delY - iconSize / 4);
    context.lineTo(delX + iconSize / 4, delY + iconSize / 4);
    context.moveTo(delX + iconSize / 4, delY - iconSize / 4);
    context.lineTo(delX - iconSize / 4, delY + iconSize / 4);
    context.stroke();
    context.restore();

    selectedSpecConnection.iconRect = { 
      x: delX - iconSize / 2, 
      y: delY - iconSize / 2, 
      width: iconSize, 
      height: iconSize 
    };
  }
}    


// 4. Função drawPreview corrigida para centralizar TODOS os objetos corretamente
function drawPreview() {
  if (!draggingToolbarType || !draggingNewObj) return;
  
  ctx.save();
  ctx.globalAlpha = 0.7;
  
  // Pegar as coordenadas do centro
  const centerX = draggingNewObj.x;
  const centerY = draggingNewObj.y;
  
  switch(draggingToolbarType) {
    case "entity":
      // Centraliza o retângulo nas coordenadas do mouse
      ctx.fillStyle = normalColors.entity.fill;
      ctx.strokeStyle = normalColors.entity.stroke;
      ctx.beginPath();
      ctx.roundRect(
        centerX - defaultEntityWidth/2,   // X ajustado para centralizar 
        centerY - defaultEntityHeight/2,  // Y ajustado para centralizar
        defaultEntityWidth, 
        defaultEntityHeight, 
        8
      );
      ctx.fill();
      ctx.stroke();
      break;
      
    case "attribute":
      // Para atributos, o centro da elipse já é centralizado
      ctx.fillStyle = normalColors.attribute.fill;
      ctx.strokeStyle = normalColors.attribute.stroke;
      ctx.beginPath();
      ctx.ellipse(
        centerX,   // centro X 
        centerY,   // centro Y
        defaultAttributeRadiusX, 
        defaultAttributeRadiusY, 
        0, 0, Math.PI*2
      );
      ctx.fill();
      ctx.stroke();
      break;
      
    case "derivedAttribute":
      // Mesmo para atributos derivados
      ctx.fillStyle = normalColors.derived.fill;
      ctx.strokeStyle = normalColors.derived.stroke;
      ctx.beginPath();
      ctx.ellipse(
        centerX, 
        centerY, 
        defaultAttributeRadiusX, 
        defaultAttributeRadiusY, 
        0, 0, Math.PI*2
      );
      ctx.fill();
      ctx.stroke();
      break;
      
    case "relationship":
      // Para relacionamentos (losango)
      ctx.fillStyle = normalColors.relationship.fill;
      ctx.strokeStyle = normalColors.relationship.stroke;
      const half = relationshipSize/2;
      ctx.beginPath();
      ctx.moveTo(centerX, centerY - half);           // Topo
      ctx.lineTo(centerX + half, centerY);           // Direita
      ctx.lineTo(centerX, centerY + half);           // Baixo
      ctx.lineTo(centerX - half, centerY);           // Esquerda
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      break;
      
    case "specialization":
      // Para especializações (triângulo)
      ctx.fillStyle = normalColors.specialization.fill;
      ctx.strokeStyle = normalColors.specialization.stroke;
      const vertices = getSpecializationVertices({ 
        x: centerX, 
        y: centerY, 
        size: defaultSpecializationSize 
      });
      ctx.beginPath();
      ctx.moveTo(vertices[0].x, vertices[0].y);
      ctx.lineTo(vertices[1].x, vertices[1].y);
      ctx.lineTo(vertices[2].x, vertices[2].y);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      break;
  }
  
  ctx.restore();
}




// 5. Atualização da função createObjectAt para garantir objetos centralizados
function createObjectAt(type, cx, cy) {
  if (type === "attribute" || type === "derivedAttribute") {
    const drop = getDraggableAt(cx, cy);
    if (!drop || (drop.type !== "entity" && drop.type !== "relationship" && drop.type !== "attribute" && drop.type !== "derivedAttribute")) {
      alert("O atributo deve ser arrastado sobre uma entidade, relacionamento ou outro atributo.");
      cleanupToolbarDrag();
      draw();
      return;
    }
    
    // Lógica para atributos (sem mudanças, já que seguem regras específicas de posicionamento)
    let parentObj = drop.element;
    let posX, posY;
    if (drop.type === "entity") {
      posX = parentObj.x + (parentObj.width || defaultEntityWidth) + defaultAttributeRadiusX + 10;
      posY = parentObj.y + (parentObj.height || defaultEntityHeight)/2;
    } else if (drop.type === "relationship") {
      posX = parentObj.x + (parentObj.size || relationshipSize)/2 + defaultAttributeRadiusX + 10;
      posY = parentObj.y;
    } else if (drop.type === "attribute" || drop.type === "derivedAttribute") {
      posX = parentObj.x + (parentObj.radiusX || defaultAttributeRadiusX) + 10;
      posY = parentObj.y;
    }
    
    const newA = {
      id: attributeIdCounter++,
      x: posX,
      y: posY,
      name: (type === "derivedAttribute") ? "Deriv." : "Simples",
      parentType: drop.type === "derivedAttribute" ? "attribute" : drop.type,
      parentId: parentObj.id,
      derived: (type === "derivedAttribute"),
      primary: false,
      selected: false,
      radiusX: defaultAttributeRadiusX,
      radiusY: defaultAttributeRadiusY,
      objType: (type === "derivedAttribute") ? "derivedAttribute" : "attribute"
    };
    attributes.push(newA);
  } else if (type === "entity") {
    // Ajuste explícito para entidades
    const newE = {
      id: entityIdCounter++,
      x: cx - defaultEntityWidth/2,   // X ajustado para centralizar
      y: cy - defaultEntityHeight/2,  // Y ajustado para centralizar 
      width: defaultEntityWidth,
      height: defaultEntityHeight,
      name: "Entidade",
      selected: false,
      objType: "entity"
    };
    entities.push(newE);
  } else if (type === "relationship") {
    // Para relacionamentos, o centro já é a posição do mouse
    const newR = {
      id: relationshipIdCounter++,
      x: cx,  // Posição do centro X
      y: cy,  // Posição do centro Y
      size: relationshipSize,
      name: "Rel.",
      connections: [],
      selected: false,
      objType: "relationship"
    };
    relationships.push(newR);
  } else if (type === "specialization") {
    // Para especializações, o centro também já é a posição do mouse
    const newS = {
      id: specializationIdCounter++,
      x: cx,  // Posição do centro X
      y: cy,  // Posição do centro Y
      size: defaultSpecializationSize,
      genType: "T,C",
      connections: [],
      selected: false,
      objType: "specialization"
    };
    specializations.push(newS);
  }
  
  saveState();
  cleanupToolbarDrag();
  draw();
}



    // Função de desenho principal, agora aplicando a transformação de zoom
    function draw() {
      ctx.save();
      ctx.clearRect(0, 0, mainWidth, mainHeight);
      ctx.translate(panOffset.x, panOffset.y); // <-- ADICIONE esta linha
      ctx.scale(zoom, zoom);
      drawAll(ctx);
      if (draggingToolbarType && draggingNewObj) {
        drawPreview();
      }

      
      if (isDraggingConnection && draggingConnection) {
        ctx.save();
        ctx.setLineDash([5,3]);
        ctx.strokeStyle = "#000000";
        ctx.beginPath();
        // Calcula o ponto de partida da linha de preview conforme a borda do objeto de origem
        let startPoint = { x: draggingConnection.start.x, y: draggingConnection.start.y };
        const currentPos = draggingConnection.current;
        const obj = draggingConnection.element;
        if (obj.objType === "entity") {
          let center = { x: obj.x + (obj.width || defaultEntityWidth)/2, y: obj.y + (obj.height || defaultEntityHeight)/2 };
          let dx = currentPos.x - center.x;
          let dy = currentPos.y - center.y;
          startPoint = getRectBorderPoint(center.x, center.y, dx, dy, obj.width/2, obj.height/2);
        } else if (obj.objType === "relationship") {
          let center = { x: obj.x, y: obj.y };
          let dx = currentPos.x - center.x;
          let dy = currentPos.y - center.y;
          startPoint = getDiamondBorderPoint(center.x, center.y, dx, dy, obj.size/2);
        } else if (obj.objType === "specialization") {
          startPoint = getTriangleBorderPoint(obj, currentPos);
        }
        ctx.moveTo(startPoint.x, startPoint.y);
        ctx.lineTo(currentPos.x, currentPos.y);
        ctx.stroke();
        ctx.restore();
      }

      // <-- NOVA LINHA: desenha os ícones de exclusão por último
      drawDeletionIcons(ctx);


      ctx.restore();
    }

    function clearSelection() {
      entities.forEach(e => e.selected = false);
      attributes.forEach(a => a.selected = false);
      relationships.forEach(r => r.selected = false);
      specializations.forEach(s => s.selected = false);
      selectedConnection = null;
      selectedSpecConnection = null;
      if (submenu) {
        $(submenu).remove();
        submenu = null;
      }
      if (submenuTimeout) {
        clearTimeout(submenuTimeout);
        submenuTimeout = null;
      }
    }

    function checkResizeHandles(x, y) {
      let found = null;
      [...entities, ...attributes, ...relationships, ...specializations].forEach(el => {
        if (el.selected && el.resizeHandles) {
          el.resizeHandles.forEach((handle, idx) => {
            if (isInsideRect({x,y}, handle)) {
              found = { type: "resize", element: el, handleIndex: idx };
            }
          });
        }
      });
      return found;
    }

    
    function getDraggableAt(x, y) {
  if (submenu && isInsideRect({ x, y }, submenuRect)) return { type: "submenu" };

  let resizeHit = checkResizeHandles(x, y);
  if (resizeHit) return resizeHit;

  // Verifica entidades
  for (let i = entities.length - 1; i >= 0; i--) {
    const e = entities[i];
    let w = e.width || defaultEntityWidth, h = e.height || defaultEntityHeight;
    if (x >= e.x && x <= e.x + w && y >= e.y && y <= e.y + h) {
      return { type: "entity", element: e };
    }
  }

  // Verifica atributos
  for (let i = attributes.length - 1; i >= 0; i--) {
    const a = attributes[i];
    let rx = a.radiusX || defaultAttributeRadiusX;
    let ry = a.radiusY || defaultAttributeRadiusY;
    if (Math.pow((x - a.x) / rx, 2) + Math.pow((y - a.y) / ry, 2) <= 1) {
      return { type: a.derived ? "derivedAttribute" : "attribute", element: a };
    }
  }

  // Verifica relacionamentos
  for (let i = relationships.length - 1; i >= 0; i--) {
    const rel = relationships[i];
    let half = (rel.size || relationshipSize) / 2;
    if (x >= rel.x - half && x <= rel.x + half && y >= rel.y - half && y <= rel.y + half) {
      return { type: "relationship", element: rel };
    }
  }

  // Verifica especializações
  for (let i = specializations.length - 1; i >= 0; i--) {
    const spec = specializations[i];
    let half = (spec.size || defaultSpecializationSize) / 2;
    if (x >= spec.x - half && x <= spec.x + half && y >= spec.y - half && y <= spec.y + half) {
      return { type: "specialization", element: spec };
    }
  }

  // Verifica conexões de especialização
  for (let s of specializations) {
    if (s.connections) {
      for (let conn of s.connections) {
        let e = entities.find(en => en.id === conn.entityId);
        if (!e) continue;
        let vertex = getSpecializationVertices(s)[conn.vertex];
        let eCenter = { x: e.x + e.width / 2, y: e.y + e.height / 2 };
        let points = [vertex];
        if (conn.breakpoints && conn.breakpoints.length > 0) {
          points.push(...conn.breakpoints);
        }
        let lastPoint = points[points.length - 1];
        let eBoundary = getRectBorderPoint(
          eCenter.x, eCenter.y, 
          lastPoint.x - eCenter.x, 
          lastPoint.y - eCenter.y, 
          e.width / 2, e.height / 2
        );
        points.push(eBoundary);
        for (let i = 0; i < points.length - 1; i++) {
          if (distancePointToSegment({ x, y }, points[i], points[i + 1]) < 15) {
            return { type: "specialization-connection", specialization: s, connection: conn };
          }
        }
      }
    }
  }

  // Verifica conexões entre relacionamentos e entidades
  for (let r of relationships) {
    for (let conn of r.connections) {
      let e = entities.find(en => en.id === conn.entityId);
      if (!e) continue;
      let rCenter = { x: r.x, y: r.y };
      let eCenter = { x: e.x + e.width / 2, y: e.y + e.height / 2 };
      let points = [rCenter];
      if (conn.breakpoints && conn.breakpoints.length > 0) {
        points.push(...conn.breakpoints);
      }
      let eBoundary = getRectBorderPoint(
        eCenter.x, eCenter.y, 
        points[points.length - 1].x - eCenter.x, 
        points[points.length - 1].y - eCenter.y, 
        e.width / 2, e.height / 2
      );
      points.push(eBoundary);
      for (let i = 0; i < points.length - 1; i++) {
        if (distancePointToSegment({ x, y }, points[i], points[i + 1]) < 15) {
          return { type: "connection", relationship: r, connection: conn };
        }
      }
    }
  }

  // Verifica breakpoints nas conexões de especialização
  for (let s of specializations) {
    if (s.connections) {
      for (let conn of s.connections) {
        if (conn.breakpoints && conn.breakpoints.length > 0) {
          for (let i = 0; i < conn.breakpoints.length; i++) {
            let bp = conn.breakpoints[i];
            if (Math.hypot(x - bp.x, y - bp.y) < 8) {
              return { type: "breakpoint", connection: conn, index: i, specialization: s };
            }
          }
        }
      }
    }
  }

  // Verifica breakpoints nas conexões de relacionamento
  for (let r of relationships) {
    for (let conn of r.connections) {
      if (conn.breakpoints && conn.breakpoints.length > 0) {
        for (let i = 0; i < conn.breakpoints.length; i++) {
          let bp = conn.breakpoints[i];
          if (Math.hypot(x - bp.x, y - bp.y) < 8) {
            return { type: "breakpoint", connection: conn, index: i, relationship: r };
          }
        }
      }
    }
  }

  return null;
}

function startToolbarDrag(type, evt) {
  evt.preventDefault();
  toolbarDrag = {
    type: type,
    startX: evt.pageX,
    startY: evt.pageY,
    isDragging: false
  };
  $(document).on("mousemove.toolbarDrag", onToolbarDragMove);
  $(document).on("mouseup.toolbarDrag", onToolbarDragEnd);
}
    
function onToolbarDragMove(evt) {
  if (!toolbarDrag) return;
  
  const dx = evt.pageX - toolbarDrag.startX;
  const dy = evt.pageY - toolbarDrag.startY;
  const distance = Math.sqrt(dx*dx + dy*dy);
  const rect = canvas.getBoundingClientRect();
  
  // Coordenadas em relação ao canvas, independentemente do zoom ou pan offset
  const canvasX = (evt.pageX - rect.left) / zoom - panOffset.x;
  const canvasY = (evt.pageY - rect.top) / zoom - panOffset.y;
  
  if (!toolbarDrag.isDragging && distance > 5) {
    toolbarDrag.isDragging = true;
    draggingToolbarType = toolbarDrag.type;
    
    // Inicializa o objeto de preview centralizado no mouse
    draggingNewObj = {
      type: toolbarDrag.type,
      x: canvasX,  // Coordenada já ajustada para o pan/zoom
      y: canvasY   // Coordenada já ajustada para o pan/zoom
    };
  } else if (toolbarDrag.isDragging) {
    // Atualiza a posição do objeto enquanto arrasta, mantendo centralizado
    draggingNewObj.x = canvasX;
    draggingNewObj.y = canvasY;
  }
  
  draw();
}


function onToolbarDragEnd(evt) {
  if (!toolbarDrag) return;
  
  $(document).off("mousemove.toolbarDrag");
  $(document).off("mouseup.toolbarDrag");
  
  const rect = canvas.getBoundingClientRect();
  const canvasX = (evt.pageX - rect.left) / zoom - panOffset.x;
  const canvasY = (evt.pageY - rect.top) / zoom - panOffset.y;
  
  // Verifica se está dentro do canvas
  const viewportX = evt.pageX - rect.left;
  const viewportY = evt.pageY - rect.top;
  const isInsideCanvas = viewportX >= 0 && viewportX <= rect.width && 
                        viewportY >= 0 && viewportY <= rect.height;
  
  if (toolbarDrag.isDragging) {
    if (isInsideCanvas) {
      createObjectAt(toolbarDrag.type, canvasX, canvasY);
    }
    cleanupToolbarDrag();
  } else {
    draggingToolbarType = toolbarDrag.type;
    clickPlacementMode = true;
    if (isInsideCanvas) {
      draggingNewObj = { 
        type: toolbarDrag.type, 
        x: canvasX, 
        y: canvasY 
      };
    }
  }
  
  toolbarDrag = null;
  draw();
}

    function cleanupToolbarDrag() {
      draggingToolbarType = null;
      draggingNewObj = null;
      clickPlacementMode = false;
      toolbarDrag = null;
    }

    
    function onCanvasStart(evt) {
  evt.preventDefault();
  let pos = getMousePos(evt);

  if (selectedConnection && selectedConnection.iconRect && 
      isInsideRect(pos, selectedConnection.iconRect)) {
    return;
  }

  let hit = getDraggableAt(pos.x, pos.y);

  if (hit && hit.type === "resize") {
    isResizing = true;
    resizingObject = hit.element;
    resizeHandleIndex = hit.handleIndex;
    if (resizingObject.objType === "entity") {
      resizingInitial = {
        x: resizingObject.x,
        y: resizingObject.y,
        width: resizingObject.width,
        height: resizingObject.height
      };
    } else if (resizingObject.objType === "attribute" || resizingObject.objType === "derivedAttribute") {
      resizingInitial = {
        x: resizingObject.x,
        y: resizingObject.y,
        ratio: (resizingObject.radiusY || defaultAttributeRadiusY) / (resizingObject.radiusX || defaultAttributeRadiusX)
      };
    } else if (resizingObject.objType === "relationship" || resizingObject.objType === "specialization") {
      resizingInitial = {
        x: resizingObject.x,
        y: resizingObject.y,
        size: resizingObject.size
      };
    }
    if (!resizingObject.selected) {
      clearSelection();
      resizingObject.selected = true;
    }
    return;
  }

  if (hit && hit.type === "breakpoint") {
    isDraggingBreakpoint = true;
    activeBreakpoint = { 
      connection: hit.connection, 
      index: hit.index,
      specialization: hit.specialization || null,
      relationship: hit.relationship || null
    };
    return;
  }

  if (isSpacePressed) {
    isPanning = true;
    panStart = { x: evt.clientX, y: evt.clientY };
    panOffsetStart = { x: panOffset.x, y: panOffset.y };
    return;
  }
  if (clickPlacementMode) {
    createObjectAt(draggingToolbarType, pos.x, pos.y);
    cleanupToolbarDrag();
    draw();
    return;
  }
  if (draggingToolbarType) return;

  if (hit && hit.type === "connection") {
    pendingConnectionHit = { ...hit, startX: pos.x, startY: pos.y };
    breakpointTimeout = setTimeout(() => {
      isDraggingBreakpoint = true;
      pendingConnectionHit = null;
      if (!hit.connection.breakpoints) {
        hit.connection.breakpoints = [];
      }
      if (hit.connection.breakpoints.length === 0) {
        hit.connection.breakpoints.push({ x: pos.x, y: pos.y });
      }
      activeBreakpoint = { 
        connection: hit.connection, 
        index: 0,
        relationship: hit.relationship
      };
      clearSelection();
      draw();
    }, 300);
  }

  if (hit && hit.type === "specialization-connection") {
    pendingConnectionHit = { ...hit, startX: pos.x, startY: pos.y };
    breakpointTimeout = setTimeout(() => {
      isDraggingBreakpoint = true;
      pendingConnectionHit = null;
      if (!hit.connection.breakpoints) {
        hit.connection.breakpoints = [];
      }
      if (hit.connection.breakpoints.length === 0) {
        hit.connection.breakpoints.push({ x: pos.x, y: pos.y });
      }
      activeBreakpoint = { 
        connection: hit.connection, 
        index: 0, 
        specialization: hit.specialization 
      };
      clearSelection();
      draw();
    }, 300);
  }

  if (hit && hit.type === "specialization-connection" && selectedSpecConnection && 
      selectedSpecConnection.iconRect && isInsideRect(pos, selectedSpecConnection.iconRect)) {
    const s = specializations.find(s => s.id === selectedSpecConnection.specializationId);
    if (s) {
      s.connections = s.connections.filter(c => c.entityId !== selectedSpecConnection.entityId || 
                                        c.vertex !== selectedSpecConnection.vertex);
      saveState();
      clearSelection();
      draw();
    }
    return;
  }

  if (hit) {
    switch(hit.type) {
      case "specialization-connection":
        clearSelection();
        selectedSpecConnection = {
          specializationId: hit.specialization.id,
          entityId: hit.connection.entityId,
          vertex: hit.connection.vertex,
          iconRect: null
        };
        draw();
        return;
      case "connection":
        clearSelection();
        selectedConnection = {
          relationshipId: hit.relationship.id,
          entityId: hit.connection.entityId,
          iconRect: null
        };
        draw();
        return;
      case "entity":
      case "attribute":
      case "derivedAttribute":
      case "relationship":
      case "specialization":
        if (!hit.element.selected) {
          clearSelection();
          hit.element.selected = true;
        }
        let selectedObjects = [...entities, ...attributes, ...relationships, ...specializations].filter(obj => obj.selected);
        if (selectedObjects.length > 1) {
          isDraggingGroup = true;
          groupMouseStart = pos;
          groupDragData = selectedObjects.map(obj => ({
            obj: obj,
            startX: obj.x,
            startY: obj.y
          }));
          groupBreakpointsData = [];
           // Coleta breakpoints de relacionamentos
          relationships.forEach(r => {
            if (r.selected && r.connections) {
              r.connections.forEach(conn => {
                if (conn.breakpoints) {
                  conn.breakpoints.forEach(bp => {
                    groupBreakpointsData.push({
                      breakpoint: bp,
                      startX: bp.x,
                      startY: bp.y
                    });
                  });
                }
              });
            } else {
              r.connections.forEach(conn => {
                let ent = entities.find(e => e.id === conn.entityId);
                if (ent && ent.selected && conn.breakpoints) {
                  conn.breakpoints.forEach(bp => {
                    groupBreakpointsData.push({
                      breakpoint: bp,
                      startX: bp.x,
                      startY: bp.y
                    });
                  });
                }
              });
            }
          });

          // Coleta breakpoints de especializações – fora do loop de relacionamentos!
          specializations.forEach(s => {
            if (s.selected && s.connections) {
              s.connections.forEach(conn => {
                if (conn.breakpoints) {
                  conn.breakpoints.forEach(bp => {
                    groupBreakpointsData.push({
                      breakpoint: bp,
                      startX: bp.x,
                      startY: bp.y
                    });
                  });
                }
              });
            } else if (s.connections) {
              s.connections.forEach(conn => {
                let ent = entities.find(e => e.id === conn.entityId);
                if (ent && ent.selected && conn.breakpoints) {
                  conn.breakpoints.forEach(bp => {
                    groupBreakpointsData.push({
                      breakpoint: bp,
                      startX: bp.x,
                      startY: bp.y
                    });
                  });
                }
              });
            }
          });
        } else {
          isDraggingObject = true;
          dragObject = hit.element;
          dragOffset = { x: pos.x - hit.element.x, y: pos.y - hit.element.y };
          submenuTimeout = setTimeout(() => {
            if (!isDraggingObject && !isDraggingGroup) {
              showSubmenu(hit.element, pos.x, pos.y);
            }
          }, 200);
        }
        $(canvas).on("mousemove.drag", onCanvasMove);
        $(canvas).on("mouseup.drag", () => {
          $(canvas).off("mousemove.drag");
          $(canvas).off("mouseup.drag");
          onCanvasEnd(evt);
        });
        draw();
        return;
    }
  } else {
    clearSelection();
    isSelecting = true;
    selectionStart = pos;
    selectionRect = { x: pos.x, y: pos.y, width: 0, height: 0 };
  }
}

    function distanceBetween(a, b) {
      return Math.hypot(b.x - a.x, b.y - a.y);
    }

    function getPolylineMidpoint(points) {
      // 1) Calcula o comprimento total
      let totalLen = 0;
      for (let i = 0; i < points.length - 1; i++) {
        totalLen += distanceBetween(points[i], points[i+1]);
      }
      let half = totalLen / 2;

      // 2) Percorre os segmentos até achar a metade
      let accum = 0;
      for (let i = 0; i < points.length - 1; i++) {
        let segLen = distanceBetween(points[i], points[i+1]);
        if (accum + segLen >= half) {
          // Achamos o segmento onde fica o meio
          let rest = half - accum;   // quanto falta pra chegar na metade
          let ratio = rest / segLen; // fração do segmento
          return {
            x: points[i].x + ratio * (points[i+1].x - points[i].x),
            y: points[i].y + ratio * (points[i+1].y - points[i].y)
          };
        }
        accum += segLen;
      }

      // Caso não encontre (por arredondamento?), retorna último ponto
      return points[points.length - 1];
    }


   
    function onCanvasMove(evt) {
      evt.preventDefault();
      let pos = getMousePos(evt);

      // Se estiver arrastando um breakpoint, atualiza sua posição
      if (isDraggingBreakpoint && activeBreakpoint) {
        activeBreakpoint.connection.breakpoints[activeBreakpoint.index] = { x: pos.x, y: pos.y };
        draw();
        return;
      }

      if (pendingConnectionHit) {
        let dx = pos.x - pendingConnectionHit.startX;
        let dy = pos.y - pendingConnectionHit.startY;
        if (Math.hypot(dx, dy) > 5) {
          // Cancela clique curto
          clearTimeout(breakpointTimeout);
          breakpointTimeout = null;

          // Cria ou usa o breakpoint existente
          isDraggingBreakpoint = true;
          if (!pendingConnectionHit.connection.breakpoints) {
            pendingConnectionHit.connection.breakpoints = [];
          }

          if (pendingConnectionHit.connection.breakpoints.length === 0) {
            // Se não existir, cria
            pendingConnectionHit.connection.breakpoints.push({ x: pos.x, y: pos.y });
          }
          // Se já existir, não criamos outro
          activeBreakpoint = { 
            connection: pendingConnectionHit.connection, 
            index: 0,
            specialization: pendingConnectionHit.specialization // Inclui a especialização se existir
          };

          pendingConnectionHit = null;
          clearSelection();
          draw();
          return;
        }
      }

      if (isPanning) {
        panOffset.x = panOffsetStart.x + (evt.clientX - panStart.x) / zoom;
        panOffset.y = panOffsetStart.y + (evt.clientY - panStart.y) / zoom;
        draw();
        return;
      }
      if (clickPlacementMode) {
        draggingNewObj = { type: draggingToolbarType, x: pos.x, y: pos.y };
        draw();
        return;
      }
      if (draggingToolbarType) return;

      if (isResizing && resizingObject) {
        if (resizingObject.objType === "entity") {
          let init = resizingInitial;
          if (resizeHandleIndex === 0) {
            let newX = pos.x;
            let newY = pos.y;
            let newWidth = (init.x + init.width) - newX;
            let newHeight = (init.y + init.height) - newY;
            if (newWidth < 40) { newWidth = 40; newX = init.x + init.width - 40; }
            if (newHeight < 30) { newHeight = 30; newY = init.y + init.height - 30; }
            resizingObject.x = newX;
            resizingObject.y = newY;
            resizingObject.width = newWidth;
            resizingObject.height = newHeight;
          } else if (resizeHandleIndex === 1) {
            let newY = pos.y;
            let newWidth = pos.x - init.x;
            let newHeight = (init.y + init.height) - newY;
            if (newWidth < 40) newWidth = 40;
            if (newHeight < 30) { newHeight = 30; newY = init.y + init.height - 30; }
            resizingObject.y = newY;
            resizingObject.width = newWidth;
            resizingObject.height = newHeight;
          } else if (resizeHandleIndex === 2) {
            let newX = pos.x;
            let newWidth = (init.x + init.width) - newX;
            let newHeight = pos.y - init.y;
            if (newWidth < 40) { newWidth = 40; newX = init.x + init.width - 40; }
            if (newHeight < 30) newHeight = 30;
            resizingObject.x = newX;
            resizingObject.width = newWidth;
            resizingObject.height = newHeight;
          } else if (resizeHandleIndex === 3) {
            let newWidth = pos.x - init.x;
            let newHeight = pos.y - init.y;
            if (newWidth < 40) newWidth = 40;
            if (newHeight < 30) newHeight = 30;
            resizingObject.width = newWidth;
            resizingObject.height = newHeight;
          }
        } else if (resizingObject.objType === "attribute" || resizingObject.objType === "derivedAttribute") {
          if (resizeHandleIndex === 0 || resizeHandleIndex === 1) {
            let newRadiusX = Math.abs(pos.x - resizingObject.x);
            let newRadiusY = newRadiusX * resizingInitial.ratio;
            if (newRadiusX < 20) {
              newRadiusX = 20;
              newRadiusY = newRadiusX * resizingInitial.ratio;
            }
            resizingObject.radiusX = newRadiusX;
            resizingObject.radiusY = newRadiusY;
          } else if (resizeHandleIndex === 2 || resizeHandleIndex === 3) {
            let newRadiusY = Math.abs(pos.y - resizingObject.y);
            let newRadiusX = newRadiusY / resizingInitial.ratio;
            if (newRadiusY < 10) {
              newRadiusY = 10;
              newRadiusX = newRadiusY / resizingInitial.ratio;
            }
            resizingObject.radiusX = newRadiusX;
            resizingObject.radiusY = newRadiusY;
          }
        } else if (resizingObject.objType === "relationship") {
          let newSize = 2 * Math.max(Math.abs(pos.x - resizingObject.x), Math.abs(pos.y - resizingObject.y));
          if (newSize < 40) newSize = 40;
          resizingObject.size = newSize;
        } else if (resizingObject.objType === "specialization") {
          let newSize = Math.abs(pos.y - resizingObject.y) * (2 / (Math.sqrt(3)/3));
          if (newSize < 40) newSize = 40;
          resizingObject.size = newSize;
        }
        draw();
        return;
      }

      if (isSelecting) {
        selectionRect.x = Math.min(selectionStart.x, pos.x);
        selectionRect.y = Math.min(selectionStart.y, pos.y);
        selectionRect.width = Math.abs(pos.x - selectionStart.x);
        selectionRect.height = Math.abs(pos.y - selectionStart.y);
        draw();
        return;
      }
      // Melhoria no arrastamento de grupos
      if (isDraggingGroup) {
        let dx = pos.x - groupMouseStart.x;
        let dy = pos.y - groupMouseStart.y;
        
        // Atualiza posição de cada objeto
        groupDragData.forEach(item => {
          item.obj.x = item.startX + dx;
          item.obj.y = item.startY + dy;
        });

        // Atualiza posição de cada breakpoint que estiver no "groupBreakpointsData"
        groupBreakpointsData.forEach(bpd => {
          bpd.breakpoint.x = bpd.startX + dx;
          bpd.breakpoint.y = bpd.startY + dy;
        });
        
        draw();
        return;
      }
      if (isDraggingObject && dragObject) {
        dragObject.x = pos.x - dragOffset.x;
        dragObject.y = pos.y - dragOffset.y;
        draw();
        return;
      }
      
      if (isDraggingConnection && draggingConnection) {
        draggingConnection.current = pos;
        draw();
        return;
      }
    }




    // Correção para função onCanvasEnd() - Parte responsável pela seleção de múltiplos objetos
function onCanvasEnd(evt) {
  evt.preventDefault();
  let pos = getMousePos(evt);

  // Se estava arrastando um breakpoint, finaliza o arraste
  if (isDraggingBreakpoint) {
    isDraggingBreakpoint = false;
    activeBreakpoint = null;
    saveState();
    draw();
    return;
  }

  // Processamento do pendingConnectionHit
  if (pendingConnectionHit) {
    clearTimeout(breakpointTimeout);
    if (pendingConnectionHit.type === "specialization-connection") {
      selectedSpecConnection = {
        specializationId: pendingConnectionHit.specialization.id,
        entityId: pendingConnectionHit.connection.entityId,
        vertex: pendingConnectionHit.connection.vertex,
        iconRect: null
      };
    } else if (pendingConnectionHit.type === "connection") {
      selectedConnection = {
        relationshipId: pendingConnectionHit.relationship.id,
        entityId: pendingConnectionHit.connection.entityId,
        iconRect: null
      };
      justSelectedConnection = true;
    }
    pendingConnectionHit = null;
    draw();
    return;
  }

  if (isPanning) {
    isPanning = false;
    return;
  }
  
  if (clickPlacementMode) {
    createObjectAt(draggingToolbarType, pos.x, pos.y);
    cleanupToolbarDrag();
    draw();
    return;
  }
  
  if (draggingToolbarType) return;
  
  if (isResizing) {
    isResizing = false;
    resizingObject = null;
    saveState();
    draw();
    return;
  }
  
  if (isSelecting) {
    // CORREÇÃO: Armazena objetos que serão selecionados
    const objectsToSelect = [];
    
    // ENTIDADES: Verifica quais entidades estão dentro da área de seleção
    entities.forEach(e => {
      const width = e.width || defaultEntityWidth;
      const height = e.height || defaultEntityHeight;
      
      // Verifica se a entidade intersecta com a área de seleção
      if (!(e.x + width < selectionRect.x || 
            e.x > selectionRect.x + selectionRect.width ||
            e.y + height < selectionRect.y || 
            e.y > selectionRect.y + selectionRect.height)) {
        objectsToSelect.push(e);
      }
    });
    
    // ATRIBUTOS: Verifica quais atributos estão dentro da área de seleção
    attributes.forEach(a => {
      const rx = a.radiusX || defaultAttributeRadiusX;
      const ry = a.radiusY || defaultAttributeRadiusY;
      
      // Verifica se o atributo intersecta com a área de seleção
      // Aproximando a elipse com um retângulo circunscrito para a verificação
      if (!(a.x + rx < selectionRect.x || 
            a.x - rx > selectionRect.x + selectionRect.width ||
            a.y + ry < selectionRect.y || 
            a.y - ry > selectionRect.y + selectionRect.height)) {
        objectsToSelect.push(a);
      }
    });
    
    // RELACIONAMENTOS: Verifica quais relacionamentos estão dentro da área de seleção
    relationships.forEach(r => {
      const half = (r.size || relationshipSize) / 2;
      
      // Verifica se o relacionamento intersecta com a área de seleção
      if (!(r.x + half < selectionRect.x || 
            r.x - half > selectionRect.x + selectionRect.width ||
            r.y + half < selectionRect.y || 
            r.y - half > selectionRect.y + selectionRect.height)) {
        objectsToSelect.push(r);
      }
    });
    
    // ESPECIALIZAÇÕES: Verifica quais especializações estão dentro da área de seleção
    specializations.forEach(s => {
      const half = (s.size || defaultSpecializationSize) / 2;
      
      // Verifica se a especialização intersecta com a área de seleção
      if (!(s.x + half < selectionRect.x || 
            s.x - half > selectionRect.x + selectionRect.width ||
            s.y + half < selectionRect.y || 
            s.y - half > selectionRect.y + selectionRect.height)) {
        objectsToSelect.push(s);
      }
    });
    
    // CORREÇÃO: Limpa a seleção atual apenas se não tivermos a tecla Shift pressionada
    // Nota: Para adicionar suporte a Shift, você pode verificar evt.shiftKey
    if (!evt.shiftKey) {
      clearSelection();
    }
    
    // Seleciona todos os objetos encontrados
    objectsToSelect.forEach(obj => {
      obj.selected = true;
    });
    
    // Limpa estado de seleção e redesenha
    isSelecting = false;
    selectionRect = null;
    
    // Se selecionamos pelo menos um objeto, considere isso uma alteração de estado
    if (objectsToSelect.length > 0) {
      // Não salvamos o estado aqui para não adicionar ao histórico de desfazer a cada seleção
      // saveState(); // Comentado para não adicionar ao histórico de desfazer
    }
    
    draw();
    return;
  }
  
  if (isDraggingGroup) {
    isDraggingGroup = false;
    groupDragData = [];
    saveState();
    draw();
    return;
  }
  
  if (isDraggingObject) {
    isDraggingObject = false;
    dragObject = null;
    saveState();
    draw();
    return;
  }
  
  if (isDraggingConnection) {
    let drop = getDraggableAt(pos.x, pos.y);
    if (drop) {
      handleConnectionDrop(draggingConnection, drop);
    }
    isDraggingConnection = false;
    draggingConnection = null;
    saveState();
    draw();
    return;
  }
}


    canvas.addEventListener("touchstart", onCanvasStart);
    canvas.addEventListener("touchmove", onCanvasMove);
    canvas.addEventListener("touchend", onCanvasEnd);
    canvas.addEventListener("touchcancel", onCanvasEnd);
    canvas.addEventListener("mousedown", onCanvasStart);
    canvas.addEventListener("mousemove", onCanvasMove);
    canvas.addEventListener("mouseup", onCanvasEnd);

    

    let inlineInput = null, inlineSelect = null, inlineSpecSelect = null;

    canvas.addEventListener("click", function(evt) {
      let pos = getMousePos(evt);

      // Se a conexão foi apenas selecionada, ignora esse clique para exclusão
      if (justSelectedConnection) {
        justSelectedConnection = false;
        return;
      }

      // 1) Se clicou no ícone de exclusão de uma conexão (linha)
      if (selectedConnection && selectedConnection.iconRect) {
        if (isInsideRect(pos, selectedConnection.iconRect)) {
          // A lógica de remover a conexão é a mesma do "deleteSelectedObjects" 
          // (item 7 no seu deleteSelectedObjects).
          let r = relationships.find(rr => rr.id === selectedConnection.relationshipId);
          if (r) {
            r.connections = r.connections.filter(
              conn => conn.entityId !== selectedConnection.entityId
            );
          }
          selectedConnection = null;
          saveState();
          clearSelection();
          draw();
          return; // sai imediatamente para não continuar no loop
        }
      }

      // 2) Se clicou no ícone de exclusão de uma especialização, faça algo similar ao dos relacionamentos
      if (selectedSpecConnection && selectedSpecConnection.iconRect) {
        if (isInsideRect(pos, selectedSpecConnection.iconRect)) {
          let s = specializations.find(sp => sp.id === selectedSpecConnection.specializationId);
          if (s && s.connections) {
            s.connections = s.connections.filter(conn =>
              !(conn.entityId === selectedSpecConnection.entityId && conn.vertex === selectedSpecConnection.vertex)
            );
          }
          selectedSpecConnection = null;
          saveState();
          clearSelection();
          draw();
          return;
        }
      }

      // 3) Caso não tenha clicado em nenhum ícone de exclusão,
      //    prossiga com o que você já faz para breakpoints e labelRect etc.
      for (let r of relationships) {
        for (let conn of r.connections) {
          // ...
          // (o seu loop de breakpoints e labelRect)
        }
      }
    });


    canvas.addEventListener("contextmenu", function(evt) {
      evt.preventDefault();
      let pos = getMousePos(evt);
      
      let hit = getDraggableAt(pos.x, pos.y);
      if (hit && (hit.type === "connection" || hit.type === "specialization-connection")) {
        // Para ambos os tipos, certifica-se de que exista o array de breakpoints
        if (!hit.connection.breakpoints) {
          hit.connection.breakpoints = [];
        }
        if (hit.connection.breakpoints.length === 0) {
          hit.connection.breakpoints.push({ x: pos.x, y: pos.y });
        }
        saveState();
        draw();
        return;
      }
    });

    canvas.addEventListener("dblclick", function(evt) {
      let pos = getMousePos(evt);


       // Primeiro: percorre as conexões de especialização
      for (let s of specializations) {
        if (s.connections) {
          for (let i = 0; i < s.connections.length; i++) {
            let conn = s.connections[i];
            if (conn.breakpoints && conn.breakpoints.length > 0) {
              for (let j = 0; j < conn.breakpoints.length; j++) {
                let bp = conn.breakpoints[j];
                if (Math.hypot(pos.x - bp.x, pos.y - bp.y) < 8) {
                  // Remove o breakpoint e atualiza o desenho
                  conn.breakpoints.splice(j, 1);
                  saveState();
                  clearSelection();
                  draw();
                  return; // Interrompe para não prosseguir com outros duplos cliques
                }
              }
            }
          }
        }
      }
      
      // Em seguida: percorre as conexões de relacionamento
      for (let r of relationships) {
        for (let i = 0; i < r.connections.length; i++) {
          let conn = r.connections[i];
          if (conn.breakpoints && conn.breakpoints.length > 0) {
            for (let j = 0; j < conn.breakpoints.length; j++) {
              let bp = conn.breakpoints[j];
              if (Math.hypot(pos.x - bp.x, pos.y - bp.y) < 8) {
                conn.breakpoints.splice(j, 1);
                saveState();
                clearSelection();
                draw();
                return;
              }
            }
          }
        }
      }

      // Verifica se o duplo clique ocorreu sobre um breakpoint
      let hit = getDraggableAt(pos.x, pos.y);
      if (hit && hit.type === "breakpoint") {
        // Remove o breakpoint clicado
        hit.connection.breakpoints.splice(hit.index, 1);
        saveState();
        clearSelection();
        draw();
        return; // Interrompe a execução para não executar outras ações de dblclick
      }

      // Cancela submenu se houver
      if (submenuTimeout) {
        clearTimeout(submenuTimeout);
        submenuTimeout = null;
      }
      if (draggingToolbarType) return;

      


      // 1) Verifica se clicou no label da cardinalidade
      for (let r of relationships) {
        for (let conn of r.connections) {
          if (conn.labelRect && isInsideRect(pos, conn.labelRect)) {
            // Se clicou diretamente no label
            // Calcula uma posição para abrir o seletor
            // (por exemplo, logo abaixo do label)
            let labelCenterX = conn.labelRect.x + conn.labelRect.width / 2;
            let labelBottomY = conn.labelRect.y + conn.labelRect.height;

            showCardinalityEditor(
              conn, 
              labelCenterX, 
              labelBottomY
            );
            return; 
          }
        }
      }




      if (hit) {
        if (hit.type === "entity" || hit.type === "attribute" || hit.type === "relationship" || hit.type === "derivedAttribute") {
          let compX = hit.type === "entity" ? hit.element.x + (hit.element.width || defaultEntityWidth)/2 : hit.element.x;
          let compY = hit.type === "entity" ? hit.element.y + (hit.element.height || defaultEntityHeight)/2 : hit.element.y;
          showInlineEditor(hit.element, compX, compY);
        } else if (hit.type === "specialization") {
          showSpecTypeEditor(hit.element, hit.element.x, hit.element.y);
        } else if (hit.type === "connection") {
          const e = entities.find(en => en.id === hit.connection.entityId);
          if (e) {
            const rCenter = { x: hit.relationship.x, y: hit.relationship.y };
            const eCenter = { x: e.x + e.width/2, y: e.y + e.height/2 };
            const rBoundary = getDiamondBorderPoint(hit.relationship.x, hit.relationship.y, eCenter.x - hit.relationship.x, eCenter.y - hit.relationship.y, hit.relationship.size/2);
            const eBoundary = getRectBorderPoint(eCenter.x, eCenter.y, rCenter.x - eCenter.x, rCenter.y - eCenter.y, e.width/2, e.height/2);
            const midX = (rBoundary.x + eBoundary.x) / 2;
            const midY = (rBoundary.y + eBoundary.y) / 2;
            showCardinalityEditor(hit.connection, midX, midY);
          }
        }
      }
    });

    function showInlineEditor(item, compX, compY) {
      if (inlineInput) $(inlineInput).remove();
      
      // 1) Pega o bounding do canvas
      let rect = canvas.getBoundingClientRect();
      
      // 2) Converte (compX, compY) do “mundo” para tela
      let screenX = rect.left + (compX + panOffset.x) * zoom;
      let screenY = rect.top  + (compY + panOffset.y) * zoom;
      
      // 3) Cria o input na posição correta
      inlineInput = $("<input type='text' class='p-2 border rounded shadow focus:outline-none focus:ring-2 focus:ring-blue-500 bg-gray-800 text-white' />")
        .val(item.name)
        .css({
          position: "absolute",
          fontSize: "16px",
          zIndex: 1000,
          width: "160px",
          // Ajuste se quiser centralizar exatamente no compX, compY
          left: (screenX - 80) + "px",
          top:  (screenY - 20) + "px"
        });
      
      $("body").append(inlineInput);
      inlineInput.focus().select();
      
      inlineInput.on("blur", function() {
        item.name = inlineInput.val();
        $(inlineInput).remove();
        inlineInput = null;
        saveState();
        draw();
      }).on("keydown", function(e) {
        if (e.key === "Enter") inlineInput.blur();
      });
    }

    function showSpecTypeEditor(spec, compX, compY) {
      if (inlineSpecSelect) $(inlineSpecSelect).remove();
        let canvasRect = canvas.getBoundingClientRect();
        let screenX = canvasRect.left + (compX + panOffset.x) * zoom;
        let screenY = canvasRect.top + (compY + panOffset.y) * zoom;
        inlineSpecSelect = $("<select class='p-2 border rounded shadow focus:outline-none focus:ring-2 focus:ring-blue-500 bg-gray-800 text-white'></select>")
          .css({
            position: "absolute",
            fontSize: "16px",
            zIndex: 1000,
            width: "100px",
            left: (screenX - 50) + "px",
            top: (screenY - 20) + "px"
          });
      const options = ["T,C", "T,D", "P,C", "P,D"];
      options.forEach(opt => {
        const option = $("<option></option>").val(opt).text(opt);
        if (opt === spec.genType) option.prop("selected", true);
        inlineSpecSelect.append(option);
      });
      $("body").append(inlineSpecSelect);
      inlineSpecSelect.focus();
      inlineSpecSelect.on("change", function() {
        spec.genType = inlineSpecSelect.val();
        $(inlineSpecSelect).remove();
        inlineSpecSelect = null;
        saveState();
        draw();
      }).on("blur", function() {
        $(inlineSpecSelect).remove();
        inlineSpecSelect = null;
      });
    }


    function showCardinalityEditor(connection, compX, compY) {
      if (inlineSelect) $(inlineSelect).remove();

      let rect = canvas.getBoundingClientRect();
      let screenX = rect.left + (compX + panOffset.x) * zoom;
      let screenY = rect.top  + (compY + panOffset.y) * zoom;

      inlineSelect = $("<select class='p-2 border rounded shadow focus:outline-none focus:ring-2 focus:ring-blue-500 bg-gray-800 text-white'></select>")
        .css({
          position: "absolute",
          fontSize: "16px",
          zIndex: 1000,
          width: "100px",
          left: (screenX - 50) + "px",
          top:  (screenY - 20) + "px"
        });

      const options = ["0,N", "1,N", "0,1", "1,1"];
      options.forEach(opt => {
        const option = $("<option></option>").val(opt).text(opt);
        if (opt === connection.cardinality) option.prop("selected", true);
        inlineSelect.append(option);
      });

      $("body").append(inlineSelect);
      inlineSelect.focus();
      inlineSelect.on("change", function() {
        connection.cardinality = inlineSelect.val();
        $(inlineSelect).remove();
        inlineSelect = null;
        saveState();
        draw();
      }).on("blur", function() {
        $(inlineSelect).remove();
        inlineSelect = null;
      });
    }

    
// Modificar a função showSubmenu para implementar arraste de relacionamento
function showSubmenu(element, x, y) {
  if (submenu) $(submenu).remove();
  submenu = document.createElement("div");
  submenu.className = "submenu";
  document.body.appendChild(submenu);

  let items = [];
  if (element.objType === "entity" || element.objType === "relationship" || element.objType === "specialization") {
    items.push({
      icon: '<svg class="w-5 h-5 text-white" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12"/></svg>',
      label: "Deletar",
      id: "menuDelete",
      action: () => {
        if (element.objType === "entity") {
          entities = entities.filter(e => e.id !== element.id);
          attributes = attributes.filter(a => !(a.parentType === "entity" && a.parentId === element.id));
          relationships.forEach(r => r.connections = r.connections.filter(c => c.entityId !== element.id));
          specializations.forEach(s => s.connections = s.connections.filter(c => c.entityId !== element.id));
        } else if (element.objType === "relationship") {
          relationships = relationships.filter(r => r.id !== element.id);
          attributes = attributes.filter(a => !(a.parentType === "relationship" && a.parentId === element.id));
        } else if (element.objType === "specialization") {
          specializations = specializations.filter(s => s.id !== element.id);
        }
        saveState();
        clearSelection();
        draw();
      }
    });
    items.push({
      icon: '<svg class="w-5 h-5 text-white" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101m-.758-4.899a4 4 0 005.656 0l4-4a4 4 0 00-5.656-5.656l-1.1 1.1"/></svg>',
      label: "Relacionar",
      id: "menuRelate",
      action: () => {
        isDraggingConnection = true;
        draggingConnection = {
          type: element.objType,
          element: element,
          start: { x: element.x + (element.width || element.size || 0)/2, y: element.y + (element.height || element.size || 0)/2 },
          current: { x: x, y: y }
        };
        clearSelection();
        draw();
      }
    });
  }
  
  // Restante do código para atributos
  if (element.objType === "attribute") {
    items.push({
      icon: '<svg class="w-5 h-5 text-white" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12"/></svg>',
      label: "Deletar",
      id: "menuDelete",
      action: () => {
        attributes = attributes.filter(a => a.id !== element.id);
        attributes.forEach(a => { if (a.parentType === "attribute" && a.parentId === element.id) a.parentId = null; });
        saveState();
        clearSelection();
        draw();
      }
    });
    items.push({
      icon: '<svg class="w-5 h-5 text-white" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M12 4v16"/></svg>',
      label: element.primary ? "Remover Chave" : "Definir Chave",
      id: "menuKey",
      action: () => {
        element.primary = !element.primary;
        saveState();
        clearSelection();
        draw();
      }
    });
  }
  
  if (element.objType === "derivedAttribute") {
    items.push({
      icon: '<svg class="w-5 h-5 text-white" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12"/></svg>',
      label: "Deletar",
      id: "menuDelete",
      action: () => {
        attributes = attributes.filter(a => a.id !== element.id);
        attributes.forEach(a => { if (a.parentType === "attribute" && a.parentId === element.id) a.parentId = null; });
        saveState();
        clearSelection();
        draw();
      }
    });
  }

  items.forEach(item => {
    let div = document.createElement("div");
    div.className = "submenu-item";
    div.id = item.id;
    div.innerHTML = `${item.icon}<span class="text-white">${item.label}</span>`;
    div.onclick = item.action;
    
    // Adicionando manipuladores para arraste a partir do botão "Relacionar"
    if (item.id === "menuRelate") {
      div.addEventListener("mousedown", function(e) {
        // Armazena informações para iniciar o arraste do relacionamento
        relationMenuSource = element;
        
        // Adiciona eventos para detectar movimento do mouse enquanto o botão estiver pressionado
        $(document).on("mousemove.relationDrag", onRelationMenuDragMove);
        $(document).on("mouseup.relationDrag", onRelationMenuDragEnd);
        
        // Previne o comportamento padrão (que seria apenas o onclick)
        e.preventDefault();
        e.stopPropagation();
      });
    }
    
    submenu.appendChild(div);
  });

  // Posicionamento do menu
  let rect = element.objType === "entity" 
      ? { x: element.x, y: element.y, width: element.width, height: element.height }
      : (element.objType === "attribute" || element.objType === "derivedAttribute") 
          ? { x: element.x - element.radiusX, y: element.y - element.radiusY, width: element.radiusX * 2, height: element.radiusY * 2 }
          : element.objType === "relationship" 
              ? { x: element.x - element.size/2, y: element.y - element.size/2, width: element.size, height: element.size }
              : { x: element.x - element.size/2, y: element.y - element.size/2, width: element.size, height: element.size };

  let canvasRect = canvas.getBoundingClientRect();
  let screenX = canvasRect.left + (rect.x + panOffset.x) * zoom;
  let screenY = canvasRect.top + (rect.y + panOffset.y) * zoom;
  let screenWidth = rect.width * zoom;
  let screenHeight = rect.height * zoom;
  let submenuX = screenX + (screenWidth / 2) - (submenu.offsetWidth / 2);
  let submenuY = screenY + screenHeight + 10;

  if (submenuX < 0) submenuX = 0;
  if (submenuX + submenu.offsetWidth > window.innerWidth) submenuX = window.innerWidth - submenu.offsetWidth;
  if (submenuY + submenu.offsetHeight > window.innerHeight) submenuY = screenY - submenu.offsetHeight - 10;
  submenu.style.left = `${submenuX}px`;
  submenu.style.top = `${submenuY}px`;
  submenuRect = {
    x: submenuX - canvasRect.left,
    y: submenuY - canvasRect.top,
    width: submenu.offsetWidth,
    height: submenu.offsetHeight
  };  
}
    

// Função para lidar com o arrastar do relacionamento a partir do menu
function onRelationMenuDragMove(evt) {
  // Se tivermos um objeto de origem para o relacionamento
  if (relationMenuSource) {
    // Inicia o arraste do relacionamento se ainda não começou
    if (!isDraggingConnection) {
      isDraggingConnection = true;
      
      // Remove o menu
      if (submenu) {
        $(submenu).remove();
        submenu = null;
        submenuRect = null;
      }
      
      // Cria o objeto de conexão para desenhar a linha
      const sourceElement = relationMenuSource;
      const pos = getMousePos(evt);
      
      draggingConnection = {
        type: sourceElement.objType,
        element: sourceElement,
        start: { 
          x: sourceElement.x + (sourceElement.width || sourceElement.size || 0)/2, 
          y: sourceElement.y + (sourceElement.height || sourceElement.size || 0)/2 
        },
        current: { x: pos.x, y: pos.y }
      };
      
      // Limpa seleção e redesenha
      clearSelection();
      draggingRelationFromMenu = true;
    }
    
    // Atualiza a posição atual para desenhar a linha
    if (isDraggingConnection && draggingConnection) {
      const pos = getMousePos(evt);
      draggingConnection.current = pos;
      draw();
    }
  }
}

// Função para finalizar o arraste do relacionamento
function onRelationMenuDragEnd(evt) {
  // Remove os handlers de evento
  $(document).off("mousemove.relationDrag");
  $(document).off("mouseup.relationDrag");
  
  // Se estivermos arrastando uma conexão
  if (isDraggingConnection && draggingConnection && draggingRelationFromMenu) {
    const pos = getMousePos(evt);
    let drop = getDraggableAt(pos.x, pos.y);
    
    // Processa o drop da conexão (como no onCanvasEnd)
    if (drop) {
      handleConnectionDrop(draggingConnection, drop);
    }
    
    // Limpa os estados
    isDraggingConnection = false;
    draggingConnection = null;
    draggingRelationFromMenu = false;
    
    // Salva e redesenha
    saveState();
    draw();
  }
  
  // Reseta a variável de origem
  relationMenuSource = null;
}

// Função auxiliar para processar a conexão após o arraste
function handleConnectionDrop(draggingConnection, drop) {
  if (draggingConnection.type === "entity" && drop.type === "entity") {
    let source = draggingConnection.element;
    let target = drop.element;
    
    // Cria relacionamento entre duas entidades
    let sourceCenter = { 
      x: source.x + (source.width || defaultEntityWidth) / 2, 
      y: source.y + (source.height || defaultEntityHeight) / 2 
    };
    let targetCenter = { 
      x: target.x + (target.width || defaultEntityWidth) / 2, 
      y: target.y + (target.height || defaultEntityHeight) / 2 
    };
    let midX = (sourceCenter.x + targetCenter.x) / 2;
    let midY = (sourceCenter.y + targetCenter.y) / 2;
    
    let newR = {
      id: relationshipIdCounter++,
      x: midX,
      y: midY,
      size: relationshipSize,
      name: "Relacionamento",
      connections: [],
      selected: false,
      objType: "relationship"
    };
    
    relationships.push(newR);
    newR.connections.push({ entityId: source.id, cardinality: "1,1" });
    newR.connections.push({ entityId: target.id, cardinality: "1,1" });
  } 
  else if (draggingConnection.type === "relationship" && drop.type === "entity") {
    // Adiciona entidade ao relacionamento
    draggingConnection.element.connections.push({ 
      entityId: drop.element.id, 
      cardinality: "1,1" 
    });
  } 
  else if (draggingConnection.type === "entity" && drop.type === "relationship") {
    // Adiciona entidade ao relacionamento
    if (!drop.element.connections.find(conn => conn.entityId === draggingConnection.element.id)) {
      drop.element.connections.push({ 
        entityId: draggingConnection.element.id, 
        cardinality: "1,1" 
      });
    }
  } 
  else if (draggingConnection.type === "specialization" && drop.type === "entity") {
    // Conecta especialização à entidade
    let spec = draggingConnection.element;
    let vertices = getSpecializationVertices(spec);
    let pos = getMousePos(event);
    let distances = vertices.map(v => Math.hypot(v.x - pos.x, v.y - pos.y));
    let vertexIndex = distances.indexOf(Math.min(...distances));
    
    if (!spec.connections) spec.connections = [];
    if (!spec.connections.find(conn => conn.vertex === vertexIndex && conn.entityId === drop.element.id)) {
      spec.connections.push({ 
        vertex: vertexIndex, 
        entityId: drop.element.id 
      });
    }
  } 
  else if (draggingConnection.type === "entity" && drop.type === "specialization") {
    // Conecta entidade à especialização
    let spec = drop.element;
    let vertices = getSpecializationVertices(spec);
    let pos = getMousePos(event);
    let distances = vertices.map(v => Math.hypot(v.x - pos.x, v.y - pos.y));
    let vertexIndex = distances.indexOf(Math.min(...distances));
    
    if (!spec.connections) spec.connections = [];
    if (!spec.connections.find(conn => conn.vertex === vertexIndex && conn.entityId === draggingConnection.element.id)) {
      spec.connections.push({ 
        vertex: vertexIndex, 
        entityId: draggingConnection.element.id 
      });
    }
  }
}// Função auxiliar para processar a conexão após o arraste
function handleConnectionDrop(draggingConnection, drop) {
  if (draggingConnection.type === "entity" && drop.type === "entity") {
    let source = draggingConnection.element;
    let target = drop.element;
    
    // Cria relacionamento entre duas entidades
    let sourceCenter = { 
      x: source.x + (source.width || defaultEntityWidth) / 2, 
      y: source.y + (source.height || defaultEntityHeight) / 2 
    };
    let targetCenter = { 
      x: target.x + (target.width || defaultEntityWidth) / 2, 
      y: target.y + (target.height || defaultEntityHeight) / 2 
    };
    let midX = (sourceCenter.x + targetCenter.x) / 2;
    let midY = (sourceCenter.y + targetCenter.y) / 2;
    
    let newR = {
      id: relationshipIdCounter++,
      x: midX,
      y: midY,
      size: relationshipSize,
      name: "Relacionamento",
      connections: [],
      selected: false,
      objType: "relationship"
    };
    
    relationships.push(newR);
    newR.connections.push({ entityId: source.id, cardinality: "1,1" });
    newR.connections.push({ entityId: target.id, cardinality: "1,1" });
  } 
  else if (draggingConnection.type === "relationship" && drop.type === "entity") {
    // Adiciona entidade ao relacionamento
    draggingConnection.element.connections.push({ 
      entityId: drop.element.id, 
      cardinality: "1,1" 
    });
  } 
  else if (draggingConnection.type === "entity" && drop.type === "relationship") {
    // Adiciona entidade ao relacionamento
    if (!drop.element.connections.find(conn => conn.entityId === draggingConnection.element.id)) {
      drop.element.connections.push({ 
        entityId: draggingConnection.element.id, 
        cardinality: "1,1" 
      });
    }
  } 
  else if (draggingConnection.type === "specialization" && drop.type === "entity") {
    // Conecta especialização à entidade
    let spec = draggingConnection.element;
    let vertices = getSpecializationVertices(spec);
    let pos = getMousePos(event);
    let distances = vertices.map(v => Math.hypot(v.x - pos.x, v.y - pos.y));
    let vertexIndex = distances.indexOf(Math.min(...distances));
    
    if (!spec.connections) spec.connections = [];
    if (!spec.connections.find(conn => conn.vertex === vertexIndex && conn.entityId === drop.element.id)) {
      spec.connections.push({ 
        vertex: vertexIndex, 
        entityId: drop.element.id 
      });
    }
  } 
  else if (draggingConnection.type === "entity" && drop.type === "specialization") {
    // Conecta entidade à especialização
    let spec = drop.element;
    let vertices = getSpecializationVertices(spec);
    let pos = getMousePos(event);
    let distances = vertices.map(v => Math.hypot(v.x - pos.x, v.y - pos.y));
    let vertexIndex = distances.indexOf(Math.min(...distances));
    
    if (!spec.connections) spec.connections = [];
    if (!spec.connections.find(conn => conn.vertex === vertexIndex && conn.entityId === draggingConnection.element.id)) {
      spec.connections.push({ 
        vertex: vertexIndex, 
        entityId: draggingConnection.element.id 
      });
    }
  }
}

function getSubmenuHit(x, y) {
      if (!submenu || !isInsideRect({x,y}, submenuRect)) return null;
      let items = submenu.children;
      for (let i = 0; i < items.length; i++) {
        let rect = items[i].getBoundingClientRect();
        let canvasRect = canvas.getBoundingClientRect();
        let itemRect = {
          x: rect.left - canvasRect.left,
          y: rect.top - canvasRect.top,
          width: rect.width,
          height: rect.height
        };
        if (isInsideRect({x,y}, itemRect)) {
          return { action: items[i].onclick };
        }
      }
      return null;
    }

    // Listener para ESC e Delete (exclusão dos objetos selecionados)
    document.addEventListener("keydown", function(e) {
      if (e.key === "Escape") {
        if (isDraggingConnection) {
          isDraggingConnection = false;
          draggingConnection = null;
          draw();
        }
        if (draggingToolbarType) {
          cleanupToolbarDrag();
          draw();
        }
      } else if (e.key === "Delete") {
        deleteSelectedObjects();
      }
    });


    function deleteSelectedObjects() {
      // 1) Exclui entidades selecionadas
      const deletedEntityIds = entities.filter(e => e.selected).map(e => e.id);
      // 2) Exclui relacionamentos selecionados
      const deletedRelationshipIds = relationships.filter(r => r.selected).map(r => r.id);

      // 3) Filtra fora as entidades e relacionamentos deletados
      entities = entities.filter(e => !e.selected);
      relationships = relationships.filter(r => !r.selected);
      specializations = specializations.filter(s => !s.selected);

      // 4) Filtra atributos que pertenciam a entidades/relacionamentos removidos
      attributes = attributes.filter(a => {
        if (a.selected) return false; // se o atributo em si estiver selecionado, exclui
        if (a.parentType === "entity" && deletedEntityIds.includes(a.parentId)) return false;
        if (a.parentType === "relationship" && deletedRelationshipIds.includes(a.parentId)) return false;
        return true;
      });

      // 5) Remove das connections qualquer entidade deletada
      relationships.forEach(r => {
        r.connections = r.connections.filter(c => !deletedEntityIds.includes(c.entityId));
      });

      // 6) Remove das conexões de especialização qualquer entidade deletada
      specializations.forEach(s => {
        if (s.connections) {
          s.connections = s.connections.filter(c => !deletedEntityIds.includes(c.entityId));
        }
      });

      // 7) Se houver selectedConnection (linha) selecionada, remove a conexão
      if (selectedConnection) {
        let r = relationships.find(rr => rr.id === selectedConnection.relationshipId);
        if (r) {
          // Filtra fora a conexão cujo entityId é o selecionado
          r.connections = r.connections.filter(conn => conn.entityId !== selectedConnection.entityId);
        }
        selectedConnection = null; 
      }

      // 8) Se houver selectedSpecConnection (linha de especialização) selecionada, remove também
      if (selectedSpecConnection) {
        let s = specializations.find(sp => sp.id === selectedSpecConnection.specializationId);
        if (s && s.connections) {
          s.connections = s.connections.filter(conn =>
            !(conn.entityId === selectedSpecConnection.entityId && conn.vertex === selectedSpecConnection.vertex)
          );
        }
        selectedSpecConnection = null;
      }

      // 9) Salva estado, limpa seleção e redesenha
      saveState();
      clearSelection();
      draw();
    }


    document.getElementById("btnEntity").addEventListener("mousedown", (e) => startToolbarDrag("entity", e));
    document.getElementById("btnAttribute").addEventListener("mousedown", (e) => startToolbarDrag("attribute", e));
    document.getElementById("btnDerivedAttribute").addEventListener("mousedown", (e) => startToolbarDrag("derivedAttribute", e));
    document.getElementById("btnRelationship").addEventListener("mousedown", (e) => startToolbarDrag("relationship", e));
    document.getElementById("btnSpecialization").addEventListener("mousedown", (e) => startToolbarDrag("specialization", e));
    document.getElementById("btnIncreaseFont").addEventListener("click", () => { fontSize += 2; draw(); });
    document.getElementById("btnDecreaseFont").addEventListener("click", () => { fontSize = Math.max(8, fontSize - 2); draw(); });
    document.getElementById("btnClear").addEventListener("click", () => {
      saveState();
      entities = [];
      attributes = [];
      relationships = [];
      specializations = [];
      clearSelection();
      draw();
    });
    
    document.getElementById("btnExport").addEventListener("click", () => {
      const exportScale = 3; // Fator de escala para maior qualidade (ajuste se necessário)
      const exportCanvas = document.createElement("canvas");
      exportCanvas.width = canvas.width * exportScale;
      exportCanvas.height = canvas.height * exportScale;
      const exportCtx = exportCanvas.getContext("2d");
      exportCtx.clearRect(0, 0, exportCanvas.width, exportCanvas.height);
      // Aplique as mesmas transformações de pan e zoom (multiplicadas pelo exportScale)
      exportCtx.translate(panOffset.x * exportScale, panOffset.y * exportScale);
      exportCtx.scale(zoom * exportScale, zoom * exportScale);
      // Desenha o conteúdo (use drawAll para renderizar somente o modelo)
      drawAll(exportCtx);
      const dataUrl = exportCanvas.toDataURL("image/png");
      const link = document.createElement("a");
      link.href = dataUrl;
      link.download = "modelagem_conceitual.png";
      link.click();
    });
    document.getElementById("btnUndo").addEventListener("click", undo);
    document.getElementById("btnRedo").addEventListener("click", redo);

    document.getElementById("hamburger").addEventListener("click", () => {
      sidebar.classList.toggle("expanded");
      resizeCanvas();
    });

    

    resizeCanvas();
    saveState();
    draw();
  </script>
</body>
</html>