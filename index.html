<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <title>Modelagem Conceitual – Redimensionamento, Especialização/Generalização, Drag em Grupo</title>
  <!-- Fonte Inter -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- jQuery (para facilitar eventos) -->
  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
  <style>
    body { font-family: 'Inter', sans-serif; margin: 0; padding: 0; }
    canvas { display: block; background-color: #ffffff; }
    button, body { user-select: none; -webkit-user-drag: none; }
  </style>
</head>
<body class="flex flex-col h-screen">

  <!-- Header / Barra de menus -->
  <header class="bg-gradient-to-r from-indigo-600 to-blue-600 text-white shadow-lg">
    <div class="container mx-auto flex justify-between items-center px-4 py-3 select-none">
      <h1 class="text-2xl font-semibold">Modelagem Conceitual</h1>
      <div id="toolbar" class="flex items-center space-x-4">
        <!-- Botão Entidade -->
        <button id="btnEntity" class="flex flex-col items-center justify-center text-white hover:opacity-90">
          <div class="w-10 h-10 bg-white text-indigo-600 rounded-full flex items-center justify-center shadow">
            <svg class="w-5 h-5" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
              <rect x="3" y="7" width="18" height="10" rx="2" ry="2"></rect>
            </svg>
          </div>
          <span class="text-xs mt-1">Entidade</span>
        </button>
        <!-- Botão Atributo Simples -->
        <button id="btnAttribute" class="flex flex-col items-center justify-center hover:opacity-90">
          <div class="w-10 h-10 bg-white text-green-600 rounded-full flex items-center justify-center shadow">
            <svg class="w-5 h-5" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
              <circle cx="12" cy="12" r="8"></circle>
            </svg>
          </div>
          <span class="text-xs mt-1">Atributo</span>
        </button>
        <!-- Botão Atributo Derivado (cor diferenciada no menu) -->
        <button id="btnDerivedAttribute" class="flex flex-col items-center justify-center hover:opacity-90">
          <div class="w-10 h-10 bg-white text-yellow-600 rounded-full flex items-center justify-center shadow">
            <svg class="w-5 h-5" fill="none" stroke="currentColor" stroke-dasharray="4,2" stroke-width="2" viewBox="0 0 24 24">
              <circle cx="12" cy="12" r="8"></circle>
            </svg>
          </div>
          <span class="text-xs mt-1">Derivado</span>
        </button>
        <!-- Botão Relacionamento -->
        <button id="btnRelationship" class="flex flex-col items-center justify-center hover:opacity-90">
          <div class="w-10 h-10 bg-white text-pink-600 rounded-full flex items-center justify-center shadow">
            <svg class="w-5 h-5" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
              <polygon points="12,2 22,12 12,22 2,12"></polygon>
            </svg>
          </div>
          <span class="text-xs mt-1">Rel</span>
        </button>
        <!-- Botão Especialização/Generalização (triângulo) -->
        <button id="btnSpecialization" class="flex flex-col items-center justify-center hover:opacity-90">
          <div class="w-10 h-10 bg-white text-purple-600 rounded-full flex items-center justify-center shadow">
            <svg class="w-5 h-5" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
              <polygon points="12,2 2,22 22,22"></polygon>
            </svg>
          </div>
          <span class="text-xs mt-1">Esp./Gen.</span>
        </button>
        <!-- Botão Aumentar Fonte -->
        <button id="btnIncreaseFont" class="flex flex-col items-center justify-center hover:opacity-90">
          <div class="w-10 h-10 bg-white text-gray-700 rounded-full flex items-center justify-center shadow">
            <span class="font-bold text-lg">A+</span>
          </div>
          <span class="text-xs mt-1">Aumentar</span>
        </button>
        <!-- Botão Diminuir Fonte -->
        <button id="btnDecreaseFont" class="flex flex-col items-center justify-center hover:opacity-90">
          <div class="w-10 h-10 bg-white text-gray-700 rounded-full flex items-center justify-center shadow">
            <span class="font-bold text-lg">A-</span>
          </div>
          <span class="text-xs mt-1">Diminuir</span>
        </button>
        <!-- Botão Limpar -->
        <button id="btnClear" class="flex flex-col items-center justify-center hover:opacity-90">
          <div class="w-10 h-10 bg-white text-red-600 rounded-full flex items-center justify-center shadow">
            <svg class="w-5 h-5" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
              <line x1="18" y1="6" x2="6" y2="18"></line>
              <line x1="6" y1="6" x2="18" y2="18"></line>
            </svg>
          </div>
          <span class="text-xs mt-1">Limpar</span>
        </button>
        <!-- Botão Exportar -->
        <button id="btnExport" class="flex flex-col items-center justify-center hover:opacity-90">
          <div class="w-10 h-10 bg-white text-blue-600 rounded-full flex items-center justify-center shadow">
            <svg class="w-5 h-5" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
              <polyline points="4 16 12 8 20 16"></polyline>
              <line x1="12" y1="8" x2="12" y2="20"></line>
            </svg>
          </div>
          <span class="text-xs mt-1">Exportar</span>
        </button>
        <!-- Botão Desfazer -->
        <button id="btnUndo" class="flex flex-col items-center justify-center hover:opacity-90">
          <div class="w-10 h-10 bg-white text-yellow-600 rounded-full flex items-center justify-center shadow">
            <svg class="w-5 h-5" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
              <path d="M15 4l-8 8 8 8"></path>
            </svg>
          </div>
          <span class="text-xs mt-1">Desfazer</span>
        </button>
        <!-- Botão Refazer -->
        <button id="btnRedo" class="flex flex-col items-center justify-center hover:opacity-90">
          <div class="w-10 h-10 bg-white text-yellow-600 rounded-full flex items-center justify-center shadow">
            <svg class="w-5 h-5" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
              <path d="M9 4l8 8-8 8"></path>
            </svg>
          </div>
          <span class="text-xs mt-1">Refazer</span>
        </button>
      </div>
    </div>
  </header>

  <!-- Área do canvas -->
  <main class="flex-grow relative bg-gray-100">
    <canvas id="canvas" class="absolute inset-0"></canvas>
  </main>

  <!-- Footer -->
  <footer class="bg-gray-800 text-gray-300 text-center py-2">
    <p class="text-sm">© 2025 Direitos Reservados</p>
  </footer>

  <script>
    /********* Configurações e Variáveis Globais *********/
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const header = $("header")[0];
    const footer = $("footer")[0];
    let mainWidth, mainHeight;
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight - header.offsetHeight - footer.offsetHeight;
      mainWidth = canvas.width;
      mainHeight = canvas.height;
      draw();
    }
    $(window).on("resize", resizeCanvas);

    // Arrays e contadores
    let entities = [], attributes = [], relationships = [], specializations = [];
    let entityIdCounter = 0, attributeIdCounter = 0, relationshipIdCounter = 0, specializationIdCounter = 0;
    const defaultEntityWidth = 140, defaultEntityHeight = 60;
    const defaultAttributeRadius = 35, relationshipSize = 100, defaultSpecializationSize = 100;
    let fontSize = 16;
    const handleSize = 8; // Tamanho das alças de redimensionamento

    // Conexões selecionadas (para edição/exclusão)
    let selectedConnection = null;      // para conexões de relacionamento
    let selectedSpecConnection = null;    // para conexões de especialização

    // Variáveis para "drag from toolbar" (preview)
    // As variáveis abaixo serão usadas tanto para o modo arraste quanto para o modo clique
    let draggingToolbarType = null; // "entity", "attribute", "derivedAttribute", "relationship", "specialization"
    let draggingNewObj = null;      // objeto de preview: { type, x, y }
    // Variável para diferenciar o modo de clique para posicionar (quando o usuário clica rápido no botão do menu)
    let clickPlacementMode = false;
    // Variável auxiliar para detectar se o usuário está arrastando a partir do menu ou apenas clicou
    let toolbarDrag = null;

    // Variáveis para mover objetos já criados
    let isDraggingObject = false, dragObject = null;
    let dragOffset = { x: 0, y: 0 };

    // Variáveis para arrastar grupo de objetos
    let isDraggingGroup = false;
    let groupDragData = []; // array de { obj, startX, startY }
    let groupMouseStart = { x: 0, y: 0 };

    // Variáveis para redimensionamento
    let isResizing = false;
    let resizingObject = null;
    let resizeHandleIndex = null;
    let resizeStartMouse = { x: 0, y: 0 };
    let resizingInitial = {}; // Armazena dimensões iniciais do objeto

    // Seleção retangular
    let isSelecting = false, selectionStart = { x: 0, y: 0 }, selectionRect = null;

    // Arraste de conexão (entre Entidade, Relacionamento ou Especialização)
    let isDraggingConnection = false, draggingConnection = null;

    // Cores – atributo derivado e especialização têm cores diferenciadas
    const normalColors = {
      entity:         { fill: "#EFF6FF", stroke: "#3B82F6" },
      attribute:      { fill: "#ECFDF5", stroke: "#10B981" },
      derived:        { fill: "#FEF9C3", stroke: "#FCD34D" },
      relationship:   { fill: "#FDF2F8", stroke: "#DB2777" },
      specialization: { fill: "#F0E68C", stroke: "#DAA520" }
    };
    const previewColors = {
      entity:         { fill: "#F0F9FF", stroke: "#93C5FD" },
      attribute:      { fill: "#F0FFF4", stroke: "#6EE7B7" },
      derived:        { fill: "#FEF9C3", stroke: "#FCD34D" },
      relationship:   { fill: "#FDF2F8", stroke: "#F9A8D4" },
      specialization: { fill: "#FAFAD2", stroke: "#FFD700" }
    };

    /********* Undo/Redo *********/
    let undoStack = [], redoStack = [];
    function saveState() {
      const state = {
        entities: JSON.parse(JSON.stringify(entities)),
        attributes: JSON.parse(JSON.stringify(attributes)),
        relationships: JSON.parse(JSON.stringify(relationships)),
        specializations: JSON.parse(JSON.stringify(specializations))
      };
      undoStack.push(state);
      redoStack = [];
    }
    function restoreState(state) {
      entities = JSON.parse(JSON.stringify(state.entities));
      attributes = JSON.parse(JSON.stringify(state.attributes));
      relationships = JSON.parse(JSON.stringify(state.relationships));
      specializations = JSON.parse(JSON.stringify(state.specializations));
      draw();
    }
    function undo() {
      if (undoStack.length > 0) {
        const currentState = {
          entities: JSON.parse(JSON.stringify(entities)),
          attributes: JSON.parse(JSON.stringify(attributes)),
          relationships: JSON.parse(JSON.stringify(relationships)),
          specializations: JSON.parse(JSON.stringify(specializations))
        };
        redoStack.push(currentState);
        const prevState = undoStack.pop();
        restoreState(prevState);
      }
    }
    function redo() {
      if (redoStack.length > 0) {
        const currentState = {
          entities: JSON.parse(JSON.stringify(entities)),
          attributes: JSON.parse(JSON.stringify(attributes)),
          relationships: JSON.parse(JSON.stringify(relationships)),
          specializations: JSON.parse(JSON.stringify(specializations))
        };
        undoStack.push(currentState);
        const nextState = redoStack.pop();
        restoreState(nextState);
      }
    }

    /********* Funções de Texto e Helpers de Desenho *********/
    function breakLongWord(word, maxWidth, context) {
      let lines = [], current = "";
      for (let i = 0; i < word.length; i++) {
        let test = current + word[i];
        if (context.measureText(test).width > maxWidth && current !== "") {
          lines.push(current);
          current = word[i];
        } else { current = test; }
      }
      if (current !== "") lines.push(current);
      return lines;
    }
    function wrapText(context, text, maxWidth) {
      let words = text.split(" "), processed = [];
      for (let w of words) {
        if (context.measureText(w).width > maxWidth) processed.push(...breakLongWord(w, maxWidth, context));
        else processed.push(w);
      }
      let lines = [], currentLine = processed[0] || "";
      for (let i = 1; i < processed.length; i++) {
        let testLine = currentLine + " " + processed[i];
        if (context.measureText(testLine).width <= maxWidth) currentLine = testLine;
        else { lines.push(currentLine); currentLine = processed[i]; }
      }
      if (currentLine !== "") lines.push(currentLine);
      return lines;
    }
    function drawWrappedText(context, text, centerX, centerY, maxWidth, isPrimary) {
      context.textAlign = "center"; context.textBaseline = "middle";
      const lines = wrapText(context, text, maxWidth);
      const lineHeight = fontSize * 1.2, totalHeight = lines.length * lineHeight;
      let y = centerY - totalHeight / 2 + lineHeight / 2;
      for (let i = 0; i < lines.length; i++) {
        let line = lines[i];
        context.fillText(line, centerX, y);
        if (isPrimary && i === 0) {
          const textWidth = context.measureText(line).width;
          context.fillRect(centerX - textWidth/2, y + fontSize*0.4, textWidth, 1);
        }
        y += lineHeight;
      }
      return lines;
    }
    function getRectBorderPoint(cx, cy, dx, dy, hw, hh) {
      if (dx === 0 && dy === 0) return { x: cx, y: cy };
      const scaleX = hw / Math.abs(dx), scaleY = hh / Math.abs(dy);
      const f = Math.min(scaleX, scaleY);
      return { x: cx + dx * f, y: cy + dy * f };
    }
    function getCircleBorderPoint(cx, cy, dx, dy, radius) {
      const len = Math.sqrt(dx*dx + dy*dy);
      if (len === 0) return { x: cx, y: cy };
      return { x: cx + (dx/len)*radius, y: cy + (dy/len)*radius };
    }
    function getDiamondBorderPoint(cx, cy, dx, dy, half) {
      const denom = Math.abs(dx) + Math.abs(dy);
      if (denom === 0) return { x: cx, y: cy };
      const f = half / denom;
      return { x: cx + dx * f, y: cy + dy * f };
    }
    function isInsideRect(pos, rect) {
      if (!rect) return false;
      return (pos.x >= rect.x && pos.x <= rect.x + rect.width &&
              pos.y >= rect.y && pos.y <= rect.y + rect.height);
    }
    function getMousePos(evt) {
      const rect = canvas.getBoundingClientRect();
      return { x: evt.clientX - rect.left, y: evt.clientY - rect.top };
    }
    // Função para calcular distância de um ponto a um segmento
    function distancePointToSegment(p, a, b) {
      const A = p.x - a.x, B = p.y - a.y;
      const C = b.x - a.x, D = b.y - a.y;
      const dot = A * C + B * D;
      const len_sq = C * C + D * D;
      let param = (len_sq !== 0) ? dot / len_sq : -1;
      let xx, yy;
      if (param < 0) { xx = a.x; yy = a.y; }
      else if (param > 1) { xx = b.x; yy = b.y; }
      else { xx = a.x + param * C; yy = a.y + param * D; }
      let dx = p.x - xx, dy = p.y - yy;
      return Math.sqrt(dx * dx + dy * dy);
    }

    /********* Funções Auxiliares para Especialização/Generalização *********/
    function getSpecializationVertices(spec) {
      let side = spec.size || defaultSpecializationSize;
      let cx = spec.x, cy = spec.y;
      // Triângulo equilátero centrado em (cx, cy)
      let v1 = { x: cx, y: cy - (Math.sqrt(3)/3)*side };
      let v2 = { x: cx - side/2, y: cy + (Math.sqrt(3)/(6))*side };
      let v3 = { x: cx + side/2, y: cy + (Math.sqrt(3)/(6))*side };
      return [v1, v2, v3];
    }
    function getSpecializationVertex(spec, index) {
      let vertices = getSpecializationVertices(spec);
      return vertices[index];
    }

    /********* Funções de Desenho *********/
    function drawAll(context) {
      context.clearRect(0, 0, mainWidth, mainHeight);
      context.font = fontSize + "px Inter";
      context.fillStyle = "#111827";
      context.lineWidth = 2;

      // Conexões de Atributo
      attributes.forEach(a => {
        if (a.parentType && a.parentId != null) {
          if (a.parentType === "entity") {
            const e = entities.find(en => en.id === a.parentId);
            if (e) {
              const eCenter = { x: e.x + e.width/2, y: e.y + e.height/2 };
              const aBorder = getCircleBorderPoint(a.x, a.y, eCenter.x - a.x, eCenter.y - a.y, a.radius || defaultAttributeRadius);
              const eBorder = getRectBorderPoint(eCenter.x, eCenter.y, a.x - eCenter.x, a.y - eCenter.y, e.width/2, e.height/2);
              context.beginPath();
              context.moveTo(eBorder.x, eBorder.y);
              context.lineTo(aBorder.x, aBorder.y);
              context.stroke();
            }
          } else if (a.parentType === "relationship") {
            const r = relationships.find(rr => rr.id === a.parentId);
            if (r) {
              context.beginPath();
              context.moveTo(r.x, r.y);
              context.lineTo(a.x, a.y);
              context.stroke();
            }
          } else if (a.parentType === "attribute") {
            const pA = attributes.find(at => at.id === a.parentId);
            if (pA) {
              const dx = a.x - pA.x, dy = a.y - pA.y;
              const pBorder = getCircleBorderPoint(pA.x, pA.y, dx, dy, pA.radius || defaultAttributeRadius);
              const cBorder = getCircleBorderPoint(a.x, a.y, -dx, -dy, a.radius || defaultAttributeRadius);
              context.beginPath();
              context.moveTo(pBorder.x, pBorder.y);
              context.lineTo(cBorder.x, cBorder.y);
              context.stroke();
            }
          }
        }
      });

      // Conexões de Relationship → Entity (com cardinalidade)
      relationships.forEach(r => {
        r.connections.forEach(conn => {
          const e = entities.find(en => en.id === conn.entityId);
          if (e) drawConnectionLine(context, r, conn, e);
        });
      });

      // Conexões de Especialização → Entidade (sem cardinalidade)
      specializations.forEach(spec => {
        if (spec.connections) {
          spec.connections.forEach(conn => {
            const e = entities.find(en => en.id === conn.entityId);
            if (e) drawSpecConnectionLine(context, spec, conn, e);
          });
        }
      });

      // Desenho das Entidades
      entities.forEach(e => {
        context.save();
        let fillC = normalColors.entity.fill, strokeC = normalColors.entity.stroke;
        if (draggingNewObj === e) { fillC = previewColors.entity.fill; strokeC = previewColors.entity.stroke; }
        context.shadowColor = "rgba(0,0,0,0.1)";
        context.shadowBlur = 4;
        context.fillStyle = fillC;
        context.strokeStyle = e.selected ? "#2563EB" : strokeC;
        context.lineWidth = e.selected ? 3 : 2;
        const margin = 12;
        let w = e.width || defaultEntityWidth, h = e.height || defaultEntityHeight;
        const lines = wrapText(context, e.name, w - margin);
        let maxLineWidth = 0;
        lines.forEach(line => { let tw = context.measureText(line).width; if (tw > maxLineWidth) maxLineWidth = tw; });
        let lineHeight = fontSize * 1.2;
        let neededH = lines.length * lineHeight + margin;
        let neededW = maxLineWidth + margin;
        e.width = Math.max(w, neededW);
        e.height = Math.max(h, neededH);
        const radius = 8;
        context.beginPath();
        context.moveTo(e.x + radius, e.y);
        context.lineTo(e.x + e.width - radius, e.y);
        context.quadraticCurveTo(e.x + e.width, e.y, e.x + e.width, e.y + radius);
        context.lineTo(e.x + e.width, e.y + e.height - radius);
        context.quadraticCurveTo(e.x + e.width, e.y + e.height, e.x + e.width - radius, e.y + e.height);
        context.lineTo(e.x + radius, e.y + e.height);
        context.quadraticCurveTo(e.x, e.y + e.height, e.x, e.y + e.height - radius);
        context.lineTo(e.x, e.y + radius);
        context.quadraticCurveTo(e.x, e.y, e.x + radius, e.y);
        context.closePath();
        context.fill();
        context.stroke();
        context.fillStyle = "#111827";
        drawWrappedText(context, e.name, e.x + e.width/2, e.y + e.height/2, e.width - margin, false);
        // Desenha ícones de exclusão e link
        if (e.selected) {
          let iconSize = 16;
          let xDel = e.x + e.width - iconSize - 2, yDel = e.y + 2;
          context.fillStyle = "#DC2626";
          context.beginPath();
          context.arc(xDel + iconSize/2, yDel + iconSize/2, iconSize/2, 0, 2*Math.PI);
          context.fill();
          context.fillStyle = "#ffffff";
          context.font = "12px Inter";
          context.textAlign = "center";
          context.textBaseline = "middle";
          context.fillText("X", xDel + iconSize/2, yDel + iconSize/2);
          e.deleteRect = { x: xDel, y: yDel, width: iconSize, height: iconSize };
          let xLink = e.x + e.width/2 - iconSize/2, yLink = e.y + e.height - iconSize - 2;
          context.fillStyle = "#3B82F6";
          context.beginPath();
          context.arc(xLink + iconSize/2, yLink + iconSize/2, iconSize/2, 0, 2*Math.PI);
          context.fill();
          context.fillStyle = "#ffffff";
          context.fillText("⇨", xLink + iconSize/2, yLink + iconSize/2);
          e.linkRect = { x: xLink, y: yLink, width: iconSize, height: iconSize };

          // Redimensionamento: desenha as alças
          e.resizeHandles = [
            { x: e.x - handleSize/2, y: e.y - handleSize/2, width: handleSize, height: handleSize },
            { x: e.x + e.width - handleSize/2, y: e.y - handleSize/2, width: handleSize, height: handleSize },
            { x: e.x - handleSize/2, y: e.y + e.height - handleSize/2, width: handleSize, height: handleSize },
            { x: e.x + e.width - handleSize/2, y: e.y + e.height - handleSize/2, width: handleSize, height: handleSize }
          ];
          e.resizeHandles.forEach(handle => {
            context.fillStyle = "#ffffff";
            context.fillRect(handle.x, handle.y, handle.width, handle.height);
            context.strokeStyle = "#000";
            context.strokeRect(handle.x, handle.y, handle.width, handle.height);
          });
        } else { e.deleteRect = null; e.linkRect = null; e.resizeHandles = []; }
        context.restore();
      });

      // Desenho dos Atributos (círculos)
      attributes.forEach(a => {
        context.save();
        let fillC, strokeC;
        if (a.derived) {
          fillC = normalColors.derived.fill;
          strokeC = normalColors.derived.stroke;
          if (draggingNewObj === a) { fillC = previewColors.derived.fill; strokeC = previewColors.derived.stroke; }
        } else {
          fillC = normalColors.attribute.fill;
          strokeC = normalColors.attribute.stroke;
          if (draggingNewObj === a) { fillC = previewColors.attribute.fill; strokeC = previewColors.attribute.stroke; }
        }
        context.shadowColor = "rgba(0,0,0,0.1)";
        context.shadowBlur = 4;
        context.fillStyle = fillC;
        context.strokeStyle = a.selected ? "#2563EB" : strokeC;
        context.lineWidth = a.selected ? 3 : 2;
        const margin = 10;
        let r = a.radius || defaultAttributeRadius;
        const lines = wrapText(context, a.name, r*2 - margin);
        let maxLineWidth = 0;
        lines.forEach(line => { let tw = context.measureText(line).width; if (tw > maxLineWidth) maxLineWidth = tw; });
        let neededDiameter = Math.max(r*2, maxLineWidth + margin);
        let neededHeight = lines.length*(fontSize*1.2) + margin;
        neededDiameter = Math.max(neededDiameter, neededHeight);
        a.radius = neededDiameter / 2;
        if (a.derived) context.setLineDash([4,2]);
        context.beginPath();
        context.arc(a.x, a.y, a.radius, 0, 2*Math.PI);
        context.fill();
        context.stroke();
        context.setLineDash([]);
        context.fillStyle = "#111827";
        drawWrappedText(context, a.name, a.x, a.y, a.radius*2 - margin, a.primary);
        if (a.selected) {
          let iconSize = 16;
          let xDel = a.x + a.radius - iconSize/2, yDel = a.y - a.radius - iconSize/2;
          context.fillStyle = "#DC2626";
          context.beginPath();
          context.arc(xDel + iconSize/2, yDel + iconSize/2, iconSize/2, 0, 2*Math.PI);
          context.fill();
          context.fillStyle = "#ffffff";
          context.font = "12px Inter";
          context.textAlign = "center";
          context.textBaseline = "middle";
          context.fillText("X", xDel + iconSize/2, yDel + iconSize/2);
          a.deleteRect = { x: xDel, y: yDel, width: iconSize, height: iconSize };
          if (!a.derived) {
            let pkSize = 16;
            let xPk = xDel - pkSize - 4, yPk = yDel;
            context.fillStyle = "#F59E0B";
            context.beginPath();
            context.arc(xPk + pkSize/2, yPk + pkSize/2, pkSize/2, 0, 2*Math.PI);
            context.fill();
            context.fillStyle = "#ffffff";
            context.fillText("PK", xPk + pkSize/2, yPk + pkSize/2);
            a.pkRect = { x: xPk, y: yPk, width: pkSize, height: pkSize };
          } else { a.pkRect = null; }
          // Alças de redimensionamento para atributos
          a.resizeHandles = [
            { x: a.x - a.radius - handleSize/2, y: a.y - a.radius - handleSize/2, width: handleSize, height: handleSize },
            { x: a.x + a.radius - handleSize/2, y: a.y - a.radius - handleSize/2, width: handleSize, height: handleSize },
            { x: a.x - a.radius - handleSize/2, y: a.y + a.radius - handleSize/2, width: handleSize, height: handleSize },
            { x: a.x + a.radius - handleSize/2, y: a.y + a.radius - handleSize/2, width: handleSize, height: handleSize }
          ];
          a.resizeHandles.forEach(handle => {
            context.fillStyle = "#ffffff";
            context.fillRect(handle.x, handle.y, handle.width, handle.height);
            context.strokeStyle = "#000";
            context.strokeRect(handle.x, handle.y, handle.width, handle.height);
          });
        } else { a.deleteRect = null; a.pkRect = null; a.resizeHandles = []; }
        context.restore();
      });

      // Desenho dos Relacionamentos (losangos)
      relationships.forEach(r => {
        context.save();
        drawRelationshipDiamond(context, r);
        if (r.selected) {
          let iconSize = 16, half = relationshipSize/2;
          let xDel = r.x - half + 4, yDel = r.y - half + 4;
          context.fillStyle = "#DC2626";
          context.beginPath();
          context.arc(xDel + iconSize/2, yDel + iconSize/2, iconSize/2, 0, 2*Math.PI);
          context.fill();
          context.fillStyle = "#ffffff";
          context.font = "12px Inter";
          context.textAlign = "center";
          context.textBaseline = "middle";
          context.fillText("X", xDel + iconSize/2, yDel + iconSize/2);
          r.deleteRect = { x: xDel, y: yDel, width: iconSize, height: iconSize };
          let xLink = r.x - iconSize/2;
          let yLink = r.y + half - iconSize - 2;
          context.fillStyle = "#3B82F6";
          context.beginPath();
          context.arc(xLink + iconSize/2, yLink + iconSize/2, iconSize/2, 0, 2*Math.PI);
          context.fill();
          context.fillStyle = "#ffffff";
          context.fillText("⇨", xLink + iconSize/2, yLink + iconSize/2);
          r.linkRect = { x: xLink, y: yLink, width: iconSize, height: iconSize };
          // Alças de redimensionamento para relacionamento
          let halfRel = relationshipSize/2;
          r.resizeHandles = [
            { x: r.x - halfRel - handleSize/2, y: r.y - halfRel - handleSize/2, width: handleSize, height: handleSize },
            { x: r.x + halfRel - handleSize/2, y: r.y - halfRel - handleSize/2, width: handleSize, height: handleSize },
            { x: r.x - halfRel - handleSize/2, y: r.y + halfRel - handleSize/2, width: handleSize, height: handleSize },
            { x: r.x + halfRel - handleSize/2, y: r.y + halfRel - handleSize/2, width: handleSize, height: handleSize }
          ];
          r.resizeHandles.forEach(handle => {
            context.fillStyle = "#ffffff";
            context.fillRect(handle.x, handle.y, handle.width, handle.height);
            context.strokeStyle = "#000";
            context.strokeRect(handle.x, handle.y, handle.width, handle.height);
          });
        } else { r.deleteRect = null; r.linkRect = null; r.resizeHandles = []; }
        context.restore();
      });

      // Desenho das Especializações/Generalizações (triângulos)
      specializations.forEach(spec => {
        context.save();
        drawSpecializationTriangle(context, spec);
        context.restore();
      });

      // Retângulo de seleção
      if (isSelecting && selectionRect) {
        ctx.save();
        ctx.setLineDash([4,2]);
        ctx.strokeStyle = "rgba(37,99,235,0.5)";
        ctx.strokeRect(selectionRect.x, selectionRect.y, selectionRect.width, selectionRect.height);
        ctx.restore();
      }
    }

    function drawConnectionLine(context, r, conn, e) {
      const rCenter = { x: r.x, y: r.y };
      const eCenter = { x: e.x + e.width/2, y: e.y + e.height/2 };
      const rBoundary = getDiamondBorderPoint(r.x, r.y, eCenter.x - r.x, eCenter.y - r.y, relationshipSize/2);
      const eBoundary = getRectBorderPoint(eCenter.x, eCenter.y, r.x - eCenter.x, r.y - eCenter.y, e.width/2, e.height/2);
      context.lineWidth = (selectedConnection && selectedConnection.relationshipId === r.id && selectedConnection.entityId === conn.entityId) ? 4 : 2;
      context.beginPath();
      context.moveTo(rBoundary.x, rBoundary.y);
      context.lineTo(eBoundary.x, eBoundary.y);
      context.stroke();
      const midX = (rBoundary.x + eBoundary.x)/2;
      const midY = (rBoundary.y + eBoundary.y)/2;
      context.fillStyle = "#000";
      context.textAlign = "center";
      context.textBaseline = "bottom";
      context.fillText(conn.cardinality, midX, midY - 5);
      if (selectedConnection && selectedConnection.relationshipId === r.id && selectedConnection.entityId === conn.entityId) {
        const iconSize = 16;
        context.save();
        context.fillStyle = "#DC2626";
        context.beginPath();
        context.arc(midX, midY, iconSize/2, 0, 2*Math.PI);
        context.fill();
        context.fillStyle = "#ffffff";
        context.font = "12px Inter";
        context.textAlign = "center";
        context.textBaseline = "middle";
        context.fillText("X", midX, midY);
        context.restore();
        selectedConnection.iconRect = { x: midX - iconSize/2, y: midY - iconSize/2, width: iconSize, height: iconSize };
      }
    }

    function drawSpecConnectionLine(context, spec, conn, e) {
      let vertex = getSpecializationVertex(spec, conn.vertex);
      const eCenter = { x: e.x + e.width/2, y: e.y + e.height/2 };
      context.lineWidth = (selectedSpecConnection && selectedSpecConnection.specializationId === spec.id && selectedSpecConnection.vertex === conn.vertex && selectedSpecConnection.entityId === conn.entityId) ? 4 : 2;
      context.beginPath();
      context.moveTo(vertex.x, vertex.y);
      const eBoundary = getRectBorderPoint(eCenter.x, eCenter.y, vertex.x - eCenter.x, vertex.y - eCenter.y, e.width/2, e.height/2);
      context.lineTo(eBoundary.x, eBoundary.y);
      context.stroke();
      if (selectedSpecConnection && selectedSpecConnection.specializationId === spec.id && selectedSpecConnection.vertex === conn.vertex && selectedSpecConnection.entityId === conn.entityId) {
        const iconSize = 16;
        const midX = (vertex.x + eBoundary.x) / 2;
        const midY = (vertex.y + eBoundary.y) / 2;
        context.save();
        context.fillStyle = "#DC2626";
        context.beginPath();
        context.arc(midX, midY, iconSize/2, 0, 2*Math.PI);
        context.fill();
        context.fillStyle = "#ffffff";
        context.font = "12px Inter";
        context.textAlign = "center";
        context.textBaseline = "middle";
        context.fillText("X", midX, midY);
        context.restore();
        selectedSpecConnection.iconRect = { x: midX - iconSize/2, y: midY - iconSize/2, width: iconSize, height: iconSize };
      }
    }

    function drawRelationshipDiamond(context, r) {
      const half = relationshipSize/2;
      let fillC = normalColors.relationship.fill;
      let strokeC = normalColors.relationship.stroke;
      if (draggingNewObj === r) { fillC = previewColors.relationship.fill; strokeC = previewColors.relationship.stroke; }
      context.save();
      context.shadowColor = "rgba(0,0,0,0.1)";
      context.shadowBlur = 4;
      context.fillStyle = fillC;
      context.strokeStyle = r.selected ? "#2563EB" : strokeC;
      context.lineWidth = r.selected ? 3 : 2;
      context.beginPath();
      context.moveTo(r.x, r.y - half);
      context.lineTo(r.x + half, r.y);
      context.lineTo(r.x, r.y + half);
      context.lineTo(r.x - half, r.y);
      context.closePath();
      context.fill();
      context.stroke();
      context.fillStyle = "#111827";
      drawWrappedText(context, r.name, r.x, r.y, relationshipSize - 15, false);
      context.restore();
      if (r.selected) {
        let iconSize = 16, half = relationshipSize/2;
        let xDel = r.x - half + 4, yDel = r.y - half + 4;
        context.fillStyle = "#DC2626";
        context.beginPath();
        context.arc(xDel + iconSize/2, yDel + iconSize/2, iconSize/2, 0, 2*Math.PI);
        context.fill();
        context.fillStyle = "#ffffff";
        context.font = "12px Inter";
        context.textAlign = "center";
        context.textBaseline = "middle";
        context.fillText("X", xDel + iconSize/2, yDel + iconSize/2);
        r.deleteRect = { x: xDel, y: yDel, width: iconSize, height: iconSize };
        let xLink = r.x - iconSize/2;
        let yLink = r.y + half - iconSize - 2;
        context.fillStyle = "#3B82F6";
        context.beginPath();
        context.arc(xLink + iconSize/2, yLink + iconSize/2, iconSize/2, 0, 2*Math.PI);
        context.fill();
        context.fillStyle = "#ffffff";
        context.fillText("⇨", xLink + iconSize/2, yLink + iconSize/2);
        r.linkRect = { x: xLink, y: yLink, width: iconSize, height: iconSize };
      } else { r.deleteRect = null; r.linkRect = null; }
    }

    function drawSpecializationTriangle(context, spec) {
      let fillC = normalColors.specialization.fill;
      let strokeC = normalColors.specialization.stroke;
      if (draggingNewObj === spec) { fillC = previewColors.specialization.fill; strokeC = previewColors.specialization.stroke; }
      context.save();
      context.shadowColor = "rgba(0,0,0,0.1)";
      context.shadowBlur = 4;
      context.fillStyle = fillC;
      context.strokeStyle = spec.selected ? "#2563EB" : strokeC;
      context.lineWidth = spec.selected ? 3 : 2;
      const side = spec.size || defaultSpecializationSize;
      const vertices = getSpecializationVertices(spec);
      context.beginPath();
      context.moveTo(vertices[0].x, vertices[0].y);
      context.lineTo(vertices[1].x, vertices[1].y);
      context.lineTo(vertices[2].x, vertices[2].y);
      context.closePath();
      context.fill();
      context.stroke();
      if(spec.genType){
        context.fillStyle = "#111827";
        drawWrappedText(context, spec.genType, spec.x, spec.y, side - 15, false);
      }
      context.restore();
      if (spec.selected) {
        let iconSize = 16;
        let half = spec.size/2 || defaultSpecializationSize/2;
        let xDel = spec.x - half + 4, yDel = spec.y - half + 4;
        context.fillStyle = "#DC2626";
        context.beginPath();
        context.arc(xDel + iconSize/2, yDel + iconSize/2, iconSize/2, 0, 2*Math.PI);
        context.fill();
        context.fillStyle = "#ffffff";
        context.font = "12px Inter";
        context.textAlign = "center";
        context.textBaseline = "middle";
        context.fillText("X", xDel + iconSize/2, yDel + iconSize/2);
        spec.deleteRect = { x: xDel, y: yDel, width: iconSize, height: iconSize };
        let xLink = spec.x - iconSize/2;
        let yLink = spec.y + half - iconSize - 2;
        context.fillStyle = "#3B82F6";
        context.beginPath();
        context.arc(xLink + iconSize/2, yLink + iconSize/2, iconSize/2, 0, 2*Math.PI);
        context.fill();
        context.fillStyle = "#ffffff";
        context.fillText("⇨", xLink + iconSize/2, yLink + iconSize/2);
        spec.linkRect = { x: xLink, y: yLink, width: iconSize, height: iconSize };

        let verts = getSpecializationVertices(spec);
        let minX = Math.min(verts[0].x, verts[1].x, verts[2].x);
        let minY = Math.min(verts[0].y, verts[1].y, verts[2].y);
        let maxX = Math.max(verts[0].x, verts[1].x, verts[2].x);
        let maxY = Math.max(verts[0].y, verts[1].y, verts[2].y);
        spec.resizeHandles = [
          { x: minX - handleSize/2, y: minY - handleSize/2, width: handleSize, height: handleSize },
          { x: maxX - handleSize/2, y: minY - handleSize/2, width: handleSize, height: handleSize },
          { x: minX - handleSize/2, y: maxY - handleSize/2, width: handleSize, height: handleSize },
          { x: maxX - handleSize/2, y: maxY - handleSize/2, width: handleSize, height: handleSize }
        ];
        spec.resizeHandles.forEach(handle => {
          context.fillStyle = "#ffffff";
          context.fillRect(handle.x, handle.y, handle.width, handle.height);
          context.strokeStyle = "#000";
          context.strokeRect(handle.x, handle.y, handle.width, handle.height);
        });
      } else { spec.deleteRect = null; spec.linkRect = null; spec.resizeHandles = []; }
    }

    function drawPreview() {
      if (!draggingToolbarType || !draggingNewObj) return;
      ctx.save();
      ctx.globalAlpha = 0.7;
      switch(draggingToolbarType) {
        case "entity":
          ctx.fillStyle = previewColors.entity.fill;
          ctx.strokeStyle = previewColors.entity.stroke;
          ctx.lineWidth = 2;
          let ex = draggingNewObj.x - defaultEntityWidth/2;
          let ey = draggingNewObj.y - defaultEntityHeight/2;
          ctx.beginPath();
          ctx.rect(ex, ey, defaultEntityWidth, defaultEntityHeight);
          ctx.fill();
          ctx.stroke();
          break;
        case "attribute":
          ctx.fillStyle = previewColors.attribute.fill;
          ctx.strokeStyle = previewColors.attribute.stroke;
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(draggingNewObj.x, draggingNewObj.y, defaultAttributeRadius, 0, Math.PI*2);
          ctx.fill();
          ctx.stroke();
          break;
        case "derivedAttribute":
          ctx.fillStyle = previewColors.derived.fill;
          ctx.strokeStyle = previewColors.derived.stroke;
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(draggingNewObj.x, draggingNewObj.y, defaultAttributeRadius, 0, Math.PI*2);
          ctx.fill();
          ctx.stroke();
          break;
        case "relationship":
          ctx.fillStyle = previewColors.relationship.fill;
          ctx.strokeStyle = previewColors.relationship.stroke;
          ctx.lineWidth = 2;
          let half = relationshipSize/2;
          ctx.beginPath();
          ctx.moveTo(draggingNewObj.x, draggingNewObj.y - half);
          ctx.lineTo(draggingNewObj.x + half, draggingNewObj.y);
          ctx.lineTo(draggingNewObj.x, draggingNewObj.y + half);
          ctx.lineTo(draggingNewObj.x - half, draggingNewObj.y);
          ctx.closePath();
          ctx.fill();
          ctx.stroke();
          break;
        case "specialization":
          ctx.fillStyle = previewColors.specialization.fill;
          ctx.strokeStyle = previewColors.specialization.stroke;
          ctx.lineWidth = 2;
          let side = defaultSpecializationSize;
          let spec = draggingNewObj;
          let vertices = getSpecializationVertices({ x: spec.x, y: spec.y, size: side });
          ctx.beginPath();
          ctx.moveTo(vertices[0].x, vertices[0].y);
          ctx.lineTo(vertices[1].x, vertices[1].y);
          ctx.lineTo(vertices[2].x, vertices[2].y);
          ctx.closePath();
          ctx.fill();
          ctx.stroke();
          break;
      }
      ctx.restore();
    }

    function draw() {
      drawAll(ctx);
      if (draggingToolbarType && draggingNewObj) { drawPreview(); }
      if (isDraggingConnection && draggingConnection) {
        ctx.save();
        ctx.setLineDash([5,3]);
        ctx.beginPath();
        ctx.moveTo(draggingConnection.start.x, draggingConnection.start.y);
        ctx.lineTo(draggingConnection.current.x, draggingConnection.current.y);
        ctx.stroke();
        ctx.restore();
      }
    }

    /********* Seleção, Drag em Grupo e Redimensionamento *********/
    function clearSelection() {
      entities.forEach(e => e.selected = false);
      attributes.forEach(a => a.selected = false);
      relationships.forEach(r => r.selected = false);
      specializations.forEach(s => s.selected = false);
      selectedConnection = null;
      selectedSpecConnection = null;
    }

    function checkResizeHandles(x, y) {
      let found = null;
      entities.forEach(e => {
        if (e.selected && e.resizeHandles) {
          e.resizeHandles.forEach((handle, idx) => {
            if (isInsideRect({x,y}, handle)) {
              found = { type: "resize", element: e, handleIndex: idx };
            }
          });
        }
      });
      attributes.forEach(a => {
        if (a.selected && a.resizeHandles) {
          a.resizeHandles.forEach((handle, idx) => {
            if (isInsideRect({x,y}, handle)) {
              found = { type: "resize", element: a, handleIndex: idx };
            }
          });
        }
      });
      relationships.forEach(r => {
        if (r.selected && r.resizeHandles) {
          r.resizeHandles.forEach((handle, idx) => {
            if (isInsideRect({x,y}, handle)) {
              found = { type: "resize", element: r, handleIndex: idx };
            }
          });
        }
      });
      specializations.forEach(s => {
        if (s.selected && s.resizeHandles) {
          s.resizeHandles.forEach((handle, idx) => {
            if (isInsideRect({x,y}, handle)) {
              found = { type: "resize", element: s, handleIndex: idx };
            }
          });
        }
      });
      return found;
    }

    function getDraggableAt(x, y) {
      for (let e of entities) {
        if (e.selected) {
          if (e.deleteRect && isInsideRect({x,y}, e.deleteRect)) return { type: "entity-delete", element: e };
          if (e.linkRect && isInsideRect({x,y}, e.linkRect)) return { type: "entity-link", element: e };
        }
      }
      for (let a of attributes) {
        if (a.selected) {
          if (a.deleteRect && isInsideRect({x,y}, a.deleteRect)) return { type: "attribute-delete", element: a };
          if (a.pkRect && isInsideRect({x,y}, a.pkRect)) return { type: "attribute-pk", element: a };
        }
      }
      for (let r of relationships) {
        if (r.selected) {
          if (r.deleteRect && isInsideRect({x,y}, r.deleteRect)) return { type: "relationship-delete", element: r };
          if (r.linkRect && isInsideRect({x,y}, r.linkRect)) return { type: "relationship-link", element: r };
        }
      }
      for (let s of specializations) {
        if (s.selected) {
          if (s.deleteRect && isInsideRect({x,y}, s.deleteRect)) return { type: "specialization-delete", element: s };
          if (s.linkRect && isInsideRect({x,y}, s.linkRect)) return { type: "specialization-link", element: s };
        }
      }
      let resizeHit = checkResizeHandles(x, y);
      if (resizeHit) return resizeHit;
      for (let r of relationships) {
        for (let conn of r.connections) {
          let e = entities.find(en => en.id === conn.entityId);
          if (!e) continue;
          let a = { x: r.x, y: r.y };
          let b = { x: e.x + e.width/2, y: e.y + e.height/2 };
          if (distancePointToSegment({x,y}, a, b) < 5)
            return { type: "connection", relationship: r, connection: conn };
        }
      }
      for (let s of specializations) {
        if (s.connections) {
          for (let conn of s.connections) {
            let e = entities.find(en => en.id === conn.entityId);
            if (!e) continue;
            let vertex = getSpecializationVertex(s, conn.vertex);
            if (distancePointToSegment({x,y}, vertex, { x: e.x + e.width/2, y: e.y + e.height/2 }) < 5)
              return { type: "specialization-connection", specialization: s, connection: conn };
          }
        }
      }
      for (let i = attributes.length - 1; i >= 0; i--) {
        const a = attributes[i];
        let r = a.radius || defaultAttributeRadius;
        if (Math.hypot(x - a.x, y - a.y) <= r)
          return { type: "attribute", element: a };
      }
      for (let i = entities.length - 1; i >= 0; i--) {
        const e = entities[i];
        let w = e.width || defaultEntityWidth, h = e.height || defaultEntityHeight;
        if (x >= e.x && x <= e.x + w && y >= e.y && y <= e.y + h)
          return { type: "entity", element: e };
      }
      for (let i = relationships.length - 1; i >= 0; i--) {
        const rel = relationships[i];
        let half = relationshipSize/2;
        if (x >= rel.x - half && x <= rel.x + half && y >= rel.y - half && y <= rel.y + half)
          return { type: "relationship", element: rel };
      }
      for (let i = specializations.length - 1; i >= 0; i--) {
        const spec = specializations[i];
        let half = (spec.size || defaultSpecializationSize)/2;
        if (x >= spec.x - half && x <= spec.x + half && y >= spec.y - half && y <= spec.y + half)
          return { type: "specialization", element: spec };
      }
      return null;
    }

    /********* Lógica de "drag from menu" e clique para posicionar *********/
    function startToolbarDrag(type, evt) {
      evt.preventDefault();
      toolbarDrag = {
        type: type,
        startX: evt.pageX,
        startY: evt.pageY,
        isDragging: false
      };
      $(document).on("mousemove.toolbarDrag", onToolbarDragMove);
      $(document).on("mouseup.toolbarDrag", onToolbarDragEnd);
    }
    function onToolbarDragMove(evt) {
      if (!toolbarDrag) return;
      const dx = evt.pageX - toolbarDrag.startX;
      const dy = evt.pageY - toolbarDrag.startY;
      const distance = Math.sqrt(dx*dx + dy*dy);
      if (!toolbarDrag.isDragging && distance > 5) {
         toolbarDrag.isDragging = true;
         draggingToolbarType = toolbarDrag.type;
         const rect = canvas.getBoundingClientRect();
         draggingNewObj = { type: toolbarDrag.type, x: evt.pageX - rect.left, y: evt.pageY - rect.top };
      } else if (toolbarDrag.isDragging) {
         const rect = canvas.getBoundingClientRect();
         draggingNewObj.x = evt.pageX - rect.left;
         draggingNewObj.y = evt.pageY - rect.top;
      }
      draw();
    }
    function onToolbarDragEnd(evt) {
      if (!toolbarDrag) return;
      $(document).off("mousemove.toolbarDrag");
      $(document).off("mouseup.toolbarDrag");
      const rect = canvas.getBoundingClientRect();
      const cx = evt.pageX - rect.left;
      const cy = evt.pageY - rect.top;
      if (toolbarDrag.isDragging) {
         if (cx >= 0 && cx <= rect.width && cy >= 0 && cy <= rect.height) {
             createObjectAt(toolbarDrag.type, cx, cy);
         }
         cleanupToolbarDrag();
      } else {
         // Se não houve arraste, ativa o modo clique para posicionar
         draggingToolbarType = toolbarDrag.type;
         clickPlacementMode = true;
         if (cx >= 0 && cx <= rect.width && cy >= 0 && cy <= rect.height) {
             draggingNewObj = { type: toolbarDrag.type, x: cx, y: cy };
         }
         // Permanece no modo clique até que o usuário clique na área do canvas
      }
      toolbarDrag = null;
      draw();
    }
    function createObjectAt(type, cx, cy) {
      if (type === "attribute" || type === "derivedAttribute") {
          const drop = getDraggableAt(cx, cy);
          if (!drop || (drop.type !== "entity" && drop.type !== "relationship" && drop.type !== "attribute")) {
            alert("O atributo deve ser arrastado sobre uma entidade, relacionamento ou outro atributo.");
            cleanupToolbarDrag();
            draw();
            return;
          }
          let parentObj = drop.element;
          let posX, posY;
          if (drop.type === "entity") {
            posX = parentObj.x + (parentObj.width || defaultEntityWidth) + defaultAttributeRadius + 10;
            posY = parentObj.y + (parentObj.height || defaultEntityHeight)/2;
          } else if (drop.type === "relationship") {
            posX = parentObj.x + relationshipSize/2 + defaultAttributeRadius + 10;
            posY = parentObj.y;
          } else if (drop.type === "attribute") {
            posX = parentObj.x + (parentObj.radius || defaultAttributeRadius) + 10;
            posY = parentObj.y;
          }
          const newA = {
            id: attributeIdCounter++,
            x: posX,
            y: posY,
            name: (type === "derivedAttribute") ? "Atributo Derivado" : "Atributo",
            parentType: drop.type,
            parentId: parentObj.id,
            derived: (type === "derivedAttribute"),
            primary: false,
            selected: true,
            radius: defaultAttributeRadius,
            objType: (type === "derivedAttribute") ? "derivedAttribute" : "attribute"
          };
          attributes.push(newA);
          clearSelection();
          newA.selected = true;
      } else if (type === "entity") {
          const newE = {
            id: entityIdCounter++,
            x: cx - defaultEntityWidth/2,
            y: cy - defaultEntityHeight/2,
            width: defaultEntityWidth,
            height: defaultEntityHeight,
            name: "Entidade",
            selected: true,
            objType: "entity"
          };
          entities.push(newE);
          clearSelection();
          newE.selected = true;
      } else if (type === "relationship") {
          const newR = {
            id: relationshipIdCounter++,
            x: cx,
            y: cy,
            size: relationshipSize,
            name: "Relacionamento",
            connections: [],
            selected: true,
            objType: "relationship"
          };
          relationships.push(newR);
          clearSelection();
          newR.selected = true;
      } else if (type === "specialization") {
          const newS = {
            id: specializationIdCounter++,
            x: cx,
            y: cy,
            size: defaultSpecializationSize,
            genType: null,
            connections: [],
            selected: true,
            objType: "specialization"
          };
          specializations.push(newS);
          clearSelection();
          newS.selected = true;
      }
      saveState();
      cleanupToolbarDrag();
      draw();
    }
    function cleanupToolbarDrag() {
      draggingToolbarType = null;
      draggingNewObj = null;
      clickPlacementMode = false;
      toolbarDrag = null;
    }

    /********* Eventos do Canvas *********/
    $("#canvas").on("mousedown", function(evt) {
      let pos = getMousePos(evt);
      if (clickPlacementMode) {
         createObjectAt(draggingToolbarType, pos.x, pos.y);
         cleanupToolbarDrag();
         draw();
         return;
      }
      if (draggingToolbarType) return;
      // Resto do código para seleção, arraste de objeto, redimensionamento, etc.
      let hit = getDraggableAt(pos.x, pos.y);
      if (hit && hit.type === "resize") {
        isResizing = true;
        resizingObject = hit.element;
        resizeHandleIndex = hit.handleIndex;
        resizeStartMouse = { x: pos.x, y: pos.y };
        if (resizingObject.objType === "entity") {
          resizingInitial = { x: resizingObject.x, y: resizingObject.y, width: resizingObject.width, height: resizingObject.height };
        } else if (resizingObject.objType === "attribute") {
          resizingInitial = { radius: resizingObject.radius };
        } else if (resizingObject.objType === "relationship") {
          resizingInitial = { size: resizingObject.size };
        } else if (resizingObject.objType === "specialization") {
          resizingInitial = { size: resizingObject.size };
        }
        saveState();
        draw();
        return;
      }
      if (selectedConnection && selectedConnection.iconRect && isInsideRect(pos, selectedConnection.iconRect)) {
        const rel = relationships.find(r => r.id === selectedConnection.relationshipId);
        if (rel) {
          rel.connections = rel.connections.filter(conn => conn.entityId !== selectedConnection.entityId);
        }
        selectedConnection = null;
        saveState();
        draw();
        return;
      }
      if (selectedSpecConnection && selectedSpecConnection.iconRect && isInsideRect(pos, selectedSpecConnection.iconRect)) {
        const spec = specializations.find(s => s.id === selectedSpecConnection.specializationId);
        if (spec && spec.connections) {
          spec.connections = spec.connections.filter(conn => !(conn.entityId === selectedSpecConnection.entityId && conn.vertex === selectedSpecConnection.vertex));
        }
        selectedSpecConnection = null;
        saveState();
        draw();
        return;
      }
      if (hit) {
        switch(hit.type) {
          case "entity-delete":
            entities = entities.filter(en => en.id !== hit.element.id);
            attributes = attributes.filter(a => !(a.parentType==="entity" && a.parentId===hit.element.id));
            relationships.forEach(r => { r.connections = r.connections.filter(conn => conn.entityId !== hit.element.id); });
            specializations.forEach(s => { if(s.connections) s.connections = s.connections.filter(conn => conn.entityId !== hit.element.id); });
            saveState();
            draw();
            return;
          case "entity-link":
            isDraggingConnection = true;
            draggingConnection = {
              type: "entity",
              entity: hit.element,
              start: { x: hit.element.x + (hit.element.width || defaultEntityWidth)/2, y: hit.element.y + (hit.element.height || defaultEntityHeight) },
              current: pos
            };
            return;
          case "attribute-delete":
            attributes = attributes.filter(a => a.id !== hit.element.id);
            attributes = attributes.filter(a => !(a.parentType==="attribute" && a.parentId===hit.element.id));
            saveState();
            draw();
            return;
          case "attribute-pk":
            hit.element.primary = !hit.element.primary;
            saveState();
            draw();
            return;
          case "relationship-delete":
            relationships = relationships.filter(r => r.id !== hit.element.id);
            attributes = attributes.filter(a => !(a.parentType==="relationship" && a.parentId===hit.element.id));
            saveState();
            draw();
            return;
          case "relationship-link":
            isDraggingConnection = true;
            draggingConnection = {
              type: "relationship",
              relationship: hit.element,
              start: { x: hit.element.x, y: hit.element.y + relationshipSize/2 },
              current: pos
            };
            return;
          case "specialization-delete":
            specializations = specializations.filter(s => s.id !== hit.element.id);
            saveState();
            draw();
            return;
          case "specialization-link":
            isDraggingConnection = true;
            draggingConnection = {
              type: "specialization",
              specialization: hit.element,
              start: { x: hit.element.x, y: hit.element.y + (hit.element.size || defaultSpecializationSize)/2 },
              current: pos
            };
            return;
          case "connection":
            clearSelection();
            selectedConnection = { relationshipId: hit.relationship.id, entityId: hit.connection.entityId, iconRect: null };
            draw();
            return;
          case "specialization-connection":
            clearSelection();
            selectedSpecConnection = { specializationId: hit.specialization.id, entityId: hit.connection.entityId, vertex: hit.connection.vertex, iconRect: null };
            draw();
            return;
          case "entity":
          case "attribute":
          case "relationship":
          case "specialization":
            if (hit.element.selected) {
              let selectedObjects = [];
              entities.forEach(e => { if (e.selected) selectedObjects.push(e); });
              attributes.forEach(a => { if (a.selected) selectedObjects.push(a); });
              relationships.forEach(r => { if (r.selected) selectedObjects.push(r); });
              specializations.forEach(s => { if (s.selected) selectedObjects.push(s); });
              if (selectedObjects.length > 1) {
                isDraggingGroup = true;
                groupMouseStart = { x: pos.x, y: pos.y };
                groupDragData = selectedObjects.map(obj => ({ obj: obj, startX: obj.x, startY: obj.y }));
              } else {
                isDraggingObject = true;
                dragObject = hit.element;
                dragOffset.x = pos.x - (hit.element.x || 0);
                dragOffset.y = pos.y - (hit.element.y || 0);
              }
            } else {
              clearSelection();
              hit.element.selected = true;
              isDraggingObject = true;
              dragObject = hit.element;
              dragOffset.x = pos.x - (hit.element.x || 0);
              dragOffset.y = pos.y - (hit.element.y || 0);
            }
            saveState();
            draw();
            return;
        }
      } else {
        clearSelection();
        isSelecting = true;
        selectionStart = pos;
        selectionRect = { x: pos.x, y: pos.y, width: 0, height: 0 };
      }
    });

    $("#canvas").on("mousemove", function(evt) {
      if (clickPlacementMode) {
         let pos = getMousePos(evt);
         draggingNewObj = { type: draggingToolbarType, x: pos.x, y: pos.y };
         draw();
         return;
      }
      if (draggingToolbarType) return;
      let pos = getMousePos(evt);
      if (isResizing) {
        if (resizingObject.objType === "entity") {
          let init = resizingInitial;
          if (resizeHandleIndex === 0) {
            let newX = pos.x;
            let newY = pos.y;
            let newWidth = (init.x + init.width) - newX;
            let newHeight = (init.y + init.height) - newY;
            if(newWidth < 40) { newWidth = 40; newX = init.x + init.width - 40; }
            if(newHeight < 30) { newHeight = 30; newY = init.y + init.height - 30; }
            resizingObject.x = newX;
            resizingObject.y = newY;
            resizingObject.width = newWidth;
            resizingObject.height = newHeight;
          } else if (resizeHandleIndex === 1) {
            let newY = pos.y;
            let newWidth = pos.x - init.x;
            let newHeight = (init.y + init.height) - newY;
            if(newWidth < 40) newWidth = 40;
            if(newHeight < 30) { newHeight = 30; newY = init.y + init.height - 30; }
            resizingObject.y = newY;
            resizingObject.width = newWidth;
            resizingObject.height = newHeight;
          } else if (resizeHandleIndex === 2) {
            let newX = pos.x;
            let newWidth = (init.x + init.width) - newX;
            let newHeight = pos.y - init.y;
            if(newWidth < 40) { newWidth = 40; newX = init.x + init.width - 40; }
            if(newHeight < 30) newHeight = 30;
            resizingObject.x = newX;
            resizingObject.width = newWidth;
            resizingObject.height = newHeight;
          } else if (resizeHandleIndex === 3) {
            let newWidth = pos.x - init.x;
            let newHeight = pos.y - init.y;
            if(newWidth < 40) newWidth = 40;
            if(newHeight < 30) newHeight = 30;
            resizingObject.width = newWidth;
            resizingObject.height = newHeight;
          }
        } else if (resizingObject.objType === "attribute" || resizingObject.objType === "derivedAttribute") {
          let newRadius = Math.max(Math.abs(pos.x - resizingObject.x), Math.abs(pos.y - resizingObject.y));
          if(newRadius < 20) newRadius = 20;
          resizingObject.radius = newRadius;
        } else if (resizingObject.objType === "relationship") {
          let newSize = 2 * Math.max(Math.abs(pos.x - resizingObject.x), Math.abs(pos.y - resizingObject.y));
          if(newSize < 40) newSize = 40;
          resizingObject.size = newSize;
        } else if (resizingObject.objType === "specialization") {
          let newSize = 2 * Math.max(Math.abs(pos.x - resizingObject.x), Math.abs(pos.y - resizingObject.y));
          if(newSize < 40) newSize = 40;
          resizingObject.size = newSize;
        }
        draw();
        return;
      }
      if (isDraggingConnection && draggingConnection) {
        draggingConnection.current = pos;
        draw();
        return;
      }
      if (isSelecting) {
        selectionRect.x = Math.min(selectionStart.x, pos.x);
        selectionRect.y = Math.min(selectionStart.y, pos.y);
        selectionRect.width = Math.abs(pos.x - selectionStart.x);
        selectionRect.height = Math.abs(pos.y - selectionStart.y);
        draw();
        return;
      }
      if (isDraggingGroup) {
        let dx = pos.x - groupMouseStart.x;
        let dy = pos.y - groupMouseStart.y;
        groupDragData.forEach(item => {
          item.obj.x = item.startX + dx;
          item.obj.y = item.startY + dy;
        });
        draw();
        return;
      }
      if (isDraggingObject && dragObject) {
        dragObject.x = pos.x - dragOffset.x;
        dragObject.y = pos.y - dragOffset.y;
        draw();
        return;
      }
    });

    $("#canvas").on("mouseup", function(evt) {
      if (clickPlacementMode) return;
      if (draggingToolbarType) return;
      let pos = getMousePos(evt);
      if (isResizing) {
        isResizing = false;
        resizingObject = null;
        saveState();
        draw();
        return;
      }
      if (isDraggingConnection && draggingConnection) {
        let drop = getDraggableAt(pos.x, pos.y);
        if (drop) {
          if (draggingConnection.type === "relationship" && drop.type === "entity") {
            if (!draggingConnection.relationship.connections.find(conn => conn.entityId === drop.element.id))
              draggingConnection.relationship.connections.push({ entityId: drop.element.id, cardinality: "1,1" });
          } else if (draggingConnection.type === "entity" && drop.type === "relationship") {
            if (!drop.element.connections.find(conn => conn.entityId === draggingConnection.entity.id))
              drop.element.connections.push({ entityId: draggingConnection.entity.id, cardinality: "1,1" });
          } else if (draggingConnection.type === "specialization" && drop.type === "entity") {
            let spec = draggingConnection.specialization;
            let vertices = getSpecializationVertices(spec);
            let distances = vertices.map(v => Math.hypot(v.x - pos.x, v.y - pos.y));
            let vertexIndex = distances.indexOf(Math.min(...distances));
            if (!spec.connections) spec.connections = [];
            if (!spec.connections.find(conn => conn.vertex === vertexIndex && conn.entityId === drop.element.id))
              spec.connections.push({ vertex: vertexIndex, entityId: drop.element.id });
          } else if (draggingConnection.type === "entity" && drop.type === "specialization") {
            let spec = drop.element;
            let vertices = getSpecializationVertices(spec);
            let distances = vertices.map(v => Math.hypot(v.x - pos.x, v.y - pos.y));
            let vertexIndex = distances.indexOf(Math.min(...distances));
            if (!spec.connections) spec.connections = [];
            if (!spec.connections.find(conn => conn.vertex === vertexIndex && conn.entityId === draggingConnection.entity.id))
              spec.connections.push({ vertex: vertexIndex, entityId: draggingConnection.entity.id });
          }
        }
        isDraggingConnection = false;
        draggingConnection = null;
        saveState();
        draw();
        return;
      }
      if (isSelecting) {
        entities.forEach(e => {
          let w = e.width || defaultEntityWidth, h = e.height || defaultEntityHeight;
          if (!(e.x+w < selectionRect.x || e.x > selectionRect.x+selectionRect.width ||
                e.y+h < selectionRect.y || e.y > selectionRect.y+selectionRect.height))
            e.selected = true;
        });
        attributes.forEach(a => {
          let r = a.radius || defaultAttributeRadius;
          if (!(a.x+r < selectionRect.x || a.x-r > selectionRect.x+selectionRect.width ||
                a.y+r < selectionRect.y || a.y-r > selectionRect.y+selectionRect.height))
            a.selected = true;
        });
        relationships.forEach(r => {
          let half = relationshipSize/2;
          if (!(r.x+half < selectionRect.x || r.x-half > selectionRect.x+selectionRect.width ||
                r.y+half < selectionRect.y || r.y-half > selectionRect.y+selectionRect.height))
            r.selected = true;
        });
        specializations.forEach(s => {
          let half = (s.size || defaultSpecializationSize)/2;
          if (!(s.x+half < selectionRect.x || s.x-half > selectionRect.x+selectionRect.width ||
                s.y+half < selectionRect.y || s.y-half > selectionRect.y+selectionRect.height))
            s.selected = true;
        });
        isSelecting = false;
        selectionRect = null;
        draw();
        return;
      }
      if (isDraggingGroup) {
        isDraggingGroup = false;
        groupDragData = [];
        saveState();
        draw();
        return;
      }
      if (isDraggingObject) {
        isDraggingObject = false;
        dragObject = null;
        saveState();
        draw();
      }
    });

    // Variáveis para editores inline
    let inlineInput = null;
    let inlineSelect = null;
    let inlineSpecSelect = null;

    $("#canvas").on("dblclick", function(evt) {
      if (draggingToolbarType) return;
      let pos = getMousePos(evt);
      let hit = getDraggableAt(pos.x, pos.y);
      if (hit) {
        if (hit.type === "entity" || hit.type === "attribute" || hit.type === "relationship") {
          let compX, compY;
          if (hit.type === "entity") {
            compX = hit.element.x + (hit.element.width || defaultEntityWidth)/2;
            compY = hit.element.y + (hit.element.height || defaultEntityHeight)/2;
          } else {
            compX = hit.element.x; compY = hit.element.y;
          }
          showInlineEditor(hit.element, compX, compY);
        } else if (hit.type === "specialization") {
          showSpecTypeEditor(hit.element, hit.element.x, hit.element.y);
        } else if (hit.type === "connection") {
          const e = entities.find(en => en.id === hit.connection.entityId);
          if(e) {
            const rCenter = { x: hit.relationship.x, y: hit.relationship.y };
            const eCenter = { x: e.x + e.width/2, y: e.y + e.height/2 };
            const rBoundary = getDiamondBorderPoint(hit.relationship.x, hit.relationship.y, eCenter.x - hit.relationship.x, eCenter.y - hit.relationship.y, relationshipSize/2);
            const eBoundary = getRectBorderPoint(eCenter.x, eCenter.y, hit.relationship.x - eCenter.x, hit.relationship.y - eCenter.y, e.width/2, e.height/2);
            const midX = (rBoundary.x + eBoundary.x)/2;
            const midY = (rBoundary.y + eBoundary.y)/2;
            showCardinalityEditor(hit.connection, midX, midY);
          }
        }
      }
    });

    function showInlineEditor(item, compX, compY) {
      if (inlineInput) { $(inlineInput).remove(); inlineInput = null; }
      inlineInput = $("<input type='text' class='p-1 border rounded shadow focus:outline-none focus:ring-2 focus:ring-blue-500' />")
                    .val(item.name)
                    .css({ position: "absolute", fontSize: "16px", zIndex: 1000, width: "140px",
                           left: (canvas.getBoundingClientRect().left + compX - 70) + "px",
                           top: (canvas.getBoundingClientRect().top + compY - 18) + "px" });
      $("body").append(inlineInput);
      inlineInput.focus().select();
      inlineInput.on("blur", function() {
        item.name = inlineInput.val();
        $(inlineInput).remove();
        inlineInput = null;
        saveState();
        draw();
      }).on("keydown", function(e) {
        if(e.key === "Enter") inlineInput.blur();
      });
    }

    function showCardinalityEditor(connection, compX, compY) {
      if (inlineSelect) { $(inlineSelect).remove(); inlineSelect = null; }
      inlineSelect = $("<select class='p-1 border rounded shadow focus:outline-none focus:ring-2 focus:ring-blue-500'></select>")
                    .css({ position: "absolute", fontSize: "16px", zIndex: 1000, width: "80px",
                           left: (canvas.getBoundingClientRect().left + compX - 40) + "px",
                           top: (canvas.getBoundingClientRect().top + compY - 18) + "px" });
      const options = ["0,N", "1,N", "0,1", "1,1"];
      options.forEach(opt => {
        const option = $("<option></option>").val(opt).text(opt);
        if(opt === connection.cardinality) option.prop("selected", true);
        inlineSelect.append(option);
      });
      $("body").append(inlineSelect);
      inlineSelect.focus();
      inlineSelect.on("change", function() {
        connection.cardinality = inlineSelect.val();
        $(inlineSelect).remove();
        inlineSelect = null;
        saveState();
        draw();
      }).on("blur", function() {
        $(inlineSelect).remove();
        inlineSelect = null;
      });
    }

    function showSpecTypeEditor(spec, compX, compY) {
      if (inlineSpecSelect) { $(inlineSpecSelect).remove(); inlineSpecSelect = null; }
      inlineSpecSelect = $("<select class='p-1 border rounded shadow focus:outline-none focus:ring-2 focus:ring-blue-500'></select>")
                         .css({ position: "absolute", fontSize: "16px", zIndex: 1000, width: "80px",
                                left: (canvas.getBoundingClientRect().left + compX - 40) + "px",
                                top: (canvas.getBoundingClientRect().top + compY - 18) + "px" });
      const options = ["T,C", "T,D", "P,C", "P,D"];
      options.forEach(opt => {
        const option = $("<option></option>").val(opt).text(opt);
        if(opt === spec.genType) option.prop("selected", true);
        inlineSpecSelect.append(option);
      });
      $("body").append(inlineSpecSelect);
      inlineSpecSelect.focus();
      inlineSpecSelect.on("change", function() {
        spec.genType = inlineSpecSelect.val();
        $(inlineSpecSelect).remove();
        inlineSpecSelect = null;
        saveState();
        draw();
      }).on("blur", function() {
        $(inlineSpecSelect).remove();
        inlineSpecSelect = null;
      });
    }

    /********* Inicialização *********/
    function init() {
      resizeCanvas();
      saveState();
      draw();
    }
    init();

    /********* Eventos do Menu *********/
    $("#btnEntity").on("mousedown", function(e) { startToolbarDrag("entity", e); });
    $("#btnAttribute").on("mousedown", function(e) { startToolbarDrag("attribute", e); });
    $("#btnDerivedAttribute").on("mousedown", function(e) { startToolbarDrag("derivedAttribute", e); });
    $("#btnRelationship").on("mousedown", function(e) { startToolbarDrag("relationship", e); });
    $("#btnSpecialization").on("mousedown", function(e) { startToolbarDrag("specialization", e); });

    $("#btnIncreaseFont").on("click", function() { fontSize += 2; draw(); });
    $("#btnDecreaseFont").on("click", function() { if (fontSize > 6) { fontSize -= 2; draw(); }});
    $("#btnClear").on("click", function() {
      entities = []; attributes = []; relationships = []; specializations = [];
      clearSelection(); saveState(); draw();
    });
    $("#btnExport").on("click", function() {
      const scaleFactor = 3;
      const exportCanvas = document.createElement("canvas");
      exportCanvas.width = mainWidth * scaleFactor;
      exportCanvas.height = mainHeight * scaleFactor;
      const exportCtx = exportCanvas.getContext("2d");
      exportCtx.fillStyle = "#ffffff";
      exportCtx.fillRect(0, 0, exportCanvas.width, exportCanvas.height);
      exportCtx.save();
      exportCtx.scale(scaleFactor, scaleFactor);
      drawAll(exportCtx);
      exportCtx.restore();
      const dataURL = exportCanvas.toDataURL("image/png");
      const link = document.createElement("a");
      link.download = "modelo_conceitual.png";
      link.href = dataURL;
      link.click();
    });
    $("#btnUndo").on("click", function() { undo(); });
    $("#btnRedo").on("click", function() { redo(); });
    $(window).on("keydown", function(evt) {
      if (evt.ctrlKey && evt.key === "z") { evt.preventDefault(); undo(); }
      else if (evt.ctrlKey && evt.key === "y") { evt.preventDefault(); redo(); }
    });
  </script>
</body>
</html>
