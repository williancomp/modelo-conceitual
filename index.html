<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Modelagem Conceitual ‚Äì Nova Era</title>
  <link href="./fonts.css" rel="stylesheet">
  <script src="./tailwind-3.4.16.js"></script>
  <script src="./jquery-3.6.0.min.js"></script>
  <style>
    body {
      font-family: 'Poppins', sans-serif;
      margin: 0;
      padding: 0;
      background: linear-gradient(to bottom right, #1f2937, #374151, #1e3a8a);
      color: #ffffff;
    }
    
    /* Navbar superior */
    .navbar {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: 60px;
      background-color: #111827;
      z-index: 100;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
      display: flex;
      align-items: center;
      padding: 0 16px;
    }
    
    .navbar-brand {
      font-weight: 700;
      font-size: 1.25rem;
      margin-right: 24px;
    }
    
    .menu-category {
      position: relative;
      margin-right: 12px;
    }

    .menu-category::after {
      content: '';
      position: absolute;
      top: 100%;
      left: 0;
      width: 100%;
      height: 10px;
    }

    /* Altera√ß√£o cr√≠tica: Em vez de :hover, usamos uma classe para controlar a visibilidade */
    .menu-category.open .menu-dropdown {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }
    
    .menu-category-btn {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 6px;
      padding: 6px 12px;
      display: flex;
      align-items: center;
      gap: 6px;
      cursor: pointer;
      transition: background 0.2s;
    }
    
    .menu-category-btn:hover {
      background: rgba(255, 255, 255, 0.2);
    }
    
    .menu-dropdown {
      position: absolute;
      top: 100%;
      left: 0;
      width: max-content;
      background: #1f2937;
      border-radius: 6px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      padding: 8px;
      margin-top: 8px;
      display: none;
      z-index: 101;
      /* Adicionamos um pequeno atraso para evitar fechamento acidental */
      transition: opacity 0.2s;
    }
    
    .menu-category:hover .menu-dropdown {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }
    
    .menu-item {
      padding: 8px 12px;
      border-radius: 6px;
      cursor: pointer;
      transition: background 0.2s;
      display: flex;
      align-items: center;
      gap: 8px;
      white-space: nowrap;
    }
    
    .menu-item:hover {
      background: rgba(255, 255, 255, 0.1);
    }
    
    /* Canvas */
    canvas {
      display: block;
      border-radius: 10px;
      margin-top: 60px; /* Espa√ßo para o navbar */
      background: #ffffff;
    }
    
    /* Mobile sidebar */
    #mobile-sidebar {
      position: fixed;
      left: -280px;
      top: 60px;
      width: 280px;
      height: calc(100vh - 60px);
      background: #111827;
      z-index: 100;
      overflow-y: auto;
      transition: left 0.3s ease;
      padding: 16px;
      box-shadow: 2px 0 10px rgba(0, 0, 0, 0.3);
    }
    
    #mobile-sidebar.open {
      left: 0;
    }
    
    .mobile-menu-section {
      margin-bottom: 16px;
    }
    
    .mobile-menu-title {
      font-weight: 600;
      margin-bottom: 8px;
      padding-left: 8px;
      color: #9ca3af;
      text-transform: uppercase;
      font-size: 0.85rem;
    }
    
    .mobile-menu-button {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px;
      border-radius: 8px;
      cursor: pointer;
      transition: background 0.2s;
      margin-bottom: 4px;
    }
    
    .mobile-menu-button:hover {
      background: rgba(255, 255, 255, 0.1);
    }
    
    /* Notification indicator */
    #autosave-indicator {
      transition: opacity 0.3s ease;
      backdrop-filter: blur(4px);
      -webkit-backdrop-filter: blur(4px);
    }
    
    /* Modal */
    #loadModal {
      transition: opacity 0.3s ease;
    }
    
    #loadModal.hidden {
      opacity: 0;
      pointer-events: none;
    }
    
    #loadModal:not(.hidden) {
      opacity: 1;
    }
    
    /* Button & hover effects */
    .toolbar-button {
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      width: 48px;
      height: 48px;
      border-radius: 8px; 
      transition: transform 0.2s, box-shadow 0.2s;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
    }
    
    .toolbar-button:hover {
      transform: scale(1.1);
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
      animation: pulse 1.5s infinite;
    }
    
    @keyframes pulse {
      0% {
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
      }
      50% {
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
      }
      100% {
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
      }
    }
    
    /* Bot√µes das categorias */
    .category-btn-entities {
      background: linear-gradient(to bottom right, #3b82f6, #1e40af);
    }
    
    .category-btn-attributes {
      background: linear-gradient(to bottom right, #10b981, #065f46);
    }
    
    .category-btn-relationships {
      background: linear-gradient(to bottom right, #ec4899, #7e22ce);
    }
    
    .category-btn-text {
      background: linear-gradient(to bottom right, #6b7280, #374151);
    }
    
    .category-btn-files {
      background: linear-gradient(to bottom right, #f59e0b, #b45309);
    }
    
    .category-btn-undo {
      background: linear-gradient(to bottom right, #6366f1, #4338ca);
    }
    
    /* Bot√µes de ferramentas espec√≠ficas */
    .tool-entity {
      background: linear-gradient(to bottom right, #3b82f6, #1e40af);
    }
    
    .tool-attribute {
      background: linear-gradient(to bottom right, #10b981, #065f46);
    }
    
    .tool-derived {
      background: linear-gradient(to bottom right, #fcd34d, #d97706);
    }
    
    .tool-relationship {
      background: linear-gradient(to bottom right, #ec4899, #7e22ce);
    }
    
    .tool-specialization {
      background: linear-gradient(to bottom right, #facc15, #ca8a04);
    }
    
    .tool-increase {
      background: linear-gradient(to bottom right, #6b7280, #374151);
    }
    
    .tool-decrease {
      background: linear-gradient(to bottom right, #6b7280, #374151);
    }
    
    .tool-clear {
      background: linear-gradient(to bottom right, #ef4444, #b91c1c);
    }
    
    .tool-export {
      background: linear-gradient(to bottom right, #3b82f6, #1e40af);
    }
    
    .tool-undo {
      background: linear-gradient(to bottom right, #6366f1, #4338ca);
    }
    
    .tool-redo {
      background: linear-gradient(to bottom right, #6366f1, #4338ca);
    }
    
    .tool-save {
      background: linear-gradient(to bottom right, #10b981, #065f46);
    }
    
    .tool-open {
      background: linear-gradient(to bottom right, #f59e0b, #b45309);
    }
    
    /* Tooltips */
    .tooltip {
      position: relative;
    }
    
    /* Tooltips melhorados */
    .tooltip .tooltip-text {
  visibility: hidden;
  width: auto;
  min-width: 120px;
  background-color: rgba(0, 0, 0, 0.9);
  color: #fff;
  text-align: center;
  border-radius: 6px;
  padding: 8px 12px;
  position: absolute;
  z-index: 1060;
  /* Alterado de bottom para top para posicionar abaixo */
  top: 125%;
  left: 50%;
  transform: translateX(-50%);
  opacity: 0;
  transition: opacity 0.3s;
  white-space: normal;
  font-size: 0.9rem;
  box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
  pointer-events: none;
}

.desktop-menu {
  display: grid;
  grid-auto-flow: row;    /* ou column, dependendo da l√≥gica */
  grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
  gap: 8px;
}
    
    .tooltip:hover .tooltip-text {
      visibility: visible;
      opacity: 1;
    }
    
    /* Responsive */
    @media (max-width: 768px) {
      .navbar .desktop-menu {
        display: none;
      }
      
      canvas {
        margin-top: 60px;
      }
    }
    
    @media (min-width: 769px) {
      .navbar .mobile-toggle {
        display: none;
      }
      
      #mobile-sidebar {
        display: none;
      }
    }

    .submenu {
  position: fixed;
  background: linear-gradient(to right, #374151, #1f2937);
  border: 1px solid #4b5563;
  border-radius: 8px;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
  padding: 8px;
  z-index: 1050;
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.submenu-item {
  display: flex;
  align-items: center;
  padding: 8px 12px;
  cursor: pointer;
  border-radius: 6px;
  transition: background 0.2s;
}

.submenu-item:hover {
  background: rgba(255, 255, 255, 0.1);
}

.submenu-item svg {
  margin-right: 8px;
}

.menu-item svg, .menu-category-btn svg, .main-menu-item svg {
    stroke-width: 2.5; /* Aumenta a espessura das linhas */
    width: 24px;       /* Aumenta o tamanho dos √≠cones */
    height: 24px;
  }


@media (max-width: 1024px) {
  .main-menu-item {
    padding: 4px 8px; 
    font-size: 0.975rem; 
  }
}
/* Estilo para os itens do menu principal (objetos) */
.main-menu-item {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 4px 8px;
  font-size: 0.975rem; 
  border-radius: 6px;
  cursor: pointer;
  transition: background 0.2s;
  white-space: nowrap;
  background: rgba(255, 255, 255, 0.1);
  margin-right: 8px;
}


#extraButtons {
  opacity: 0;
  transform: translateY(10px);
  transition: opacity 0.3s ease, transform 0.3s ease;
}
  
  .main-menu-item:hover {
    background: rgba(255, 255, 255, 0.2);
  }
  
  /* Cores para os diferentes tipos de elementos */
  .entity-btn {
    background: linear-gradient(to bottom right, #3b82f6, #1e40af);
  }
  
  .attribute-btn {
    background: linear-gradient(to bottom right, #10b981, #065f46);
  }
  
  .derived-btn {
    background: linear-gradient(to bottom right, #fcd34d, #d97706); 
  }
  
  .relationship-btn {
    background: linear-gradient(to bottom right, #ec4899, #7e22ce);
  }
  
  .specialization-btn {
    background: linear-gradient(to bottom right, #facc15, #ca8a04);
  }
  
  /* Grupo de atributos e relacionamentos */
  .item-group {
    display: flex;
    align-items: center;
    gap: 8px;
  }
  
  .item-group-label {
    margin-right: 8px;
    font-weight: 500;
    color: #9ca3af;
  }


  /* Cores para os novos tipos de elementos */
  .multivalued-btn {
    background: linear-gradient(to bottom right, #06b6d4, #0e7490);
  }
  
  .aggregation-btn {
    background: linear-gradient(to bottom right, #8b5cf6, #6d28d9);
  }
  
  
  
  .tool-multivalued {
    background: linear-gradient(to bottom right, #06b6d4, #0e7490);
  }
  
  .tool-aggregation {
    background: linear-gradient(to bottom right, #8b5cf6, #6d28d9);
  }
  
  
  
  </style>
</head>
<body class="flex flex-col h-screen">
  <!-- Navbar - Desktop & Mobile -->
  <nav class="navbar">
    <!-- Menu hamburguer (mobile) - sem altera√ß√µes -->
    <button id="mobile-menu-toggle" class="mobile-toggle p-2 mr-2">
      <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M4 6h16M4 12h16m-7 6h7" />
      </svg>
    </button>
    
    <!-- Logo - sem altera√ß√µes -->
    <div class="navbar-brand">ModelaDB</div>
    
    <!-- Menu redesenhado (desktop) -->
    <div class="desktop-menu flex flex-1 items-center">
      <!-- Objetos diretos no menu principal -->
      
      <!-- Categoria: Arquivos -->
      <div class="menu-category">
        <div class="menu-category-btn files-btn">
          <svg class="w-5 h-5 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24" stroke-width="2.5">
            <path d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
          </svg>
          <span>Arquivo</span>
        </div>
        <div class="menu-dropdown">
          <div id="btnOpenFile" class="menu-item tooltip">
            <svg class="w-5 h-5 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24" stroke-width="2.5">
              <path d="M5 19a2 2 0 0 1-2-2V7a2 2 0 0 1 2-2h4l2 2h4a2 2 0 0 1 2 2v1M5 19h14a2 2 0 0 0 2-2v-5a2 2 0 0 0-2-2H9a2 2 0 0 0-2 2v5a2 2 0 0 0 2 2z" />
            </svg>
            <span>Abrir</span>
            <span class="tooltip-text">Abrir arquivo de diagrama</span>
          </div>
          <div id="btnSaveFile" class="menu-item tooltip">
            <svg class="w-5 h-5 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24" stroke-width="2.5">
              <path d="M8 7H5a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3m-1 4l-3 3m0 0l-3-3m3 3V4" />
            </svg>
            <span>Salvar</span>
            <span class="tooltip-text">Salvar diagrama em arquivo</span>
          </div>
          <div id="btnExport" class="menu-item tooltip">
            <svg class="w-5 h-5 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24" stroke-width="2.5">
              <path d="M4 16l8-8 8 8m-8-8v12" />
            </svg>
            <span>Exportar</span>
            <span class="tooltip-text">Exportar diagrama como imagem</span>
          </div>
        </div>
      </div>

      <!-- Entidade -->
      <div id="btnEntity" class="main-menu-item tooltip entity-btn">
        <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <rect x="4" y="6" width="16" height="12" rx="2" stroke-width="2.5" />
        </svg>
        <span>Entidade</span>
        <span class="tooltip-text">Adicionar uma nova entidade ao diagrama</span>
      </div>
      
      <!-- Atributo -->
      <div id="btnAttribute" class="main-menu-item tooltip attribute-btn">
        <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <ellipse cx="12" cy="12" rx="8" ry="4" stroke-width="2.5" />
        </svg>
        <span>Atr. Simples</span>
        <span class="tooltip-text">Adicionar um atributo simples</span>
      </div>
      
      <!-- Atributo Derivado -->
      <div id="btnDerivedAttribute" class="main-menu-item tooltip derived-btn">
        <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" stroke-dasharray="4" viewBox="0 0 24 24">
          <ellipse cx="12" cy="12" rx="8" ry="4" stroke-width="2.5" />
        </svg>
        <span>Atr. Derivado</span>
        <span class="tooltip-text">Adicionar um atributo derivado</span>
      </div>


      <!-- Atributo Multivalorado -->
      <div id="btnMultivaluedAttribute" class="main-menu-item tooltip multivalued-btn">
        <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <ellipse cx="12" cy="12" rx="8" ry="4" stroke-width="2.5" />
          <ellipse cx="12" cy="12" rx="6" ry="3" stroke-width="2.5" />
        </svg>
        <span>Atr. Multivalorado</span>
        <span class="tooltip-text">Adicionar um atributo multivalorado</span>
      </div>
      
      <!-- Relacionamento -->
      <div id="btnRelationship" class="main-menu-item tooltip relationship-btn">
        <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <polygon points="12 4 20 12 12 20 4 12" stroke-width="2.5" />
        </svg>
        <span>Relacionamento</span>
        <span class="tooltip-text">Adicionar um relacionamento entre entidades</span>
      </div>
      
      <!-- Especializa√ß√£o/Generaliza√ß√£o -->
      <div id="btnSpecialization" class="main-menu-item tooltip specialization-btn">
        <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <polygon points="12 4 4 20 20 20" stroke-width="2.5" />
        </svg>
        <span>Gen./Esp.</span>
        <span class="tooltip-text">Adicionar especializa√ß√£o/generaliza√ß√£o</span>
      </div>

      <!-- Relacionamento de Agrega√ß√£o -->
      <div id="btnAggregation" class="main-menu-item tooltip aggregation-btn">
        <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <rect x="6" y="6" width="12" height="12" rx="1" stroke-width="2.5" />
          <polygon points="12 8 16 12 12 16 8 12" stroke-width="2.5" />
        </svg>
        <span>Agrega√ß√£o</span>
        <span class="tooltip-text">Adicionar uma agrega√ß√£o</span>
      </div>

      
    </div>
  </nav>
  
  <!-- Sidebar Mobile -->
  <div id="mobile-sidebar">
    <!-- Se√ß√£o: Componentes B√°sicos -->
    <div class="mobile-menu-section">
      <div class="mobile-menu-title">Componentes</div>
      
      <div id="btnEntity-mobile" class="mobile-menu-button">
        <div class="toolbar-button tool-entity">
          <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <rect x="4" y="6" width="16" height="12" rx="2" />
          </svg>
        </div>
        <span>Entidade</span>
      </div>
      
      <div id="btnAttribute-mobile" class="mobile-menu-button">
        <div class="toolbar-button tool-attribute">
          <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <ellipse cx="12" cy="12" rx="8" ry="4" />
          </svg>
        </div>
        <span>Atr. Simples</span>
      </div>
      
      <div id="btnDerivedAttribute-mobile" class="mobile-menu-button">
        <div class="toolbar-button tool-derived">
          <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" stroke-dasharray="4" viewBox="0 0 24 24">
            <ellipse cx="12" cy="12" rx="8" ry="4" />
          </svg>
        </div>
        <span>Atr. Derivado</span>
      </div>

      <div id="btnMultivaluedAttribute-mobile" class="mobile-menu-button">
        <div class="toolbar-button tool-multivalued">
          <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <ellipse cx="12" cy="12" rx="8" ry="4" />
            <ellipse cx="12" cy="12" rx="6" ry="3" />
          </svg>
        </div>
        <span>Atr. Multivalorado</span>
      </div>
      
      <div id="btnRelationship-mobile" class="mobile-menu-button">
        <div class="toolbar-button tool-relationship">
          <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <polygon points="12 4 20 12 12 20 4 12" />
          </svg>
        </div>
        <span>Relacionamento</span>
      </div>
      
      <div id="btnSpecialization-mobile" class="mobile-menu-button">
        <div class="toolbar-button tool-specialization">
          <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <polygon points="12 4 4 20 20 20" />
          </svg>
        </div>
        <span>Esp./Gen</span>
      </div>

      <div id="btnAggregation-mobile" class="mobile-menu-button">
        <div class="toolbar-button tool-aggregation">
          <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <rect x="6" y="6" width="12" height="12" rx="1" />
            <polygon points="12 8 16 12 12 16 8 12" />
          </svg>
        </div>
        <span>Agrega√ß√£o</span>
      </div>

      
    </div>
    
    <!-- Se√ß√£o: Texto -->
    <div class="mobile-menu-section">
      <div class="mobile-menu-title">Texto</div>
      
      <div id="btnIncreaseFont-mobile" class="mobile-menu-button">
        <div class="toolbar-button tool-increase">
          <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path d="M12 4v16m-8-8h16" />
          </svg>
        </div>
        <span>Aumentar Texto</span>
      </div>
      
      <div id="btnDecreaseFont-mobile" class="mobile-menu-button">
        <div class="toolbar-button tool-decrease">
          <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path d="M4 12h16" />
          </svg>
        </div>
        <span>Diminuir Texto</span>
      </div>
    </div>
    
    <!-- Se√ß√£o: Hist√≥rico -->
    <div class="mobile-menu-section">
      <div class="mobile-menu-title">Hist√≥rico</div>
      
      <div id="btnUndo-mobile" class="mobile-menu-button">
        <div class="toolbar-button tool-undo">
          <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path d="M15 4l-8 8 8 8" />
          </svg>
        </div>
        <span>Desfazer</span>
      </div>
      
      <div id="btnRedo-mobile" class="mobile-menu-button">
        <div class="toolbar-button tool-redo">
          <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path d="M9 4l8 8-8 8" />
          </svg>
        </div>
        <span>Refazer</span>
      </div>
      
      <div id="btnClear-mobile" class="mobile-menu-button">
        <div class="toolbar-button tool-clear">
          <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path d="M6 18L18 6M6 6l12 12" />
          </svg>
        </div>
        <span>Limpar Tudo</span>
      </div>
    </div>
    
    <!-- Se√ß√£o: Arquivos -->
    <div class="mobile-menu-section">
      <div class="mobile-menu-title">Arquivos</div>
      
      <div id="btnSaveFile-mobile" class="mobile-menu-button">
        <div class="toolbar-button tool-save">
          <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path d="M8 7H5a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3m-1 4l-3 3m0 0l-3-3m3 3V4" />
          </svg>
        </div>
        <span>Salvar Arquivo</span>
      </div>
      
      <div id="btnOpenFile-mobile" class="mobile-menu-button">
        <div class="toolbar-button tool-open">
          <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path d="M5 19a2 2 0 0 1-2-2V7a2 2 0 0 1 2-2h4l2 2h4a2 2 0 0 1 2 2v1M5 19h14a2 2 0 0 0 2-2v-5a2 2 0 0 0-2-2H9a2 2 0 0 0-2 2v5a2 2 0 0 0 2 2z" />
          </svg>
        </div>
        <span>Abrir Arquivo</span>
      </div>
      
      <div id="btnExport-mobile" class="mobile-menu-button">
        <div class="toolbar-button tool-export">
          <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path d="M4 16l8-8 8 8m-8-8v12" />
          </svg>
        </div>
        <span>Exportar Imagem</span>
      </div>
    </div>
  </div>
  
  <!-- Canvas (√°rea principal) -->
  <main class="flex-grow">
    <canvas id="canvas"></canvas>
    
    <!-- Indicador de autosave -->
    <div id="autosave-indicator" class="fixed bottom-4 left-1/2 transform -translate-x-1/2 bg-gray-800 text-green-400 px-4 py-2 rounded-lg shadow-lg z-50 opacity-0 transition-opacity duration-300">
      Salvando...
    </div>



  
    <div class="fixed bottom-4 right-4 flex flex-col items-end gap-2 z-50">
    
      <!-- Bot√£o principal que abre/fecha as op√ß√µes -->
      
    
      <!-- Bot√µes que aparecem acima do toggle quando clicado -->
      <div id="extraButtons" class="hidden flex flex-col gap-2 opacity-0 translate-y-4 transition-all duration-300">
        <button id="btnIncreaseFont"
          class="flex items-center justify-center w-12 h-12
                 rounded-md shadow bg-gray-700 hover:bg-gray-600 text-white transition-colors"
          title="Aumentar Fonte">
          A+
        </button>
        <button id="btnDecreaseFont"
          class="flex items-center justify-center w-12 h-12
                 rounded-md shadow bg-gray-700 hover:bg-gray-600 text-white transition-colors"
          title="Diminuir Fonte">
          A-
        </button>
        <button id="btnIncreaseZoom"
          class="flex items-center justify-center w-12 h-12
                 rounded-md shadow bg-gray-700 hover:bg-gray-600 text-white transition-colors"
          title="Aumentar Zoom">
          üîç+
        </button>
        <button id="btnDecreaseZoom"
          class="flex items-center justify-center w-12 h-12
                 rounded-md shadow bg-gray-700 hover:bg-gray-600 text-white transition-colors"
          title="Diminuir Zoom">
          üîç-
        </button>
      </div>

      <button id="btnToggle"
        class="relative flex items-center justify-center w-12 h-12
               rounded-md shadow bg-gray-700 hover:bg-gray-600 text-white transition-all duration-300">
        <svg id="iconPlus" xmlns="http://www.w3.org/2000/svg" class="w-6 h-6 transition-transform duration-300"
             fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
          <path stroke-linecap="round" stroke-linejoin="round" d="M12 4v16m8-8H4" />
        </svg>
        <svg id="iconClose" xmlns="http://www.w3.org/2000/svg" class="w-6 h-6 absolute opacity-0 transition-opacity duration-300"
             fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
          <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12"/>
        </svg>
      </button>
    
      <!-- Linha fixa com os bot√µes de desfazer, refazer e limpar -->
      <div class="flex flex-row gap-2">
        <button id="btnUndoFloating"
          class="flex items-center justify-center w-12 h-12
                 rounded-md shadow bg-gray-700 hover:bg-gray-600 text-white transition-colors"
          title="Desfazer">
          <svg xmlns="http://www.w3.org/2000/svg" class="w-5 h-5" fill="none" 
               viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
            <path stroke-linecap="round" stroke-linejoin="round" d="M15 4l-8 8 8 8"/>
          </svg>
        </button>
        <button id="btnRedoFloating"
          class="flex items-center justify-center w-12 h-12
                 rounded-md shadow bg-gray-700 hover:bg-gray-600 text-white transition-colors"
          title="Refazer">
          <svg xmlns="http://www.w3.org/2000/svg" class="w-5 h-5" fill="none" 
               viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
            <path stroke-linecap="round" stroke-linejoin="round" d="M9 4l8 8-8 8"/>
          </svg>
        </button>
        <button id="btnClearFloating"
          class="flex items-center justify-center px-4 h-12
                 rounded-md shadow bg-gray-700 hover:bg-red-600 text-white transition-colors"
          title="Limpar Tudo">
          Limpar Tudo
        </button>
      </div>
    
    </div>


  </main>
  
  <!-- Input oculto para upload de arquivo -->
  <input type="file" id="fileInput" accept=".merdb" style="display: none;" />
  
  <!-- Modal de confirma√ß√£o para carregamento de arquivo -->
  <div id="loadModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden z-50">
    <div class="bg-gray-800 p-6 rounded-lg shadow-lg max-w-md w-full">
      <h3 class="text-xl font-bold text-white mb-4">Carregar diagrama</h3>
      <p class="text-white mb-6">Tem certeza que deseja carregar um novo diagrama? O diagrama atual ser√° substitu√≠do.</p>
      <div class="flex justify-end gap-3">
        <button id="loadCancelBtn" class="px-4 py-2 bg-gray-600 text-white rounded hover:bg-gray-500 transition">Cancelar</button>
        <button id="loadConfirmBtn" class="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-500 transition">Carregar</button>
      </div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const sidebar = document.getElementById("sidebar");

    let clipboard = null;
    let lastMousePos = { x: 0, y: 0 };
    let isCtrlPressed = false;

    // Novas constantes para dimensionamento dos atributos
    const ATTR_CIRCLE_RADIUS = 12; // Raio do c√≠rculo do atributo
    const ATTR_TEXT_PADDING = 16; // Espa√ßamento entre o c√≠rculo e o texto
    const ATTR_TEXT_OFFSET_Y = 2; // Pequeno ajuste vertical para melhor alinhamento do texto

    // Fator de zoom global (inicial = 1)
    let zoom = 1;

    let panOffset = { x: 0, y: 0 };
    let isPanning = false;
    let panStart = { x: 0, y: 0 };
    let panOffsetStart = { x: 0, y: 0 };
    let isSpacePressed = false;
    let relationClickMode = false;

    let selectedAggregationConnection = null;

    const fabToggleBtn = document.getElementById('fab-toggle');
    const fabSubmenu = document.getElementById('fab-submenu');

    

    let breakpointTimeout = null;
    let isDraggingBreakpoint = false;
    let activeBreakpoint = null;  // Guarda { connection, index } do breakpoint atual
    let pendingConnectionHit = null; // Guarda o hit de conex√£o para diferenciar click curto de longo

    // Vari√°vel para controlar se h√° mudan√ßas n√£o salvas
    let hasUnsavedChanges = false;

    document.getElementById("btnToggle").addEventListener("click", () => {
  const extraButtons = document.getElementById("extraButtons");
  const iconPlus = document.getElementById("iconPlus");
  const iconClose = document.getElementById("iconClose");

  if (extraButtons.classList.contains("hidden")) {
    // Mostrar bot√µes com fade-in e movimento para cima
    extraButtons.classList.remove("hidden");
    setTimeout(() => {
      extraButtons.style.opacity = "1";
      extraButtons.style.transform = "translateY(0)";
    }, 10);

    // Trocar √≠cone para "X"
    iconPlus.style.opacity = "0";
    setTimeout(() => {
      iconClose.style.opacity = "1";
    }, 150);

  } else {
    // Suavizar efeito de fade-out para baixo
    extraButtons.style.opacity = "0";
    extraButtons.style.transform = "translateY(10px)";

    setTimeout(() => {
      extraButtons.classList.add("hidden");
    }, 300); // Pequeno delay para suavizar antes de esconder

    // Voltar √≠cone para "+"
    iconClose.style.opacity = "0";
    setTimeout(() => {
      iconPlus.style.opacity = "1";
    }, 150);
  }
});

    
    document.addEventListener('mousedown', function(e) {
      if (inlineInput && !$(e.target).is(inlineInput) && $(e.target).closest(inlineInput).length === 0) {
        inlineInput.blur();
      }
      if (inlineSelect && !$(e.target).is(inlineSelect) && $(e.target).closest(inlineSelect).length === 0) {
        $(inlineSelect).blur();
      }
      if (inlineSpecSelect && !$(e.target).is(inlineSpecSelect) && $(e.target).closest(inlineSpecSelect).length === 0) {
        $(inlineSpecSelect).blur();
      }
    });

    document.addEventListener('keydown', (e) => {
      // Se o foco estiver em um input, textarea ou elemento edit√°vel, n√£o interfere
      if (document.activeElement &&
          (document.activeElement.tagName === 'INPUT' ||
          document.activeElement.tagName === 'TEXTAREA' ||
          document.activeElement.isContentEditable)) {
        return;
      }

      // Fechar submenus ao pressionar Delete ou Backspace
      if (e.key === 'Delete' || e.key === 'Backspace') {
        // Fecha todos os submenus abertos
        document.querySelectorAll('.submenu').forEach((submenuElem) => {
          submenuElem.remove();
        });
        // Se houver alguma vari√°vel global que guarde o submenu, zere-a:
        submenu = null;
        currentSubmenuCloseHandler = null;
        saveState();
      }

      // Undo: Ctrl+Z ou Command+Z (sem Shift)
      if ((e.ctrlKey || e.metaKey) && !e.shiftKey && e.key.toLowerCase() === 'z') {
        e.preventDefault();
        undo(); // sua fun√ß√£o de desfazer
        return;
      }

      // Redo: Ctrl+Shift+Z ou Command+Shift+Z
      if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key.toLowerCase() === 'z') {
        e.preventDefault();
        redo(); // sua fun√ß√£o de refazer
        return;
      }

      // Redo: Ctrl+Y ou Command+Y
      if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'y') {
        e.preventDefault();
        redo();
        return;
      }

      // Chamada para delete dos objetos (j√° existente)
      if (e.key === 'Delete' || e.key === 'Backspace') {
        e.preventDefault();
        deleteSelectedObjects(); // sua fun√ß√£o de deletar
        saveState();
      }
    });


    document.addEventListener('keyup', (e) => {
      if (e.code === 'Space') {
        isSpacePressed = false;
        isPanning = false;
      }
    });

    let mainWidth, mainHeight;
    function resizeCanvas() {
      // O canvas agora come√ßa abaixo da navbar (60px)
      const navbarHeight = 60;
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight - navbarHeight;
      mainWidth = canvas.width;
      mainHeight = canvas.height;
      draw();
    }

    let handleSize = window.innerWidth < 768 ? 16 : 8;
    let globalIconSize = window.innerWidth < 768 ? 32 : 24;

    // Eventos de redimensionamento
    window.addEventListener("resize", resizeCanvas);

    let entities = [], attributes = [], relationships = [], specializations = [];
    let entityIdCounter = 0, attributeIdCounter = 0, relationshipIdCounter = 0, specializationIdCounter = 0;
    let undoStack = [], redoStack = [];
    const defaultEntityWidth = 160, defaultEntityHeight = 80;
    const defaultAttributeRadiusX = 40, defaultAttributeRadiusY = 20, relationshipSize = 120, defaultSpecializationSize = 100;
    let fontSize = 18;

    let selectedConnection = null, selectedSpecConnection = null;
    let draggingToolbarType = null, draggingNewObj = null, clickPlacementMode = false, toolbarDrag = null;
    let isDraggingObject = false, dragObject = null, dragOffset = { x: 0, y: 0 };
    let isDraggingGroup = false, groupDragData = [], groupMouseStart = { x: 0, y: 0 };
    let isResizing = false, resizingObject = null, resizeHandleIndex = null, resizeStartMouse = { x: 0, y: 0 }, resizingInitial = {};
    let isSelecting = false, selectionStart = { x: 0, y: 0 }, selectionRect = null;
    let isDraggingConnection = false, draggingConnection = null;
    let submenu = null, submenuRect = null, submenuTimeout = null;
    let justSelectedConnection = false;
    // Array global para armazenar info de breakpoints durante o arraste em grupo
    let groupBreakpointsData = [];

    let currentSubmenuCloseHandler = null;

    // Vari√°veis para controlar o arraste de relacionamento a partir do menu
    let draggingRelationFromMenu = false;
    let relationMenuSource = null;

    // Novos contadores para os novos tipos
    let aggregationIdCounter = 0;
    
    // Armazenamento para agrega√ß√µes
    let aggregations = [];

    const normalColors = {
      entity: { fill: "#3b82f6", stroke: "#1e40af" },
      attribute: { fill: "#10b981", stroke: "#065f46" },
      derived: { fill: "#fcd34d", stroke: "#d97706" },
      relationship: { fill: "#ec4899", stroke: "#7e22ce" },
      specialization: { fill: "#facc15", stroke: "#ca8a04" },
      multivalued : { fill: "#06b6d4", stroke: "#0e7490" },
      aggregation : { fill: "#8b5cf6", stroke: "#6d28d9" }
    };

    
    // Adicione um flag para verificar se o localStorage est√° dispon√≠vel
    function isLocalStorageAvailable() {
      try {
        const test = 'test';
        localStorage.setItem(test, test);
        localStorage.removeItem(test);
        return true;
      } catch(e) {
        console.error("LocalStorage n√£o est√° dispon√≠vel:", e);
        return false;
      }
    }


    function copySelection() {
  clipboard = {
    entities: [],
    attributes: [],
    relationships: [],
    specializations: [],
    aggregations: [],
    // Armazena a bounding box dos objetos copiados
    boundingBox: { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity }
  };

  // Fun√ß√£o auxiliar para atualizar a bounding box
  function updateBB(obj, bb) {
    if (obj.x !== undefined && obj.y !== undefined) {
      bb.minX = Math.min(bb.minX, obj.x);
      bb.minY = Math.min(bb.minY, obj.y);
      // Para objetos com dimens√µes
      if (obj.width && obj.height) {
        bb.maxX = Math.max(bb.maxX, obj.x + obj.width);
        bb.maxY = Math.max(bb.maxY, obj.y + obj.height);
      } else {
        // Se n√£o houver dimens√µes (como atributos), considere um raio
        let r = ATTR_CIRCLE_RADIUS || 12;
        bb.maxX = Math.max(bb.maxX, obj.x + r);
        bb.maxY = Math.max(bb.maxY, obj.y + r);
      }
    }
  }

  entities.forEach(e => {
    if (e.selected) {
      let clone = JSON.parse(JSON.stringify(e));
      clipboard.entities.push(clone);
      updateBB(clone, clipboard.boundingBox);
    }
  });
  attributes.forEach(a => {
    if (a.selected) {
      let clone = JSON.parse(JSON.stringify(a));
      clipboard.attributes.push(clone);
      updateBB(clone, clipboard.boundingBox);
    }
  });
  relationships.forEach(r => {
    if (r.selected) {
      let clone = JSON.parse(JSON.stringify(r));
      clipboard.relationships.push(clone);
      updateBB(clone, clipboard.boundingBox);
    }
  });
  specializations.forEach(s => {
    if (s.selected) {
      let clone = JSON.parse(JSON.stringify(s));
      clipboard.specializations.push(clone);
      updateBB(clone, clipboard.boundingBox);
    }
  });
  aggregations.forEach(agg => {
    if (agg.selected) {
      let clone = JSON.parse(JSON.stringify(agg));
      clipboard.aggregations.push(clone);
      updateBB(clone, clipboard.boundingBox);
    }
  });
}



function pasteClipboard() {
  if (!clipboard) return;
  
  // Calcula o centro da bounding box dos objetos copiados
  const bb = clipboard.boundingBox;
  const centerX = (bb.minX + bb.maxX) / 2;
  const centerY = (bb.minY + bb.maxY) / 2;
  
  // Calcula o deslocamento para posicionar o centro do grupo no lastMousePos
  const dx = lastMousePos.x - centerX;
  const dy = lastMousePos.y - centerY;
  
  // Cria√ß√£o de mapas para atualizar os IDs internos
  const entityIdMap = {};
  const attributeIdMap = {};
  const relationshipIdMap = {};
  const specializationIdMap = {};
  const aggregationIdMap = {};

  // Limpa a sele√ß√£o atual (para que s√≥ fiquem os novos colados selecionados)
  clearSelection();

  // Cole as entidades
  clipboard.entities.forEach(oldEntity => {
    let newEntity = JSON.parse(JSON.stringify(oldEntity));
    newEntity.id = entityIdCounter++;
    newEntity.x += dx;
    newEntity.y += dy;
    newEntity.selected = true; // os novos colados ficam selecionados
    entities.push(newEntity);
    entityIdMap[oldEntity.id] = newEntity.id;
  });

  // Cole os relacionamentos (atualizando as conex√µes)
  clipboard.relationships.forEach(oldRel => {
    let newRel = JSON.parse(JSON.stringify(oldRel));
    newRel.id = relationshipIdCounter++;
    newRel.x += dx;
    newRel.y += dy;
    newRel.selected = true;
    
    // AQUI EST√Å A PRIMEIRA CORRE√á√ÉO:
    // Filtrar conex√µes para manter apenas aquelas com entidades que tamb√©m foram copiadas
    if (newRel.connections) {
      newRel.connections = newRel.connections.filter(conn => 
        entityIdMap[conn.entityId] !== undefined
      );
      
      // Atualizar os IDs das entidades nas conex√µes
      newRel.connections.forEach(conn => {
        if (entityIdMap[conn.entityId] !== undefined) {
          conn.entityId = entityIdMap[conn.entityId];
        }
      });
    }
    
    relationships.push(newRel);
    relationshipIdMap[oldRel.id] = newRel.id;
  });

  // Cole as especializa√ß√µes (atualizando as conex√µes)
  clipboard.specializations.forEach(oldSpec => {
    let newSpec = JSON.parse(JSON.stringify(oldSpec));
    newSpec.id = specializationIdCounter++;
    newSpec.x += dx;
    newSpec.y += dy;
    newSpec.selected = true;
    
    // Similar √† corre√ß√£o para relacionamentos
    if (newSpec.connections) {
      newSpec.connections = newSpec.connections.filter(conn => 
        entityIdMap[conn.entityId] !== undefined
      );
      
      newSpec.connections.forEach(conn => {
        if (entityIdMap[conn.entityId] !== undefined) {
          conn.entityId = entityIdMap[conn.entityId];
        }
      });
    }
    
    specializations.push(newSpec);
    specializationIdMap[oldSpec.id] = newSpec.id;
  });

  // Cole as agrega√ß√µes (atualizando as conex√µes)
  clipboard.aggregations.forEach(oldAgg => {
    let newAgg = JSON.parse(JSON.stringify(oldAgg));
    newAgg.id = aggregationIdCounter++;
    newAgg.x += dx;
    newAgg.y += dy;
    newAgg.selected = true;
    
    // Similar √† corre√ß√£o para relacionamentos
    if (newAgg.connections) {
      newAgg.connections = newAgg.connections.filter(conn => 
        (conn.entityId && entityIdMap[conn.entityId] !== undefined) ||
        (conn.relationshipId && relationshipIdMap[conn.relationshipId] !== undefined)
      );
      
      newAgg.connections.forEach(conn => {
        if (conn.entityId && entityIdMap[conn.entityId] !== undefined) {
          conn.entityId = entityIdMap[conn.entityId];
        }
        if (conn.relationshipId && relationshipIdMap[conn.relationshipId] !== undefined) {
          conn.relationshipId = relationshipIdMap[conn.relationshipId];
        }
      });
    }
    
    aggregations.push(newAgg);
    aggregationIdMap[oldAgg.id] = newAgg.id;
  });

  // Cole os atributos (atualizando o parentId se necess√°rio)
  // MOVER ESTE BLOCO PARA DEPOIS DOS RELACIONAMENTOS
  clipboard.attributes.forEach(oldAttr => {
    let newAttr = JSON.parse(JSON.stringify(oldAttr));
    newAttr.id = attributeIdCounter++;
    newAttr.x += dx;
    newAttr.y += dy;
    newAttr.selected = true;
    
    // AQUI EST√Å A SEGUNDA CORRE√á√ÉO:
    // Verifica e atualiza parentId baseado no tipo de parent
    if (newAttr.parentType === "entity" && entityIdMap[newAttr.parentId] !== undefined) {
      newAttr.parentId = entityIdMap[newAttr.parentId];
    } else if (newAttr.parentType === "attribute" && attributeIdMap[newAttr.parentId] !== undefined) {
      newAttr.parentId = attributeIdMap[newAttr.parentId];
    } else if (newAttr.parentType === "relationship" && relationshipIdMap[newAttr.parentId] !== undefined) {
      newAttr.parentId = relationshipIdMap[newAttr.parentId];
    } else if (newAttr.parentType === "aggregation" && aggregationIdMap[newAttr.parentId] !== undefined) {
      newAttr.parentId = aggregationIdMap[newAttr.parentId];
    } else {
      // Se o parent n√£o foi copiado, n√£o adicione este atributo
      return; // Skip this attribute
    }
    
    attributes.push(newAttr);
    attributeIdMap[oldAttr.id] = newAttr.id;
  });

  // Ap√≥s colar, salve o estado e redesenhe
  saveState();
  draw();
}
  // M√©todo para salvar antes de fechar a p√°gina
  window.addEventListener('beforeunload', (e) => {
    if (hasUnsavedChanges) {
      saveToLocalStorage();
    }
  });


  // Adicionando auto-save a cada 30 segundos
  const autoSaveInterval = 30000; // 30 segundos
  setInterval(() => {
    if (hasUnsavedChanges) {
      saveToLocalStorage();
    }
  }, autoSaveInterval);



  // Fun√ß√£o restoreState
  function restoreState(state) {
    entities = JSON.parse(JSON.stringify(state.entities));
    attributes = JSON.parse(JSON.stringify(state.attributes));
    relationships = JSON.parse(JSON.stringify(state.relationships));
    specializations = JSON.parse(JSON.stringify(state.specializations));
    
    // Se a propriedade 'aggregations' existir no estado, restaura
    if (state.aggregations) {
      aggregations = JSON.parse(JSON.stringify(state.aggregations));
    } else {
      aggregations = []; // Caso seja um estado antigo sem agrega√ß√µes
    }
    
    draw();
  }

  // Inicializa√ß√£o
  document.addEventListener("DOMContentLoaded", function() {
    // Setup do menu mobile
    const mobileMenuToggle = document.getElementById("mobile-menu-toggle");
    const mobileSidebar = document.getElementById("mobile-sidebar");
    
    mobileMenuToggle.addEventListener("click", function() {
      mobileSidebar.classList.toggle("open");
    });
    
    // Fechar o menu mobile ao clicar no canvas
    canvas.addEventListener("click", function() {
      mobileSidebar.classList.remove("open");
    });
    
    // Setup dos bot√µes mobile
    setupMobileButtons();
    
    // Inicializa o canvas
    resizeCanvas();
    
    // Carrega dados salvos
    loadFromLocalStorage();
    
    // Desenha o canvas
    draw();
    
    // Adiciona eventos para os bot√µes principais
    setupDesktopButtons();
    
    // Adiciona eventos para o canvas
    setupCanvasEvents();
    
    // Adiciona eventos para teclas
    setupKeyboardEvents();
  });


  // C√≥digo para implementar os menus que n√£o fecham
  document.addEventListener("DOMContentLoaded", function() {
    // Seleciona todas as categorias do menu
    const menuCategories = document.querySelectorAll('.menu-category');
    
    // Adiciona eventos para cada bot√£o de categoria
    menuCategories.forEach(category => {
      // Refer√™ncia ao bot√£o da categoria
      const button = category.querySelector('.menu-category-btn');
      
      // Ao clicar, alterna o estado do dropdown
      button.addEventListener('click', function(e) {
        e.stopPropagation(); // Impede que o clique chegue ao document
        
        // Fecha todos os outros menus primeiro
        menuCategories.forEach(otherCategory => {
          if (otherCategory !== category) {
            otherCategory.classList.remove('open');
          }
        });
        
        // Alterna o estado deste menu
        category.classList.toggle('open');
      });
      
      // Evita que o menu feche quando clicar dentro dele
      const dropdown = category.querySelector('.menu-dropdown');
      if (dropdown) {
        dropdown.addEventListener('click', function(e) {
          e.stopPropagation(); // Impede propaga√ß√£o para n√£o fechar o menu
        });
      }
    });
    
    // Fecha todos os menus ao clicar fora deles
    document.addEventListener('click', function() {
      menuCategories.forEach(category => {
        category.classList.remove('open');
      });
    });
  });


  // Adicionar novos eventos de drag para os bot√µes
  document.getElementById("btnMultivaluedAttribute").addEventListener("mousedown", (e) => startToolbarDrag("multivaluedAttribute", e));
  document.getElementById("btnAggregation").addEventListener("mousedown", (e) => startToolbarDrag("aggregation", e));
  
  
  // Adicionando event listeners para os bot√µes mobile
  function addMobileListeners() {
    const mobileButtonIds = [
      "MultivaluedAttribute", "Aggregation"
    ];
    
    mobileButtonIds.forEach(id => {
      const mobileBtn = document.getElementById(`btn${id}-mobile`);
      const desktopBtn = document.getElementById(`btn${id}`);
      
      if (mobileBtn && desktopBtn) {
        mobileBtn.addEventListener("mousedown", function(e) {
          const newEvent = new MouseEvent("mousedown", {
            clientX: e.clientX,
            clientY: e.clientY,
            bubbles: true
          });
          desktopBtn.dispatchEvent(newEvent);
          
          document.getElementById("mobile-sidebar").classList.remove("open");
        });
        
        mobileBtn.addEventListener("touchstart", function(e) {
          const touch = e.touches[0];
          const newEvent = new MouseEvent("mousedown", {
            clientX: touch.clientX,
            clientY: touch.clientY,
            bubbles: true
          });
          desktopBtn.dispatchEvent(newEvent);
          
          document.getElementById("mobile-sidebar").classList.remove("open");
        });
      }
    });
  }
  
  // Chamar a fun√ß√£o para adicionar os listeners
  document.addEventListener("DOMContentLoaded", function() {
    addMobileListeners();
  });



  // Configura√ß√£o dos bot√µes mobile
  function setupMobileButtons() {
      const buttonIds = [
        "Entity", "Attribute", "DerivedAttribute", "Relationship", "Specialization",
        "IncreaseFont", "DecreaseFont", "Clear", "Export", "Undo", "Redo", "SaveFile", "OpenFile"
      ];
      
      buttonIds.forEach(id => {
        const mobileBtn = document.getElementById(`btn${id}-mobile`);
        const desktopBtn = document.getElementById(`btn${id}`);
        
        if (mobileBtn && desktopBtn) {
          // Para bot√µes que usam eventos mousedown (drag start)
          if (["Entity", "Attribute", "DerivedAttribute", "Relationship", "Specialization"].includes(id)) {
            mobileBtn.addEventListener("mousedown", function(e) {
              // Simula o evento no bot√£o desktop
              const newEvent = new MouseEvent("mousedown", {
                clientX: e.clientX,
                clientY: e.clientY,
                bubbles: true
              });
              desktopBtn.dispatchEvent(newEvent);
              
              // Fecha o menu
              document.getElementById("mobile-sidebar").classList.remove("open");
            });
            
            // Suporte a toque
            mobileBtn.addEventListener("touchstart", function(e) {
              const touch = e.touches[0];
              const newEvent = new MouseEvent("mousedown", {
                clientX: touch.clientX,
                clientY: touch.clientY,
                bubbles: true
              });
              desktopBtn.dispatchEvent(newEvent);
              
              // Fecha o menu
              document.getElementById("mobile-sidebar").classList.remove("open");
            });
          } 
          // Para bot√µes que usam click
          else {
            mobileBtn.addEventListener("click", function() {
              desktopBtn.click();
              document.getElementById("mobile-sidebar").classList.remove("open");
            });
          }
        }
      });
    }




     // Configura√ß√£o dos bot√µes desktop
     function setupDesktopButtons() {
      document.getElementById("btnEntity").addEventListener("mousedown", (e) => startToolbarDrag("entity", e));
      document.getElementById("btnAttribute").addEventListener("mousedown", (e) => startToolbarDrag("attribute", e));
      document.getElementById("btnDerivedAttribute").addEventListener("mousedown", (e) => startToolbarDrag("derivedAttribute", e));
      document.getElementById("btnRelationship").addEventListener("mousedown", (e) => startToolbarDrag("relationship", e));
      document.getElementById("btnSpecialization").addEventListener("mousedown", (e) => startToolbarDrag("specialization", e));
      document.getElementById("btnIncreaseFont").addEventListener("click", () => { fontSize += 2; draw(); });
      document.getElementById("btnDecreaseFont").addEventListener("click", () => { fontSize = Math.max(8, fontSize - 2); draw(); });
      document.getElementById("btnClearFloating").addEventListener("click", () => {
        saveState();
        entities = [];
        attributes = [];
        relationships = [];
        specializations = [];
        aggregations = [];
        fontSize = 18;
        clearSelection();
        draw();
      });
      document.getElementById("btnClear-mobile").addEventListener("click", () => {
        saveState();
        entities = [];
        attributes = [];
        relationships = [];
        specializations = [];
        aggregations = [];
        fontSize = 18;
        clearSelection();
        draw();
      });


      
      document.getElementById("btnExport").addEventListener("click", exportDiagram);
      document.getElementById("btnUndoFloating").addEventListener("click", undo);
      document.getElementById("btnRedoFloating").addEventListener("click", redo);
      document.getElementById("btnSaveFile").addEventListener("click", saveDiagramToFile);
      document.getElementById("btnOpenFile").addEventListener("click", openFileSelector);
    }

    // Configura√ß√£o dos eventos do canvas
    function setupCanvasEvents() {
      canvas.addEventListener("touchstart", onCanvasStart);
      canvas.addEventListener("touchmove", onCanvasMove);
      canvas.addEventListener("touchend", onCanvasEnd);
      canvas.addEventListener("touchcancel", onCanvasEnd);
      canvas.addEventListener("mousedown", onCanvasStart);
      canvas.addEventListener("mousemove", onCanvasMove);
      canvas.addEventListener("mouseup", onCanvasEnd);
      canvas.addEventListener("dblclick", onCanvasDblClick);
      canvas.addEventListener("contextmenu", onCanvasContextMenu);
    }


    // Configura√ß√£o dos eventos do teclado
    function setupKeyboardEvents() {
      document.addEventListener("keydown", (e) => {
        if (e.key === "Control" || e.key === "Meta") { // Meta para suporte a Mac
          isCtrlPressed = true;
          updateCursor();
        }

        // N√£o intercepta teclas se estiver editando texto
        if (document.activeElement && 
            (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'SELECT')) {
          return;
        }
        

        // Atalho Copiar: Ctrl+C ou Command+C
        if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'c') {
          e.preventDefault();
          copySelection();
          showNotification("Copiado!", "success");
          return;
        }

        // Atalho Colar: Ctrl+V ou Command+V
        if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'v') {
          e.preventDefault();
          pasteClipboard();
          showNotification("Colado!", "success");
          return;
        }
        
        if (e.code === 'Space') {
          isSpacePressed = true;
          e.preventDefault();
        } else if (e.key === "Escape") {
          if (isDraggingConnection) {
            isDraggingConnection = false;
            draggingConnection = null;
            draw();
          }
          if (draggingToolbarType) {
            cleanupToolbarDrag();
            draw();
          }
        } else if (e.key === "Delete") {
          deleteSelectedObjects();
        }
      });
      
      document.addEventListener("keyup", (e) => {
        if (e.key === "Control" || e.key === "Meta") {
          isCtrlPressed = false;
          updateCursor();
        }
        if (e.code === 'Space') {
          isSpacePressed = false;
          isPanning = false;
        }
      });
    }



  // Event Listeners para os novos bot√µes
document.addEventListener("DOMContentLoaded", function() {
  // Adiciona listeners para os bot√µes de salvar/abrir
  document.getElementById("btnSaveFile").addEventListener("click", saveDiagramToFile);
  document.getElementById("btnOpenFile").addEventListener("click", openFileSelector);
  
  // Configura o input de arquivo
  const fileInput = document.getElementById("fileInput");
  fileInput.addEventListener("change", function(event) {
    if (event.target.files.length > 0) {
      const file = event.target.files[0];
      loadDiagramFromFile(file);
      // Limpa o valor para permitir selecionar o mesmo arquivo novamente
      fileInput.value = "";
    }
  });
  
  // Adiciona suporte para arrastar e soltar arquivos
  const canvas = document.getElementById("canvas");
  
  canvas.addEventListener("dragover", function(event) {
    event.preventDefault();
    canvas.classList.add("border-4", "border-blue-500", "border-dashed");
  });
  
  canvas.addEventListener("dragleave", function() {
    canvas.classList.remove("border-4", "border-blue-500", "border-dashed");
  });
  
  canvas.addEventListener("drop", function(event) {
    event.preventDefault();
    canvas.classList.remove("border-4", "border-blue-500", "border-dashed");
    
    if (event.dataTransfer.files.length > 0) {
      const file = event.dataTransfer.files[0];
      if (file.name.endsWith('.merdb')) {
        loadDiagramFromFile(file);
      } else {
        showNotification("Formato de arquivo n√£o suportado. Use arquivos .merdb", "error");
      }
    }
  });
});




  // Vers√£o melhorada de loadFromLocalStorage para garantir o debug
function loadFromLocalStorage() {
  
  
  try {
    const dataStr = localStorage.getItem("diagramData");
    
    
    
    if (!dataStr) {
      console.log("Nenhum diagrama encontrado no localStorage");
      return; // n√£o tem nada salvo ainda
    }

    const data = JSON.parse(dataStr);
    console.log("Carregando diagrama do localStorage, conte√∫do:", data);

    // Carrega somente se realmente houver dados
    if (data.entities && Array.isArray(data.entities)) {
      // Restaura arrays
      entities = data.entities || [];
      attributes = data.attributes || [];
      relationships = data.relationships || [];
      specializations = data.specializations || [];
      aggregations = data.aggregations || [];

      // Restaura contadores - importante garantir que sejam n√∫meros!
      entityIdCounter = typeof data.entityIdCounter === 'number' ? data.entityIdCounter : 0;
      attributeIdCounter = typeof data.attributeIdCounter === 'number' ? data.attributeIdCounter : 0;
      relationshipIdCounter = typeof data.relationshipIdCounter === 'number' ? data.relationshipIdCounter : 0;
      specializationIdCounter = typeof data.specializationIdCounter === 'number' ? data.specializationIdCounter : 0;
      aggregationIdCounter = typeof data.aggregationIdCounter === 'number' ? data.aggregationIdCounter : 0;
      
      // Restaura configura√ß√µes visuais
      if (data.fontSize) fontSize = data.fontSize;
      if (data.panOffset) panOffset = data.panOffset;
      
      console.log("Diagrama carregado com sucesso:", {
        entidades: entities.length,
        atributos: attributes.length,
        relacionamentos: relationships.length,
        especializacoes: specializations.length
      });

      return true; // indica que carregou com sucesso
    } else {
      console.warn("Dados encontrados no localStorage, mas sem entidades v√°lidas");
      return false;
    }
  } catch (err) {
    console.error("Falha ao carregar do localStorage:", err);
    return false;
  }
}

// Vers√£o melhorada de saveToLocalStorage para garantir o sucesso
function saveToLocalStorage() {
  try {
    const currentData = {
      entities,
      attributes,
      relationships,
      specializations,
      aggregations,
      entityIdCounter,
      attributeIdCounter,
      relationshipIdCounter,
      specializationIdCounter,
      aggregationIdCounter, // Adicionar este contador
      fontSize,
      panOffset
    };
    
    
    
    const jsonData = JSON.stringify(currentData);
    localStorage.setItem("diagramData", jsonData);
    
    // Verifica√ß√£o de que foi salvo corretamente
    const savedData = localStorage.getItem("diagramData");
    const savedSuccess = savedData === jsonData;
    
    // Mostra indicador de autosave
    const indicator = document.getElementById("autosave-indicator");
    if (indicator) {
      indicator.textContent = savedSuccess ? 
        "Salvo √†s " + new Date().toLocaleTimeString() : 
        "Erro de verifica√ß√£o ao salvar";
      
      indicator.classList.remove("opacity-0");
      indicator.classList.add("opacity-100");
      
      // Esconde o indicador ap√≥s 2 segundos
      setTimeout(() => {
        indicator.classList.remove("opacity-100");
        indicator.classList.add("opacity-0");
      }, 2000);
    }
    
    console.log("Diagrama salvo no localStorage:", new Date().toLocaleTimeString(), savedSuccess ? "‚úì" : "‚úó");
    return savedSuccess;
  } catch (err) {
    console.error("Erro ao salvar no localStorage:", err);
    
    // Mostra erro no indicador
    const indicator = document.getElementById("autosave-indicator");
    if (indicator) {
      indicator.classList.remove("opacity-0");
      indicator.classList.add("opacity-100");
      indicator.classList.remove("text-green-400");
      indicator.classList.add("text-red-500");
      indicator.textContent = "Erro ao salvar: " + err.message;
      
      // Esconde ap√≥s 3 segundos
      setTimeout(() => {
        indicator.classList.remove("opacity-100");
        indicator.classList.add("opacity-0");
        indicator.classList.add("text-green-400");
        indicator.classList.remove("text-red-500");
      }, 3000);
    }
    return false;
  }
}

// Importante: Garante que n√£o salvamos um estado vazio se o carregamento falhar
function saveState() {
  // N√£o salva um estado vazio se n√£o houver opera√ß√µes reais
  if (entities.length === 0 && attributes.length === 0 &&
      relationships.length === 0 && specializations.length === 0 &&
      undoStack.length === 0) {
    
    return;
  }

  // Salva no stack de Undo/Redo
  const state = {
    entities: JSON.parse(JSON.stringify(entities)),
    attributes: JSON.parse(JSON.stringify(attributes)),
    relationships: JSON.parse(JSON.stringify(relationships)),
    specializations: JSON.parse(JSON.stringify(specializations)),
    aggregations: JSON.parse(JSON.stringify(aggregations))
  };
  undoStack.push(state);
  redoStack = [];

  // Marca que h√° mudan√ßas n√£o salvas
  hasUnsavedChanges = true;
  
  // Salva imediatamente no localStorage
  saveToLocalStorage();
}


// Fun√ß√£o para salvar o diagrama em um arquivo
function saveDiagramToFile() {
  try {
    // Cria um objeto com todos os dados do diagrama
    const diagramData = {
      entities,
      attributes,
      relationships,
      specializations,
      aggregations,
      entityIdCounter,
      attributeIdCounter,
      relationshipIdCounter,
      specializationIdCounter,
      aggregationIdCounter,
      fontSize,
      panOffset,
      version: "1.0" // √ötil para compatibilidade futura
    };
    
    // Converte para JSON e cria um Blob
    const jsonData = JSON.stringify(diagramData, null, 2);
    const blob = new Blob([jsonData], { type: "application/json" });
    
    // Cria um link para download e dispara o clique
    const link = document.createElement("a");
    link.href = URL.createObjectURL(blob);
    
    // Gera um nome de arquivo baseado na data e hora atual
    const now = new Date();
    const dateStr = now.toISOString().slice(0, 10).replace(/-/g, "");
    const timeStr = now.toTimeString().slice(0, 8).replace(/:/g, "");
    link.download = `diagrama_er_${dateStr}_${timeStr}.merdb`; // .merdb = Modelagem ER DataBase
    
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    // Mostra uma mensagem de sucesso
    showNotification("Diagrama salvo com sucesso!", "success");
  } catch (err) {
    console.error("Erro ao salvar diagrama em arquivo:", err);
    showNotification("Erro ao salvar o arquivo: " + err.message, "error");
  }
}


// Fun√ß√£o para abrir o seletor de arquivos
function openFileSelector() {
  document.getElementById("fileInput").click();
}

// Fun√ß√£o para carregar um diagrama de um arquivo
function loadDiagramFromFile(file) {
  const reader = new FileReader();
  
  reader.onload = function(event) {
    try {
      const jsonData = event.target.result;
      const diagramData = JSON.parse(jsonData);
      
      // Verifica se o arquivo tem o formato esperado
      if (!diagramData.entities || !Array.isArray(diagramData.entities)) {
        throw new Error("Formato de arquivo inv√°lido");
      }
      
      // Abre o modal de confirma√ß√£o
      const modal = document.getElementById("loadModal");
      modal.classList.remove("hidden");
      
      // Configura os bot√µes do modal
      document.getElementById("loadCancelBtn").onclick = function() {
        modal.classList.add("hidden");
      };
      
      document.getElementById("loadConfirmBtn").onclick = function() {
        // Carrega os dados do arquivo
        entities = diagramData.entities || [];
        attributes = diagramData.attributes || [];
        relationships = diagramData.relationships || [];
        specializations = diagramData.specializations || [];
        
        // ADICIONE ESTA LINHA PARA CARREGAR AGREGA√á√ïES
        aggregations = diagramData.aggregations || [];
        
        // Carrega os contadores
        entityIdCounter = diagramData.entityIdCounter || 0;
        attributeIdCounter = diagramData.attributeIdCounter || 0;
        relationshipIdCounter = diagramData.relationshipIdCounter || 0;
        specializationIdCounter = diagramData.specializationIdCounter || 0;
        
        // Adicione o contador de agrega√ß√µes
        aggregationIdCounter = diagramData.aggregationIdCounter || 0;
        
        // Carrega as configura√ß√µes visuais
        if (diagramData.fontSize) fontSize = diagramData.fontSize;
        if (diagramData.panOffset) panOffset = diagramData.panOffset;
        
        // Salva no localStorage tamb√©m
        saveToLocalStorage();
        
        // Atualiza o desenho
        draw();
        
        // Fecha o modal
        modal.classList.add("hidden");
        
        // Mostra uma mensagem de sucesso
        showNotification("Diagrama carregado com sucesso!", "success");
      };
    } catch (err) {
      console.error("Erro ao carregar arquivo:", err);
      showNotification("Erro ao carregar o arquivo: " + err.message, "error");
    }
  };
  
  reader.onerror = function() {
    showNotification("Erro ao ler o arquivo", "error");
  };
  
  reader.readAsText(file);
}

// Fun√ß√£o para mostrar notifica√ß√µes
function showNotification(message, type = "info") {
  const indicator = document.getElementById("autosave-indicator");
  if (!indicator) return;
  
  // Configura a cor baseada no tipo
  indicator.classList.remove("text-green-400", "text-red-500", "text-blue-400");
  
  if (type === "success") {
    indicator.classList.add("text-green-400");
  } else if (type === "error") {
    indicator.classList.add("text-red-500");
  } else {
    indicator.classList.add("text-blue-400");
  }
  
  // Define a mensagem e mostra
  indicator.textContent = message;
  indicator.classList.remove("opacity-0");
  indicator.classList.add("opacity-100");
  
  // Esconde ap√≥s 3 segundos
  setTimeout(() => {
    indicator.classList.remove("opacity-100");
    indicator.classList.add("opacity-0");
  }, 3000);
}



  function undo() {
    if (undoStack.length > 0) {
      const currentState = {
        entities: JSON.parse(JSON.stringify(entities)),
        attributes: JSON.parse(JSON.stringify(attributes)),
        relationships: JSON.parse(JSON.stringify(relationships)),
        specializations: JSON.parse(JSON.stringify(specializations)),
        aggregations: JSON.parse(JSON.stringify(aggregations))
      };
      redoStack.push(currentState);
      const prevState = undoStack.pop();
      restoreState(prevState);
    }
  }


  function redo() {
    if (redoStack.length > 0) {
      const currentState = {
        entities: JSON.parse(JSON.stringify(entities)),
        attributes: JSON.parse(JSON.stringify(attributes)),
        relationships: JSON.parse(JSON.stringify(relationships)),
        specializations: JSON.parse(JSON.stringify(specializations))
      };
      undoStack.push(currentState);
      const nextState = redoStack.pop();
      restoreState(nextState);
    }
  }

    function breakLongWord(word, maxWidth, context) {
      let lines = [], current = "";
      for (let i = 0; i < word.length; i++) {
        let test = current + word[i];
        if (context.measureText(test).width > maxWidth && current !== "") {
          lines.push(current);
          current = word[i];
        } else {
          current = test;
        }
      }
      if (current !== "") lines.push(current);
      return lines;
    }
    function wrapText(context, text, maxWidth) {
      let words = text.split(" "), processed = [];
      for (let w of words) {
        if (context.measureText(w).width > maxWidth) {
          processed.push(...breakLongWord(w, maxWidth, context));
        } else {
          processed.push(w);
        }
      }
      let lines = [], currentLine = processed[0] || "";
      for (let i = 1; i < processed.length; i++) {
        let testLine = currentLine + " " + processed[i];
        if (context.measureText(testLine).width <= maxWidth) {
          currentLine = testLine;
        } else {
          lines.push(currentLine);
          currentLine = processed[i];
        }
      }
      if (currentLine !== "") lines.push(currentLine);
      return lines;
    }
    function drawWrappedText(context, text, centerX, centerY, maxWidth, isPrimary) {
      context.textAlign = "center";
      context.textBaseline = "middle";
      const lines = wrapText(context, text, maxWidth);
      const lineHeight = fontSize * 1.2;
      const totalHeight = lines.length * lineHeight;
      let y = centerY - totalHeight / 2 + lineHeight / 2;
      for (let i = 0; i < lines.length; i++) {
        let line = lines[i];
        context.fillText(line, centerX, y);
        if (isPrimary && i === 0) {
          const textWidth = context.measureText(line).width;
          context.fillRect(centerX - textWidth/2, y + fontSize*0.4, textWidth, 1);
        }
        y += lineHeight;
      }
      return lines;
    }
    function getRectBorderPoint(cx, cy, dx, dy, hw, hh) {
      if (dx === 0 && dy === 0) return { x: cx, y: cy };
      const scaleX = hw / Math.abs(dx);
      const scaleY = hh / Math.abs(dy);
      const f = Math.min(scaleX, scaleY);
      return { x: cx + dx * f, y: cy + dy * f };
    }
    function getCircleBorderPoint(cx, cy, dx, dy, radiusX, radiusY) {
      const angle = Math.atan2(dy, dx);
      const rx = radiusX || defaultAttributeRadiusX;
      const ry = radiusY || defaultAttributeRadiusY;
      return {
        x: cx + rx * Math.cos(angle),
        y: cy + ry * Math.sin(angle)
      };
    }

// Tamb√©m podemos melhorar a fun√ß√£o que calcula os pontos de conex√£o para relacionamentos em geral
function getDiamondBorderPoint(cx, cy, dx, dy, half) {
  // Se n√£o houver dire√ß√£o, retorna o centro
  if (dx === 0 && dy === 0) return { x: cx, y: cy };
  
  // Calcula o ponto de interse√ß√£o com o losango
  // Determina qual borda do losango intersecta primeiro
  const abs_dx = Math.abs(dx);
  const abs_dy = Math.abs(dy);
  
  let t;
  if (abs_dx * half >= abs_dy * half) {
    // Intersecta na borda horizontal (esquerda ou direita)
    t = half / abs_dx;
  } else {
    // Intersecta na borda vertical (superior ou inferior)
    t = half / abs_dy;
  }
  
  return {
    x: cx + dx * t,
    y: cy + dy * t
  };
}



    function getSpecializationVertices(spec) {
      let side = spec.size || defaultSpecializationSize;
      let cx = spec.x, cy = spec.y;
      let v1 = { x: cx, y: cy - (Math.sqrt(3)/3)*side };
      let v2 = { x: cx - side/2, y: cy + (Math.sqrt(3)/6)*side };
      let v3 = { x: cx + side/2, y: cy + (Math.sqrt(3)/6)*side };
      return [v1, v2, v3];
    }
    // Calcula a interse√ß√£o entre a linha e os lados do tri√¢ngulo (especializa√ß√£o)
    function getTriangleBorderPoint(spec, mousePos) {
      let vertices = getSpecializationVertices(spec);
      let center = { x: spec.x, y: spec.y };
      let dx = mousePos.x - center.x;
      let dy = mousePos.y - center.y;
      let intersections = [];
      for (let i = 0; i < 3; i++) {
        let v1 = vertices[i];
        let v2 = vertices[(i+1)%3];
        let inter = getLineIntersection(center, { x: center.x + dx, y: center.y + dy }, v1, v2);
        if (inter) {
          if ((inter.x - center.x)*dx + (inter.y - center.y)*dy >= 0) {
            intersections.push(inter);
          }
        }
      }
      if (intersections.length > 0) {
        let minDist = Infinity, chosen = null;
        for (let p of intersections) {
          let d = Math.hypot(p.x - center.x, p.y - center.y);
          if (d < minDist) { minDist = d; chosen = p; }
        }
        return chosen;
      }
      return center;
    }
    function getLineIntersection(p0, p1, p2, p3) {
      let s1_x = p1.x - p0.x;
      let s1_y = p1.y - p0.y;
      let s2_x = p3.x - p2.x;
      let s2_y = p3.y - p2.y;
      let denom = (-s2_x * s1_y + s1_x * s2_y);
      if (denom === 0) return null;
      let s = (-s1_y * (p0.x - p2.x) + s1_x * (p0.y - p2.y)) / denom;
      let t = ( s2_x * (p0.y - p2.y) - s2_y * (p0.x - p2.x)) / denom;
      if (s >= 0 && s <= 1 && t >= 0 && t <= 1) {
          return { x: p0.x + (t * s1_x), y: p0.y + (t * s1_y) };
      }
      return null;
    }

    function isInsideRect(pos, rect) {
      // Transforma as coordenadas do rect para o espa√ßo da tela
      let screenRectX = (rect.x + panOffset.x) * zoom;
      let screenRectY = (rect.y + panOffset.y) * zoom;
      let screenRectWidth = rect.width * zoom;
      let screenRectHeight = rect.height * zoom;

      // Transforma as coordenadas do clique para o espa√ßo da tela
      let screenPosX = (pos.x + panOffset.x) * zoom;
      let screenPosY = (pos.y + panOffset.y) * zoom;

      return pos.x >= rect.x && 
         pos.x <= rect.x + rect.width && 
         pos.y >= rect.y && 
         pos.y <= rect.y + rect.height;
    }

// Certifique-se de que getMousePos() est√° consistente com estas altera√ß√µes
function getMousePos(evt) {
  const rect = canvas.getBoundingClientRect();
  let clientX = evt.clientX, clientY = evt.clientY;
  if (evt.touches && evt.touches.length > 0) {
    clientX = evt.touches[0].clientX;
    clientY = evt.touches[0].clientY;
  }
  // Ajuste correto para o zoom e pan
  return { 
    x: (clientX - rect.left) / zoom - panOffset.x, 
    y: (clientY - rect.top) / zoom - panOffset.y 
  };
}




function getDiamondBorderPointCorrect(cx, cy, targetX, targetY, size) {
  // Se o alvo for o pr√≥prio centro, retorna o centro
  if (targetX === cx && targetY === cy) return { x: cx, y: cy };
  
  // Metade do tamanho do losango
  const half = size / 2;
  
  // Definir os quatro v√©rtices do losango (em ordem hor√°ria)
  const vertices = [
    { x: cx, y: cy - half },        // Topo
    { x: cx + half, y: cy },        // Direita
    { x: cx, y: cy + half },        // Baixo
    { x: cx - half, y: cy }         // Esquerda
  ];
  
  // Linha do centro at√© o alvo
  const line = {
    p1: { x: cx, y: cy },
    p2: { x: targetX, y: targetY }
  };
  
  // Encontrar interse√ß√£o com cada aresta do losango
  let closestIntersection = null;
  let minDistance = Infinity;
  
  for (let i = 0; i < 4; i++) {
    const edgeLine = {
      p1: vertices[i],
      p2: vertices[(i + 1) % 4]
    };
    
    // Calcular interse√ß√£o entre a linha centro-alvo e a aresta atual
    const intersection = lineSegmentIntersection(line, edgeLine);
    
    if (intersection) {
      // Verificar se a interse√ß√£o est√° na dire√ß√£o correta (do centro para o alvo)
      const dirVector = {
        x: targetX - cx,
        y: targetY - cy
      };
      
      const intersectVector = {
        x: intersection.x - cx,
        y: intersection.y - cy
      };
      
      // Produto escalar positivo significa mesma dire√ß√£o
      const dotProduct = dirVector.x * intersectVector.x + dirVector.y * intersectVector.y;
      
      if (dotProduct > 0) {
        const distance = Math.sqrt(
          Math.pow(intersection.x - cx, 2) + 
          Math.pow(intersection.y - cy, 2)
        );
        
        if (distance < minDistance) {
          minDistance = distance;
          closestIntersection = intersection;
        }
      }
    }
  }
  
  // Se encontramos uma interse√ß√£o v√°lida, retornamos ela
  if (closestIntersection) {
    return closestIntersection;
  }
  
  // Caso de fallback (n√£o deveria ocorrer com geometria correta)
  return {
    x: cx + (targetX - cx) * half / Math.sqrt(Math.pow(targetX - cx, 2) + Math.pow(targetY - cy, 2)),
    y: cy + (targetY - cy) * half / Math.sqrt(Math.pow(targetX - cx, 2) + Math.pow(targetY - cy, 2))
  };
}

// Fun√ß√£o auxiliar para calcular interse√ß√£o entre dois segmentos de linha
function lineSegmentIntersection(line1, line2) {
  const x1 = line1.p1.x;
  const y1 = line1.p1.y;
  const x2 = line1.p2.x;
  const y2 = line1.p2.y;
  
  const x3 = line2.p1.x;
  const y3 = line2.p1.y;
  const x4 = line2.p2.x;
  const y4 = line2.p2.y;
  
  // C√°lculo do determinante
  const den = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
  
  // Linhas paralelas ou coincidentes
  if (den === 0) {
    return null;
  }
  
  const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / den;
  const ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / den;
  
  // Verifica se a interse√ß√£o est√° dentro dos segmentos de linha
  if (ub >= 0 && ub <= 1 && ua >= 0) {
    return {
      x: x1 + ua * (x2 - x1),
      y: y1 + ua * (y2 - y1)
    };
  }
  
  return null;
}





    function distancePointToSegment(p, a, b) {
      const A = p.x - a.x, B = p.y - a.y;
      const C = b.x - a.x, D = b.y - a.y;
      const dot = A * C + B * D;
      const len_sq = C * C + D * D;
      let param = (len_sq !== 0) ? dot / len_sq : -1;
      let xx, yy;
      if (param < 0) { xx = a.x; yy = a.y; }
      else if (param > 1) { xx = b.x; yy = b.y; }
      else { xx = a.x + param * C; yy = a.y + param * D; }
      let dx = p.x - xx, dy = p.y - yy;
      return Math.sqrt(dx * dx + dy * dy);
    }


    // Corrigir a fun√ß√£o drawAggregationConnectionLine primeiro
function drawAggregationConnectionLine(context, agg, conn, target) {
  // Ponto central da agrega√ß√£o
  const aggCenter = { x: agg.x, y: agg.y };
  
  // Ponto central do objeto alvo (entidade ou relacionamento)
  const targetCenter = target.objType === "entity" ? 
    { x: target.x + target.width/2, y: target.y + target.height/2 } : 
    { x: target.x, y: target.y };
  
  const half = (agg.size || relationshipSize) / 2;
  const rectSize = half * 1.2;  // mesmo fator que voc√™ usa ao desenhar

  // Calcula o ponto na borda da agrega√ß√£o, olhando para o primeiro breakpoint ou para o alvo
  let firstTarget = (conn.breakpoints && conn.breakpoints.length > 0) ? 
    conn.breakpoints[0] : targetCenter;
    
  // Vetor do centro da agrega√ß√£o at√© o primeiro ponto alvo
  const dx1 = firstTarget.x - agg.x;
  const dy1 = firstTarget.y - agg.y;
  
  // Calcula o ponto na borda da agrega√ß√£o
  const aggBorder = getRectBorderPoint(
    agg.x,   // centro do ret√¢ngulo
    agg.y,
    dx1, dy1,
    rectSize, // halfWidth
    rectSize  // halfHeight (pois √© quadrado)
  );
  
  // Ponto na borda do objeto alvo
  let lastSource = (conn.breakpoints && conn.breakpoints.length > 0) ?
    conn.breakpoints[conn.breakpoints.length - 1] : aggBorder;
    
  let targetBorder;
  if (target.objType === "entity") {
    // Vetor do centro da entidade para o √∫ltimo ponto da linha
    const dx2 = lastSource.x - targetCenter.x;
    const dy2 = lastSource.y - targetCenter.y;
    
    targetBorder = getRectBorderPoint(
      targetCenter.x, targetCenter.y,
      dx2, dy2,
      target.width/2, target.height/2
    );
  } else {
    // Para relacionamentos (losangos)
    const halfRel = (target.size || relationshipSize) / 2;
    targetBorder = getDiamondBorderPointCorrect(
      target.x, 
      target.y, 
      lastSource.x,      
      lastSource.y, 
      halfRel
    );
  }
  
  // Montamos os pontos da polyline
  let points = [aggBorder];
  
  // Adicionamos os breakpoints
  if (conn.breakpoints && conn.breakpoints.length > 0) {
    points.push(...conn.breakpoints);
  }
  
  // Adicionamos o ponto na borda do alvo
  points.push(targetBorder);
  
  // Desenha a linha de conex√£o
  context.beginPath();
  context.moveTo(points[0].x, points[0].y);
  for (let i = 1; i < points.length; i++) {
    context.lineTo(points[i].x, points[i].y);
  }
  
  // Define espessura maior se for selecionada
  context.lineWidth = (selectedAggregationConnection && 
                    selectedAggregationConnection.aggregationId === agg.id && 
                    ((conn.entityId && selectedAggregationConnection.entityId === conn.entityId) || 
                    (conn.relationshipId && selectedAggregationConnection.relationshipId === conn.relationshipId))) ? 4 : 2;
  
  context.strokeStyle = "#000000";
  context.stroke();
  
  // Desenha os breakpoints
  if (conn.breakpoints) {
    for (let bp of conn.breakpoints) {
      context.beginPath();
      context.arc(bp.x, bp.y, 5, 0, 2*Math.PI);
      context.fillStyle = "#000000";
      context.fill();
    }
  }
  
  // Desenha a cardinalidade
  if (conn.cardinality) {
    // Calcular a posi√ß√£o e medir o texto
    let labelPos = getPolylineMidpoint(points);
    const text = conn.cardinality || "";
    const padding = 2;                // Espa√ßo extra em volta do texto
    context.font = `${fontSize}px Poppins`; 
    context.textAlign = "center";
    context.textBaseline = "middle";

    // Medidas do texto
    const textWidth = context.measureText(text).width + 10;
    const textHeight = fontSize; // ou fontSize * 1.2, se quiser extra

    // Para ficar circular, pegamos o maior entre (metade da largura) e (metade da altura)
    const radius = Math.max(textWidth / 2, textHeight / 2) + padding;

    // Vamos desenhar o texto "acima" da linha em Y-5
    const textCenterX = labelPos.x ;
    const textCenterY = labelPos.y - 1;  // Ajuste vertical para ficar um pouco acima

    // 1) Desenha o c√≠rculo de fundo
    context.beginPath();
    context.arc(textCenterX, textCenterY, radius, 0, 2 * Math.PI);
    context.fillStyle = "#ffffff";  // Cor de fundo
    context.fill();

    
    // 2) Desenha o texto em cima do c√≠rculo
    context.fillStyle = "#000000";    // Cor do texto
    context.fillText(text, textCenterX, textCenterY);


    // 3)  Atualiza conn.labelRect, para clique:
    conn.labelRect = {
      x: textCenterX - radius,
      y: textCenterY - radius,
      width: radius * 2,
      height: radius * 2
    };
  }
}

// Agora corrigir a fun√ß√£o drawConnectionLine que lida com relacionamentos e entidades
function drawConnectionLine(context, r, conn, e) {
  const rCenter = { x: r.x, y: r.y };
  const eCenter = { x: e.x + e.width / 2, y: e.y + e.height / 2 };
  
  // Calcula o ponto na borda do losango (relacionamento)
  const half = (r.size || relationshipSize) / 2;
  
  // Determina para onde apontar a borda do relacionamento
  let firstTarget = (conn.breakpoints && conn.breakpoints.length > 0) ? 
    conn.breakpoints[0] : eCenter;
  
  // Calcula o ponto correto na borda do losango
  const rBorder = getDiamondBorderPointCorrect(r.x, r.y, firstTarget.x, firstTarget.y, half);
  
  // Determina de onde vem a linha para a entidade
  let lastSource = (conn.breakpoints && conn.breakpoints.length > 0) ?
    conn.breakpoints[conn.breakpoints.length - 1] : rBorder;
  
  // Calcula o ponto na borda da entidade
  const eBorder = getRectBorderPoint(
    eCenter.x, eCenter.y,
    lastSource.x - eCenter.x, lastSource.y - eCenter.y,
    e.width / 2, e.height / 2
  );
  
  // Monta os pontos para a polyline
  let points = [rBorder];
  
  // Adiciona os breakpoints se existirem
  if (conn.breakpoints && conn.breakpoints.length > 0) {
    points.push(...conn.breakpoints);
  }
  
  // Adiciona o ponto na borda da entidade
  points.push(eBorder);
  
  // Desenho da polyline
  context.beginPath();
  context.moveTo(points[0].x, points[0].y);
  for (let i = 1; i < points.length; i++) {
    context.lineTo(points[i].x, points[i].y);
  }
  
  // Define a espessura base: se a conex√£o for marcada como weak (fraca), usa 6, sen√£o 2.
  let baseLineWidth = (conn.weak) ? 6 : 2;
  // Se a conex√£o estiver selecionada, adiciona 2 (ou outro valor) para evidenciar a sele√ß√£o.
  if (
    selectedConnection &&
    selectedConnection.relationshipId === r.id &&
    selectedConnection.entityId === conn.entityId
  ) {
    baseLineWidth += 2;
  }
  context.lineWidth = baseLineWidth;
  context.strokeStyle = "#000000";
  context.stroke();
  
  // Desenho dos breakpoints
  if (conn.breakpoints) {
    for (let bp of conn.breakpoints) {
      context.beginPath();
      context.arc(bp.x, bp.y, 5, 0, 2*Math.PI);
      context.fillStyle = "#000000";
      context.fill();
    }
  }
  
  // Desenha a cardinalidade
  // Calcular a posi√ß√£o e medir o texto
  let labelPos = getPolylineMidpoint(points);
  const text = conn.cardinality || "";
  const padding = 2;                // Espa√ßo extra em volta do texto
  context.font = `${fontSize}px Poppins`; 
  context.textAlign = "center";
  context.textBaseline = "middle";

  // Medidas do texto
  const textWidth = context.measureText(text).width + 10;
  const textHeight = fontSize; // ou fontSize * 1.2, se quiser extra

  // Para ficar circular, pegamos o maior entre (metade da largura) e (metade da altura)
  const radius = Math.max(textWidth / 2, textHeight / 2) + padding;

  // Vamos desenhar o texto "acima" da linha em Y-5
  const textCenterX = labelPos.x ;
  const textCenterY = labelPos.y - 1;  // Ajuste vertical para ficar um pouco acima

  // 1) Desenha o c√≠rculo de fundo
  context.beginPath();
  context.arc(textCenterX, textCenterY, radius, 0, 2 * Math.PI);
  context.fillStyle = "#ffffff";  // Cor de fundo
  context.fill();

  
  // 2) Desenha o texto em cima do c√≠rculo
  context.fillStyle = "#000000";    // Cor do texto
  context.fillText(text, textCenterX, textCenterY);


  // 3)  Atualiza conn.labelRect, para clique:
  conn.labelRect = {
    x: textCenterX - radius,
    y: textCenterY - radius,
    width: radius * 2,
    height: radius * 2
  };
}


    
    function drawAll(context) {
      context.clearRect(0, 0, mainWidth, mainHeight);
      context.font = `${fontSize}px Poppins`;


        // Desenha conex√µes entre atributos e seus pais
        attributes.forEach(a => {
          if (a.parentType && a.parentId != null) {
            context.strokeStyle = "#000000";
            context.lineWidth = 2;
            
            if (a.parentType === "entity") {
              const e = entities.find(en => en.id === a.parentId);
              if (e) {
                const eCenter = { x: e.x + e.width/2, y: e.y + e.height/2 };
                // Conecta ao centro do c√≠rculo do atributo
                context.beginPath();
                context.moveTo(eCenter.x, eCenter.y);
                context.lineTo(a.x, a.y);
                context.stroke();
              }
            } else if (a.parentType === "relationship") {
              const r = relationships.find(rr => rr.id === a.parentId);
              if (r) {
                // Vetor do centro do relacionamento para o atributo
                const dx = a.x - r.x;
                const dy = a.y - r.y;
                
                // Calculamos o ponto correto de interse√ß√£o na borda do losango
                const half = (r.size || relationshipSize) / 2;
                const borderPoint = getDiamondBorderPointCorrect(r.x, r.y, a.x, a.y, half);
                
                // Desenhamos a linha do ponto de interse√ß√£o at√© o atributo
                context.beginPath();
                context.moveTo(borderPoint.x, borderPoint.y);
                context.lineTo(a.x, a.y);
                context.stroke();
              }
            } else if (a.parentType === "attribute") {
              const pA = attributes.find(at => at.id === a.parentId);
              if (pA) {
                // Conecta atributo pai ao filho
                context.beginPath();
                context.moveTo(pA.x, pA.y);
                context.lineTo(a.x, a.y);
                context.stroke();
              }
            } else if (a.parentType === "aggregation") {
              const aggr = aggregations.find(ag => ag.id === a.parentId);
              if (aggr) {
                const half = (aggr.size || relationshipSize)/2;
                const rectSize = half * 1.2;
                
                // Usamos a mesma abordagem simples para agrega√ß√µes
                const dx = a.x - aggr.x;
                const dy = a.y - aggr.y;
                
                const len = Math.sqrt(dx*dx + dy*dy);
                if (len === 0) return;
                
                const ndx = dx / len;
                const ndy = dy / len;
                
                // Aqui usamos rectSize pois a agrega√ß√£o √© um pouco maior
                const t = Math.min(
                  Math.abs(rectSize / ndx),
                  Math.abs(rectSize / ndy)
                );
                
                const intersectX = aggr.x + ndx * t;
                const intersectY = aggr.y + ndy * t;
                
                context.beginPath();
                context.moveTo(intersectX, intersectY);
                context.lineTo(a.x, a.y);
                context.stroke();
              }
            }
          }
        });

      // Desenha as conex√µes entre relacionamentos e entidades
      relationships.forEach(r => {
        r.connections.forEach(conn => {
          const e = entities.find(en => en.id === conn.entityId);
          if (e) drawConnectionLine(context, r, conn, e);
        });
      });

      // Desenha as conex√µes entre especializa√ß√µes e entidades
      specializations.forEach(spec => {
        if (spec.connections) {
          spec.connections.forEach(conn => {
            const e = entities.find(en => en.id === conn.entityId);
            if (e) drawSpecConnectionLine(context, spec, conn, e);
          });
        }
      });


      aggregations.forEach(agg => {
        if (agg.connections) {
          agg.connections.forEach(conn => {
            const target = conn.entityId ? 
              entities.find(e => e.id === conn.entityId) :
              relationships.find(r => r.id === conn.relationshipId);
            
            if (target) {
              drawAggregationConnectionLine(context, agg, conn, target);
            }
          });
        }
      });



      // Desenhar agrega√ß√µes
      aggregations.forEach(agg => {
        context.save();
        context.shadowColor = "rgba(0,0,0,0.5)";
        context.shadowBlur = 10;
        context.fillStyle = normalColors.aggregation.fill;
        context.strokeStyle = agg.selected ? "#60a5fa" : normalColors.aggregation.stroke;
        context.lineWidth = agg.selected ? 3 : 2;
        
        const half = (agg.size || relationshipSize)/2;
        const rectSize = half * 1.2;
        
        // Desenha o ret√¢ngulo externo
        context.beginPath();
        context.rect(agg.x - rectSize, agg.y - rectSize, rectSize*2, rectSize*2);
        context.stroke();
        
        // Desenha o losango interno
        context.beginPath();
        context.moveTo(agg.x, agg.y - half);
        context.lineTo(agg.x + half, agg.y);
        context.lineTo(agg.x, agg.y + half);
        context.lineTo(agg.x - half, agg.y);
        context.closePath();
        context.fill();
        context.stroke();
        
        // Desenha o texto da agrega√ß√£o
        context.fillStyle = "#ffffff";
        drawWrappedText(context, agg.name, agg.x, agg.y, agg.size - 20, false);
        
        // Desenha as al√ßas de redimensionamento se selecionado
        if (agg.selected) {
          agg.resizeHandles = [
            { x: agg.x - rectSize - handleSize/2, y: agg.y - handleSize/2, width: handleSize, height: handleSize },
            { x: agg.x + rectSize - handleSize/2, y: agg.y - handleSize/2, width: handleSize, height: handleSize },
            { x: agg.x - handleSize/2, y: agg.y - rectSize - handleSize/2, width: handleSize, height: handleSize },
            { x: agg.x - handleSize/2, y: agg.y + rectSize - handleSize/2, width: handleSize, height: handleSize }
          ];
          agg.resizeHandles.forEach(handle => {
            context.fillStyle = "#ffffff";
            context.strokeStyle = "#000000";
            context.fillRect(handle.x, handle.y, handle.width, handle.height);
            context.strokeRect(handle.x, handle.y, handle.width, handle.height);
          });
        } else {
          agg.resizeHandles = [];
        }
        
        context.restore();
      });

      entities.forEach(e => {
        context.save();
        context.shadowColor = "rgba(0,0,0,0.5)";
        context.shadowBlur = 10;
        context.fillStyle = normalColors.entity.fill;
        context.strokeStyle = e.selected ? "#60a5fa" : normalColors.entity.stroke;
        context.lineWidth = e.selected ? 3 : 2;
        const margin = 16;
        let w = e.width || defaultEntityWidth;
        let h = e.height || defaultEntityHeight;
        const lines = wrapText(context, e.name, w - margin);
        let maxLineWidth = 0;
        lines.forEach(line => {
          let tw = context.measureText(line).width;
          if (tw > maxLineWidth) maxLineWidth = tw;
        });
        let lineHeight = fontSize * 1.2;
        let neededH = lines.length * lineHeight + margin;
        let neededW = maxLineWidth + margin;
        e.width = Math.max(w, neededW);
        e.height = Math.max(h, neededH);
        context.beginPath();
        context.roundRect(e.x, e.y, e.width, e.height, 8);
        context.fill();
        context.stroke();

        // Se a entidade estiver em um relacionamento fraco, desenha um ret√¢ngulo interno para efeito de linha dupla
        if (isEntityWeak(e)) {
          let inset = 3; // ajuste conforme desejado
          context.beginPath();
          context.roundRect(e.x + inset+4, e.y + inset + 4, e.width - inset*4.5, e.height - inset*4.5, 6);
          context.stroke();
        }

        context.fillStyle = "#ffffff";
        drawWrappedText(context, e.name, e.x + e.width/2, e.y + e.height/2, e.width - margin, false);


        if (e.selected) {
          e.resizeHandles = [
            { x: e.x - handleSize/2, y: e.y - handleSize/2, width: handleSize, height: handleSize },
            { x: e.x + e.width - handleSize/2, y: e.y - handleSize/2, width: handleSize, height: handleSize },
            { x: e.x - handleSize/2, y: e.y + e.height - handleSize/2, width: handleSize, height: handleSize },
            { x: e.x + e.width - handleSize/2, y: e.y + e.height - handleSize/2, width: handleSize, height: handleSize }
          ];
          e.resizeHandles.forEach(handle => {
            context.fillStyle = "#ffffff";
            context.strokeStyle = "#000000";
            context.fillRect(handle.x, handle.y, handle.width, handle.height);
            context.strokeRect(handle.x, handle.y, handle.width, handle.height);
          });
        } else {
          e.resizeHandles = [];
        }

        
        context.restore();
      });

      // Desenha os atributos com o novo estilo
      attributes.forEach(a => {
        context.save();
        context.shadowColor = "rgba(0,0,0,0.5)";
        context.shadowBlur = 10;
        
        // Determina o estilo com base no tipo de atributo
        if (a.derived) {
          context.strokeStyle = a.selected ? "#60a5fa" : normalColors.derived.stroke;
          context.setLineDash([4, 2]);
        } else if (a.multivalued) {
          context.strokeStyle = a.selected ? "#60a5fa" : normalColors.multivalued.stroke;
        } else {
          context.strokeStyle = a.selected ? "#60a5fa" : normalColors.attribute.stroke;
        }
        
        context.lineWidth = a.selected ? 3 : 2;
        
        // Determina se o atributo √© chave prim√°ria (preenchido)
        if (a.primary) {
          context.fillStyle = a.derived ? normalColors.derived.fill : normalColors.attribute.fill;
        } else {
          context.fillStyle = "white"; // Fundo branco para os n√£o-chave
        }
        
        // Desenha o c√≠rculo do atributo
        context.beginPath();
        context.arc(a.x, a.y, ATTR_CIRCLE_RADIUS, 0, 2 * Math.PI);
        context.fill();
        context.stroke();
        
        // Desenha o segundo c√≠rculo para atributos multivalorados
        if (a.multivalued) {
          context.beginPath();
          context.arc(a.x, a.y, ATTR_CIRCLE_RADIUS * 0.7, 0, 2 * Math.PI);
          context.stroke();
        }
        
        // Resetar linha tracejada para o texto
        context.setLineDash([]);
        
        // Preparar para desenhar o texto
        context.fillStyle = "#000000";
        context.textAlign = "left";
        context.textBaseline = "middle";
        
        // Determinar o texto a ser exibido
        let displayText = a.name;
        
        // Calcular a largura do texto para ajuste
        let textWidth = context.measureText(displayText).width;
        let textHeight = fontSize;
        
        // Desenhar o texto √† direita do c√≠rculo
        context.fillText(displayText, a.x + ATTR_CIRCLE_RADIUS + ATTR_TEXT_PADDING, a.y + ATTR_TEXT_OFFSET_Y);
        
        // Armazenar a "caixa" total do atributo para detec√ß√£o de cliques
        a.hitBox = {
          x: a.x - ATTR_CIRCLE_RADIUS,
          y: a.y - ATTR_CIRCLE_RADIUS,
          width: ATTR_CIRCLE_RADIUS * 2 + ATTR_TEXT_PADDING + textWidth,
          height: Math.max(ATTR_CIRCLE_RADIUS * 2, textHeight)
        };
        
        // Se selecionado, mostrar al√ßas de redimensionamento
        if (a.selected) {
          // Agora as al√ßas de redimensionamento ficam apenas no c√≠rculo, n√£o na elipse
          a.resizeHandles = [
            { x: a.x - ATTR_CIRCLE_RADIUS - handleSize/2, y: a.y - handleSize/2, width: handleSize, height: handleSize },
            { x: a.x + ATTR_CIRCLE_RADIUS - handleSize/2, y: a.y - handleSize/2, width: handleSize, height: handleSize },
            { x: a.x - handleSize/2, y: a.y - ATTR_CIRCLE_RADIUS - handleSize/2, width: handleSize, height: handleSize },
            { x: a.x - handleSize/2, y: a.y + ATTR_CIRCLE_RADIUS - handleSize/2, width: handleSize, height: handleSize }
          ];
          
          a.resizeHandles.forEach(handle => {
            context.fillStyle = "#ffffff";
            context.strokeStyle = "#000000";
            context.fillRect(handle.x, handle.y, handle.width, handle.height);
            context.strokeRect(handle.x, handle.y, handle.width, handle.height);
          });
        } else {
          a.resizeHandles = [];
        }
        
        context.restore();
      });

      relationships.forEach(r => {
        context.save();
        context.shadowColor = "rgba(0,0,0,0.5)";
        context.shadowBlur = 10;
        context.fillStyle = normalColors.relationship.fill;
        context.strokeStyle = r.selected ? "#60a5fa" : normalColors.relationship.stroke;
        context.lineWidth = r.selected ? 3 : 2;
        const half = (r.size || relationshipSize) / 2;
        context.beginPath();
        context.moveTo(r.x, r.y - half);
        context.lineTo(r.x + half, r.y);
        context.lineTo(r.x, r.y + half);
        context.lineTo(r.x - half, r.y);
        context.closePath();
        context.fill();
        context.stroke();

        // Se o relacionamento for fraco, desenha um losango interno para efeito de linha dupla
        if (isRelationshipWeak(r)) {
          let offset = 8; // ajuste conforme desejado
          let innerHalf = half - offset;
          context.beginPath();
          context.moveTo(r.x, r.y - innerHalf);
          context.lineTo(r.x + innerHalf, r.y);
          context.lineTo(r.x, r.y + innerHalf);
          context.lineTo(r.x - innerHalf, r.y);
          context.closePath();
          // Para o contorno interno, pode-se usar a mesma cor e largura
          context.stroke();
        }

        // Desenha o texto do relacionamento por cima (n√£o interfere nas conex√µes)
        context.fillStyle = "#ffffff";
        drawWrappedText(context, r.name, r.x, r.y, r.size - 20, false);
        if (r.selected) {
          r.resizeHandles = [
            { x: r.x - half - handleSize/2, y: r.y - handleSize/2, width: handleSize, height: handleSize },
            { x: r.x + half - handleSize/2, y: r.y - handleSize/2, width: handleSize, height: handleSize },
            { x: r.x - handleSize/2, y: r.y - half - handleSize/2, width: handleSize, height: handleSize },
            { x: r.x - handleSize/2, y: r.y + half - handleSize/2, width: handleSize, height: handleSize }
          ];
          r.resizeHandles.forEach(handle => {
            context.fillStyle = "#ffffff";
            context.strokeStyle = "#000000";
            context.fillRect(handle.x, handle.y, handle.width, handle.height);
            context.strokeRect(handle.x, handle.y, handle.width, handle.height);
          });
        } else {
          r.resizeHandles = [];
        }
        context.restore();
      });

      specializations.forEach(spec => {
        context.save();
        context.shadowColor = "rgba(0,0,0,0.5)";
        context.shadowBlur = 10;
        context.fillStyle = normalColors.specialization.fill;
        context.strokeStyle = spec.selected ? "#60a5fa" : normalColors.specialization.stroke;
        context.lineWidth = spec.selected ? 3 : 2;
        const vertices = getSpecializationVertices(spec);
        context.beginPath();
        context.moveTo(vertices[0].x, vertices[0].y);
        context.lineTo(vertices[1].x, vertices[1].y);
        context.lineTo(vertices[2].x, vertices[2].y);
        context.closePath();
        context.fill();
        context.stroke();
        context.fillStyle = "#ffffff";
        drawWrappedText(context, spec.genType || "", spec.x, spec.y, spec.size - 20, false);
        if (spec.selected) {
          spec.resizeHandles = vertices.map(v => ({
            x: v.x - handleSize/2,
            y: v.y - handleSize/2,
            width: handleSize,
            height: handleSize
          }));
          spec.resizeHandles.forEach(handle => {
            context.fillStyle = "#ffffff";
            context.strokeStyle = "#000000";
            context.fillRect(handle.x, handle.y, handle.width, handle.height);
            context.strokeRect(handle.x, handle.y, handle.width, handle.height);
          });
        } else {
          spec.resizeHandles = [];
        }
        context.restore();
      });



      
      
      
      
      if (isSelecting && selectionRect) {
        context.save();
        context.setLineDash([4,2]);
        context.strokeStyle = "rgba(96,165,250,0.7)";
        context.strokeRect(selectionRect.x, selectionRect.y, selectionRect.width, selectionRect.height);
        context.restore();
      }
    }



// Verifica se um relacionamento √© fraco (todas as conex√µes s√£o weak)
function isRelationshipWeak(r) {
  return r.connections
      && r.connections.length > 0
      && r.connections.some(conn => conn.weak);
}

// Verifica se uma entidade est√° envolvida em algum relacionamento fraco
function isEntityWeak(e) {
  return relationships.some(r =>
    r.connections && r.connections.some(conn => conn.entityId === e.id && conn.weak)
  );
}

// Tamb√©m substitua a fun√ß√£o getAggregationBorderPoint pela vers√£o simplificada:
function getAggregationBorderPoint(agg, dx, dy) {
  // Simplesmente utilize a fun√ß√£o getDiamondBorderPoint que j√° funciona corretamente
  const half = (agg.size || relationshipSize)/2;
  return getDiamondBorderPoint(agg.x, agg.y, dx, dy, half);
}

function drawDeletionIconForConnection(context, r, conn) {
  // Calcule os pontos da polyline
  const rCenter = { x: r.x, y: r.y };
  const e = entities.find(en => en.id === conn.entityId);
  if (!e) return;
  const eCenter = { x: e.x + e.width / 2, y: e.y + e.height / 2 };
  let points = [rCenter];
  if (conn.breakpoints) {
    points.push(...conn.breakpoints);
  }
  points.push(eCenter);
  
  // Para posicionar o √≠cone, use uma fra√ß√£o do primeiro segmento (por exemplo, 35%)
  let fraction = 0.35;
  let start = points[0];
  let next = points[1]; // garante que h√° pelo menos dois pontos
  let iconPos = {
    x: start.x + (next.x - start.x) * fraction,
    y: start.y + (next.y - start.y) * fraction
  };

  let iconSize = globalIconSize + 4;
  
  // Desenha o √≠cone (X)
  context.save();
  context.fillStyle = "#b91c1c";
  context.beginPath();
  context.arc(iconPos.x, iconPos.y, iconSize / 2, 0, 2 * Math.PI);
  context.fill();
  context.strokeStyle = "#ffffff";
  context.lineWidth = 2;
  context.beginPath();
  context.moveTo(iconPos.x - iconSize/4, iconPos.y - iconSize/4);
  context.lineTo(iconPos.x + iconSize/4, iconPos.y + iconSize/4);
  context.moveTo(iconPos.x + iconSize/4, iconPos.y - iconSize/4);
  context.lineTo(iconPos.x - iconSize/4, iconPos.y + iconSize/4);
  context.stroke();
  context.restore();

  // Armazena a posi√ß√£o para detec√ß√£o de clique
  conn.iconRect = {
    x: iconPos.x - iconSize/2,
    y: iconPos.y - iconSize/2,
    width: iconSize,
    height: iconSize
  };
}


function drawDeletionIconForSpecConnection(context, spec, conn) {
  const vertex = getSpecializationVertices(spec)[conn.vertex];
  const e = entities.find(en => en.id === conn.entityId);
  if (!e) return;
  const eCenter = { x: e.x + e.width / 2, y: e.y + e.height / 2 };
  let points = [vertex];
  if (conn.breakpoints && conn.breakpoints.length > 0) {
    points.push(...conn.breakpoints);
  }
  let eBoundary = getRectBorderPoint(
    eCenter.x, eCenter.y,
    points[points.length - 1].x - eCenter.x,
    points[points.length - 1].y - eCenter.y,
    e.width / 2, e.height / 2
  );
  points.push(eBoundary);
  
  // Para especializa√ß√£o, use uma fra√ß√£o menor (por exemplo, 20%)
  let fraction = 0.2;
  let start = points[0];
  let next = points[1];
  let iconPos = {
    x: start.x + (next.x - start.x) * fraction,
    y: start.y + (next.y - start.y) * fraction
  };

  let iconSize = globalIconSize + 4;
  
  context.save();
  context.fillStyle = "#b91c1c";
  context.beginPath();
  context.arc(iconPos.x, iconPos.y, iconSize / 2, 0, 2 * Math.PI);
  context.fill();
  context.strokeStyle = "#ffffff";
  context.lineWidth = 2;
  context.beginPath();
  context.moveTo(iconPos.x - iconSize/4, iconPos.y - iconSize/4);
  context.lineTo(iconPos.x + iconSize/4, iconPos.y + iconSize/4);
  context.moveTo(iconPos.x + iconSize/4, iconPos.y - iconSize/4);
  context.lineTo(iconPos.x - iconSize/4, iconPos.y + iconSize/4);
  context.stroke();
  context.restore();

  conn.iconRect = {
    x: iconPos.x - iconSize/2,
    y: iconPos.y - iconSize/2,
    width: iconSize,
    height: iconSize
  };
}




function drawConnectionLine(context, r, conn, e) {
  // Pontos centrais
  const rCenter = { x: r.x, y: r.y };
  const eCenter = { x: e.x + e.width / 2, y: e.y + e.height / 2 };
  
  // Tamanho do losango (relacionamento)
  const half = (r.size || relationshipSize) / 2;
  
  // Determina para onde apontar a borda do relacionamento:
  // - Se houver breakpoints, aponta para o primeiro breakpoint
  // - Se n√£o houver, aponta para o centro da entidade
  let firstTarget = (conn.breakpoints && conn.breakpoints.length > 0) ? 
    conn.breakpoints[0] : eCenter;
  
  // Calcula o ponto na borda do relacionamento
  const rBorder = getDiamondBorderPointCorrect(r.x, r.y, firstTarget.x, firstTarget.y, half);
  
  // Determina de onde vem a linha para a entidade:
  // - Se houver breakpoints, vem do √∫ltimo breakpoint
  // - Se n√£o houver, vem da borda do relacionamento
  let lastSource = (conn.breakpoints && conn.breakpoints.length > 0) ?
    conn.breakpoints[conn.breakpoints.length - 1] : rBorder;
  
  // Calcula a dire√ß√£o do vetor para a borda da entidade
  const dx = lastSource.x - eCenter.x;
  const dy = lastSource.y - eCenter.y;
  
  // Calcula o ponto na borda da entidade
  const eBorder = getRectBorderPoint(
    eCenter.x, eCenter.y,
    dx, dy,
    e.width / 2, e.height / 2
  );
  
  // Montamos os pontos para a polyline
  let points = [rBorder];
  
  // Adicionamos os breakpoints se existirem
  if (conn.breakpoints && conn.breakpoints.length > 0) {
    points.push(...conn.breakpoints);
  }
  
  // Adicionamos o ponto na borda da entidade
  points.push(eBorder);
  
  // Desenho da polyline
  context.beginPath();
  context.moveTo(points[0].x, points[0].y);
  for (let i = 1; i < points.length; i++) {
    context.lineTo(points[i].x, points[i].y);
  }
  
  // Define a espessura base: se a conex√£o for marcada como weak (fraca), usa 6, sen√£o 2.
  let baseLineWidth = (conn.weak) ? 6 : 2;
  // Se a conex√£o estiver selecionada, adiciona 2 (ou outro valor) para evidenciar a sele√ß√£o.
  if (
    selectedConnection &&
    selectedConnection.relationshipId === r.id &&
    selectedConnection.entityId === conn.entityId
  ) {
    baseLineWidth += 2;
  }
  context.lineWidth = baseLineWidth;
  context.strokeStyle = "#000000";
  context.stroke();
  
  // Desenho dos breakpoints
  if (conn.breakpoints) {
    for (let bp of conn.breakpoints) {
      context.beginPath();
      context.arc(bp.x, bp.y, 5, 0, 2*Math.PI);
      context.fillStyle = "#000000";
      context.fill();
    }
  }
  
  // Desenha a cardinalidade
  // Calcular a posi√ß√£o e medir o texto
  let labelPos = getPolylineMidpoint(points);
  const text = conn.cardinality || "";
  const padding = 2;                // Espa√ßo extra em volta do texto
  context.font = `${fontSize}px Poppins`; 
  context.textAlign = "center";
  context.textBaseline = "middle";

  // Medidas do texto
  const textWidth = context.measureText(text).width + 10;
  const textHeight = fontSize; // ou fontSize * 1.2, se quiser extra

  // Para ficar circular, pegamos o maior entre (metade da largura) e (metade da altura)
  const radius = Math.max(textWidth / 2, textHeight / 2) + padding;

  // Vamos desenhar o texto "acima" da linha em Y-5
  const textCenterX = labelPos.x;
  const textCenterY = labelPos.y - 1;  // Ajuste vertical para ficar um pouco acima

  // 1) Desenha o c√≠rculo de fundo
  context.beginPath();
  context.arc(textCenterX, textCenterY, radius, 0, 2 * Math.PI);
  context.fillStyle = "#ffffff";  // Cor de fundo
  context.fill();
  
  // 2) Desenha o texto em cima do c√≠rculo
  context.fillStyle = "#000000";    // Cor do texto
  context.fillText(text, textCenterX, textCenterY);

  // 3)  Atualiza conn.labelRect, para clique:
  conn.labelRect = {
    x: textCenterX - radius,
    y: textCenterY - radius,
    width: radius * 2,
    height: radius * 2
  };
}



function drawSpecConnectionLine(context, spec, conn, e) {
  const vertex = getSpecializationVertices(spec)[conn.vertex];
  const eCenter = { x: e.x + e.width / 2, y: e.y + e.height / 2 };
  let points = [vertex];
  if (conn.breakpoints && conn.breakpoints.length > 0) {
    points.push(...conn.breakpoints);
  }
  let eBoundary = getRectBorderPoint(
    eCenter.x, eCenter.y, 
    points[points.length - 1].x - eCenter.x, 
    points[points.length - 1].y - eCenter.y, 
    e.width / 2, e.height / 2
  );
  points.push(eBoundary);

  // Desenho da polilinha
  context.beginPath();
  context.moveTo(points[0].x, points[0].y);
  for (let i = 1; i < points.length; i++) {
    context.lineTo(points[i].x, points[i].y);
  }
  context.lineWidth = (selectedSpecConnection &&
    selectedSpecConnection.specializationId === spec.id &&
    selectedSpecConnection.vertex === conn.vertex &&
    selectedSpecConnection.entityId === conn.entityId) ? 4 : 2;
  context.strokeStyle = "#000000";
  context.stroke();

  // Desenho dos breakpoints
  if (conn.breakpoints && conn.breakpoints.length > 0) {
    for (let bp of conn.breakpoints) {
      context.beginPath();
      context.arc(bp.x, bp.y, 5, 0, 2 * Math.PI);
      context.fillStyle = "#000000";
      context.fill();
    }
  }

  
}    


// 4. Fun√ß√£o drawPreview corrigida para centralizar TODOS os objetos corretamente
function drawPreview() {
  if (!draggingToolbarType || !draggingNewObj) return;
  
  ctx.save();
  ctx.globalAlpha = 0.7;
  
  // Pegar as coordenadas do centro
  const centerX = draggingNewObj.x;
  const centerY = draggingNewObj.y;
  
  switch(draggingToolbarType) {
    case "entity":
      // Centraliza o ret√¢ngulo nas coordenadas do mouse
      ctx.fillStyle = normalColors.entity.fill;
      ctx.strokeStyle = normalColors.entity.stroke;
      ctx.beginPath();
      ctx.roundRect(
        centerX - defaultEntityWidth/2,   // X ajustado para centralizar 
        centerY - defaultEntityHeight/2,  // Y ajustado para centralizar
        defaultEntityWidth, 
        defaultEntityHeight, 
        8
      );
      ctx.fill();
      ctx.stroke();
      break;
      
      case "attribute":
      // Novo preview para atributo simples
      ctx.fillStyle = "white";
      ctx.strokeStyle = normalColors.attribute.stroke;
      ctx.beginPath();
      ctx.arc(centerX, centerY, ATTR_CIRCLE_RADIUS, 0, 2 * Math.PI);
      ctx.fill();
      ctx.stroke();
      
      // Texto de exemplo
      ctx.fillStyle = "#000000";
      ctx.textAlign = "left";
      ctx.textBaseline = "middle";
      ctx.fillText("Atributo", centerX + ATTR_CIRCLE_RADIUS + ATTR_TEXT_PADDING, centerY + ATTR_TEXT_OFFSET_Y);
      break;
      
    case "derivedAttribute":
      // Novo preview para atributo derivado
      ctx.fillStyle = "white";
      ctx.strokeStyle = normalColors.derived.stroke;
      ctx.setLineDash([4, 2]);
      ctx.beginPath();
      ctx.arc(centerX, centerY, ATTR_CIRCLE_RADIUS, 0, 2 * Math.PI);
      ctx.fill();
      ctx.stroke();
      ctx.setLineDash([]);
      
      // Texto de exemplo
      ctx.fillStyle = "#000000";
      ctx.textAlign = "left";
      ctx.textBaseline = "middle";
      ctx.fillText("Derivado", centerX + ATTR_CIRCLE_RADIUS + ATTR_TEXT_PADDING, centerY + ATTR_TEXT_OFFSET_Y);
      break;
      
    case "multivaluedAttribute":
      // Novo preview para atributo multivalorado
      ctx.fillStyle = "white";
      ctx.strokeStyle = normalColors.multivalued.stroke;
      ctx.beginPath();
      ctx.arc(centerX, centerY, ATTR_CIRCLE_RADIUS, 0, 2 * Math.PI);
      ctx.fill();
      ctx.stroke();
      
      // C√≠rculo interno para multivalorado
      ctx.beginPath();
      ctx.arc(centerX, centerY, ATTR_CIRCLE_RADIUS * 0.7, 0, 2 * Math.PI);
      ctx.stroke();
      
      // Texto de exemplo
      ctx.fillStyle = "#000000";
      ctx.textAlign = "left";
      ctx.textBaseline = "middle";
      ctx.fillText("Multivaluado", centerX + ATTR_CIRCLE_RADIUS + ATTR_TEXT_PADDING, centerY + ATTR_TEXT_OFFSET_Y);
      break;
      
    case "relationship":
      // Para relacionamentos (losango)
      ctx.fillStyle = normalColors.relationship.fill;
      ctx.strokeStyle = normalColors.relationship.stroke;
      const half = relationshipSize/2;
      ctx.beginPath();
      ctx.moveTo(centerX, centerY - half);           // Topo
      ctx.lineTo(centerX + half, centerY);           // Direita
      ctx.lineTo(centerX, centerY + half);           // Baixo
      ctx.lineTo(centerX - half, centerY);           // Esquerda
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      break;
      
    case "specialization":
      // Para especializa√ß√µes (tri√¢ngulo)
      ctx.fillStyle = normalColors.specialization.fill;
      ctx.strokeStyle = normalColors.specialization.stroke;
      const vertices = getSpecializationVertices({ 
        x: centerX, 
        y: centerY, 
        size: defaultSpecializationSize 
      });
      ctx.beginPath();
      ctx.moveTo(vertices[0].x, vertices[0].y);
      ctx.lineTo(vertices[1].x, vertices[1].y);
      ctx.lineTo(vertices[2].x, vertices[2].y);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      break;
  
      // Adicione o caso para agrega√ß√£o
    case "aggregation":
      ctx.fillStyle = normalColors.aggregation.fill;
      ctx.strokeStyle = normalColors.aggregation.stroke;
      const half2 = relationshipSize/2;
      const rectSize = half2 * 1.2;
      
      // Ret√¢ngulo externo
      ctx.beginPath();
      ctx.rect(centerX - rectSize, centerY - rectSize, rectSize*2, rectSize*2);
      ctx.stroke();
      
      // Losango interno
      ctx.beginPath();
      ctx.moveTo(centerX, centerY - half2);
      ctx.lineTo(centerX + half2, centerY);
      ctx.lineTo(centerX, centerY + half2);
      ctx.lineTo(centerX - half2, centerY);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      break;
  }
  
  ctx.restore();
}




// 5. Atualiza√ß√£o da fun√ß√£o createObjectAt para garantir objetos centralizados
function createObjectAt(type, cx, cy) {
  if (type === "attribute" || type === "derivedAttribute" || type === "multivaluedAttribute") {
    const drop = getDraggableAt(cx, cy);
    if (!drop || (drop.type !== "entity" && drop.type !== "relationship" && 
                  drop.type !== "attribute" && drop.type !== "derivedAttribute" && 
                  drop.type !== "aggregation")) {
      alert("O atributo deve ser arrastado sobre uma entidade, relacionamento, outro atributo ou agrega√ß√£o.");
      cleanupToolbarDrag();
      draw();
      return;
    }
    
    
    // L√≥gica para atributos
    let parentObj = drop.element;
    let posX, posY;
    if (drop.type === "entity") {
      posX = parentObj.x + (parentObj.width || defaultEntityWidth) + 30;
      posY = parentObj.y + (parentObj.height || defaultEntityHeight)/2;
    } else if (drop.type === "relationship") {
      posX = parentObj.x + (parentObj.size || relationshipSize)/2 + 30;
      posY = parentObj.y;
    } else if (drop.type === "aggregation") {
      posX = parentObj.x + (parentObj.size || relationshipSize)/2 + 30;
      posY = parentObj.y;
    } else if (drop.type === "attribute" || drop.type === "derivedAttribute" || drop.type === "multivaluedAttribute") {
      posX = parentObj.x + 30;
      posY = parentObj.y;
    }
    
    // Criar o novo atributo
    const newA = {
      id: attributeIdCounter++,
      x: posX,
      y: posY,
      name: type === "derivedAttribute" ? "Deriv." : 
            (type === "multivaluedAttribute" ? "Multival." : "Simples"),
      parentType: drop.type === "derivedAttribute" || drop.type === "multivaluedAttribute" ? 
                  "attribute" : drop.type,
      parentId: parentObj.id,
      derived: (type === "derivedAttribute"),
      multivalued: (type === "multivaluedAttribute"),
      primary: false,
      selected: false,
      objType: "attribute",
      hitBox: {
        x: posX - ATTR_CIRCLE_RADIUS,
        y: posY - ATTR_CIRCLE_RADIUS,
        width: ATTR_CIRCLE_RADIUS * 2 + ATTR_TEXT_PADDING + 100, // Valor provis√≥rio para largura do texto
        height: ATTR_CIRCLE_RADIUS * 2
      }
    };
    attributes.push(newA);
    }  else if (type === "entity") {
    // Ajuste expl√≠cito para entidades
    const newE = {
      id: entityIdCounter++,
      x: cx - defaultEntityWidth/2,   // X ajustado para centralizar
      y: cy - defaultEntityHeight/2,  // Y ajustado para centralizar 
      width: defaultEntityWidth,
      height: defaultEntityHeight,
      name: "Entidade",
      selected: false,
      objType: "entity"
    };
    entities.push(newE);
  } else if (type === "relationship") {
    // Para relacionamentos, o centro j√° √© a posi√ß√£o do mouse
    const newR = {
      id: relationshipIdCounter++,
      x: cx,  // Posi√ß√£o do centro X
      y: cy,  // Posi√ß√£o do centro Y
      size: relationshipSize,
      name: "Rel.",
      connections: [],
      selected: false,
      objType: "relationship"
    };
    relationships.push(newR);
  } else if (type === "specialization") {
    // Para especializa√ß√µes, o centro tamb√©m j√° √© a posi√ß√£o do mouse
    const newS = {
      id: specializationIdCounter++,
      x: cx,  // Posi√ß√£o do centro X
      y: cy,  // Posi√ß√£o do centro Y
      size: defaultSpecializationSize,
      genType: "T,C",
      connections: [],
      selected: false,
      objType: "specialization"
    };
    specializations.push(newS);
  } else if (type === "aggregation") {
    const newAgg = {
      id: aggregationIdCounter++,
      x: cx,  // Posi√ß√£o do centro X
      y: cy,  // Posi√ß√£o do centro Y
      size: relationshipSize,
      name: "Agrega.",
      connections: [],
      selected: false,
      objType: "aggregation"
    };
    aggregations.push(newAgg);
  }
  
  saveState();
  cleanupToolbarDrag();
  draw();
}



    // Fun√ß√£o de desenho principal, agora aplicando a transforma√ß√£o de zoom
    function draw() {
      ctx.save();
      ctx.clearRect(0, 0, mainWidth, mainHeight);

      // Aplica as transforma√ß√µes na ordem correta
      ctx.translate(panOffset.x * zoom, panOffset.y * zoom);
      ctx.scale(zoom, zoom);

      drawAll(ctx);
      if (draggingToolbarType && draggingNewObj) {
        drawPreview();
      }

      
      if (isDraggingConnection && draggingConnection) {
        ctx.save();
        ctx.setLineDash([5,3]);
        ctx.strokeStyle = "#000000";
        ctx.beginPath();
        
        // Calcula o ponto de partida da linha de preview conforme a borda do objeto de origem
        let startPoint = { x: draggingConnection.start.x, y: draggingConnection.start.y };
        const currentPos = draggingConnection.current;
        const obj = draggingConnection.element;
        
        if (obj.objType === "entity") {
          let center = { x: obj.x + (obj.width || defaultEntityWidth)/2, y: obj.y + (obj.height || defaultEntityHeight)/2 };
          let dx = currentPos.x - center.x;
          let dy = currentPos.y - center.y;
          startPoint = getRectBorderPoint(center.x, center.y, dx, dy, obj.width/2, obj.height/2);
        } else if (obj.objType === "relationship") {
          let center = { x: obj.x, y: obj.y };
          startPoint = getDiamondBorderPointCorrect(center.x, center.y, currentPos.x, currentPos.y, obj.size);
        } else if (obj.objType === "specialization") {
          startPoint = getTriangleBorderPoint(obj, currentPos);
        } else if (obj.objType === "aggregation") {
          let center = { x: obj.x, y: obj.y };
          let dx = currentPos.x - center.x;
          let dy = currentPos.y - center.y;
          const half = (obj.size || relationshipSize) / 2;
          const rectSize = half * 1.2; // mesmo fator usado para desenhar a agrega√ß√£o
          startPoint = getRectBorderPoint(center.x, center.y, dx, dy, rectSize, rectSize);
        }
        
        ctx.moveTo(startPoint.x, startPoint.y);
        ctx.lineTo(currentPos.x, currentPos.y);
        ctx.stroke();
        ctx.restore();
      }

      ctx.restore();
    }

    // Fun√ß√£o clearSelection
    function clearSelection() {
      entities.forEach(e => e.selected = false);
      attributes.forEach(a => a.selected = false);
      relationships.forEach(r => r.selected = false);
      specializations.forEach(s => s.selected = false);
      aggregations.forEach(a => a.selected = false);
      
      selectedConnection = null;
      selectedSpecConnection = null;
      selectedAggregationConnection = null;

    }

    function checkResizeHandles(x, y) {
    let found = null;
    [...entities, ...attributes, ...relationships, ...specializations, ...aggregations].forEach(el => {
      if (el.selected && el.resizeHandles) {
        el.resizeHandles.forEach((handle, idx) => {
          if (isInsideRect({x,y}, handle)) {
            found = { type: "resize", element: el, handleIndex: idx };
          }
        });
      }
    });
    return found;
  }

    
    function getDraggableAt(x, y)
    {
        if (submenu && isInsideRect({ x, y }, submenuRect)) return { type: "submenu" };

        let resizeHit = checkResizeHandles(x, y);
        if (resizeHit) return resizeHit;

        // Verifica entidades
        for (let i = entities.length - 1; i >= 0; i--) {
          const e = entities[i];
          let w = e.width || defaultEntityWidth, h = e.height || defaultEntityHeight;
          if (x >= e.x && x <= e.x + w && y >= e.y && y <= e.y + h) {
            return { type: "entity", element: e };
          }
        }

        // Verifica atributos - Agora usando a hitBox para detec√ß√£o de cliques
        for (let i = attributes.length - 1; i >= 0; i--) {
          const a = attributes[i];
          if (a.hitBox && isInsideRect({x, y}, a.hitBox)) {
            // Retorna o tipo correto baseado nas propriedades do atributo
            if (a.derived) {
              return { type: "derivedAttribute", element: a };
            } else if (a.multivalued) {
              return { type: "multivaluedAttribute", element: a };
            } else {
              return { type: "attribute", element: a };
            }
          }
        }

        // Verifica relacionamentos
        for (let i = relationships.length - 1; i >= 0; i--) {
          const rel = relationships[i];
          let half = (rel.size || relationshipSize) / 2;
          if (x >= rel.x - half && x <= rel.x + half && y >= rel.y - half && y <= rel.y + half) {
            return { type: "relationship", element: rel };
          }
        }


        // Verifica agrega√ß√µes
        for (let i = aggregations.length - 1; i >= 0; i--) {
          const agg = aggregations[i];
          const half = (agg.size || relationshipSize) / 2;
          const rectSize = half * 1.2;
          
          // Forma mais precisa para verificar o ret√¢ngulo da agrega√ß√£o
          if (x >= agg.x - rectSize && x <= agg.x + rectSize &&
              y >= agg.y - rectSize && y <= agg.y + rectSize) {
            return { type: "aggregation", element: agg };
          }
        }
        
        
        // Verifica conex√µes de agrega√ß√µes
        for (let agg of aggregations) {
          if (agg.connections) {
            for (let conn of agg.connections) {
              let target;
              if (conn.entityId) {
                target = entities.find(e => e.id === conn.entityId);
              } else if (conn.relationshipId) {
                target = relationships.find(r => r.id === conn.relationshipId);
              }
              
              if (target) {
                let aggCenter = { x: agg.x, y: agg.y };
                let targetCenter;
                
                if (conn.entityId) {
                  targetCenter = { 
                    x: target.x + (target.width || defaultEntityWidth)/2, 
                    y: target.y + (target.height || defaultEntityHeight)/2 
                  };
                } else {
                  targetCenter = { x: target.x, y: target.y };
                }
                
                let points = [aggCenter];
                if (conn.breakpoints && conn.breakpoints.length > 0) {
                  points.push(...conn.breakpoints);
                }
                points.push(targetCenter);
                
                // Verifica se clicou na linha de conex√£o
                for (let i = 0; i < points.length - 1; i++) {
                  if (distancePointToSegment({ x, y }, points[i], points[i + 1]) < 15) {
                    return { 
                      type: "aggregation-connection", 
                      aggregation: agg, 
                      connection: conn 
                    };
                  }
                }
                
                // ... c√≥digo existente para breakpoints ...
              }
            }
          }
        }

        // Verifica especializa√ß√µes
        for (let i = specializations.length - 1; i >= 0; i--) {
          const spec = specializations[i];
          let half = (spec.size || defaultSpecializationSize) / 2;
          if (x >= spec.x - half && x <= spec.x + half && y >= spec.y - half && y <= spec.y + half) {
            return { type: "specialization", element: spec };
          }
        }

        

        // Verifica conex√µes de especializa√ß√£o
        for (let s of specializations) {
          if (s.connections) {
            for (let conn of s.connections) {
              let e = entities.find(en => en.id === conn.entityId);
              if (!e) continue;
              let vertex = getSpecializationVertices(s)[conn.vertex];
              let eCenter = { x: e.x + e.width / 2, y: e.y + e.height / 2 };
              let points = [vertex];
              if (conn.breakpoints && conn.breakpoints.length > 0) {
                points.push(...conn.breakpoints);
              }
              let lastPoint = points[points.length - 1];
              let eBoundary = getRectBorderPoint(
                eCenter.x, eCenter.y, 
                lastPoint.x - eCenter.x, 
                lastPoint.y - eCenter.y, 
                e.width / 2, e.height / 2
              );
              points.push(eBoundary);
              for (let i = 0; i < points.length - 1; i++) {
                if (distancePointToSegment({ x, y }, points[i], points[i + 1]) < 15) {
                  return { type: "specialization-connection", specialization: s, connection: conn };
                }
              }
            }
          }
        }

        // Verifica conex√µes entre relacionamentos e entidades
        for (let r of relationships) {
          for (let conn of r.connections) {
            let e = entities.find(en => en.id === conn.entityId);
            if (!e) continue;
            let rCenter = { x: r.x, y: r.y };
            let eCenter = { x: e.x + e.width / 2, y: e.y + e.height / 2 };
            let points = [rCenter];
            if (conn.breakpoints && conn.breakpoints.length > 0) {
              points.push(...conn.breakpoints);
            }
            let eBoundary = getRectBorderPoint(
              eCenter.x, eCenter.y, 
              points[points.length - 1].x - eCenter.x, 
              points[points.length - 1].y - eCenter.y, 
              e.width / 2, e.height / 2
            );
            points.push(eBoundary);
            for (let i = 0; i < points.length - 1; i++) {
              if (distancePointToSegment({ x, y }, points[i], points[i + 1]) < 15) {
                return { type: "connection", relationship: r, connection: conn };
              }
            }
          }
        }

        // Verifica breakpoints nas conex√µes de especializa√ß√£o
        for (let s of specializations) {
          if (s.connections) {
            for (let conn of s.connections) {
              if (conn.breakpoints && conn.breakpoints.length > 0) {
                for (let i = 0; i < conn.breakpoints.length; i++) {
                  let bp = conn.breakpoints[i];
                  if (Math.hypot(x - bp.x, y - bp.y) < 8) {
                    return { type: "breakpoint", connection: conn, index: i, specialization: s };
                  }
                }
              }
            }
          }
        }

        // Verifica breakpoints nas conex√µes de relacionamento
        for (let r of relationships) {
          for (let conn of r.connections) {
            if (conn.breakpoints && conn.breakpoints.length > 0) {
              for (let i = 0; i < conn.breakpoints.length; i++) {
                let bp = conn.breakpoints[i];
                if (Math.hypot(x - bp.x, y - bp.y) < 8) {
                  return { type: "breakpoint", connection: conn, index: i, relationship: r };
                }
              }
            }
          }
        }


        // Verifica breakpoints nas conex√µes de agrega√ß√µes
        for (let agg of aggregations) {
          if (agg.connections) {
            for (let conn of agg.connections) {
              if (conn.breakpoints && conn.breakpoints.length > 0) {
                for (let i = 0; i < conn.breakpoints.length; i++) {
                  let bp = conn.breakpoints[i];
                  if (Math.hypot(x - bp.x, y - bp.y) < 8) {
                    return { 
                      type: "breakpoint", 
                      connection: conn, 
                      index: i, 
                      aggregation: agg 
                    };
                  }
                }
              }
              
              // Tamb√©m verifica a linha da conex√£o
              let target;
              if (conn.entityId) {
                target = entities.find(e => e.id === conn.entityId);
              } else if (conn.relationshipId) {
                target = relationships.find(r => r.id === conn.relationshipId);
              }
              
              if (target) {
                let aggCenter = { x: agg.x, y: agg.y };
                let targetCenter;
                
                if (conn.entityId) {
                  targetCenter = { 
                    x: target.x + (target.width || defaultEntityWidth)/2, 
                    y: target.y + (target.height || defaultEntityHeight)/2 
                  };
                } else {
                  targetCenter = { x: target.x, y: target.y };
                }
                
                let points = [aggCenter];
                if (conn.breakpoints && conn.breakpoints.length > 0) {
                  points.push(...conn.breakpoints);
                }
                points.push(targetCenter);
                
                for (let i = 0; i < points.length - 1; i++) {
                  if (distancePointToSegment({ x, y }, points[i], points[i + 1]) < 15) {
                    return { 
                      type: "aggregation-connection", 
                      aggregation: agg, 
                      connection: conn 
                    };
                  }
                }
              }
            }
          }
        }

        

        return null;
    }










function startToolbarDrag(type, evt) {
  evt.preventDefault();
  toolbarDrag = {
    type: type,
    startX: evt.pageX,
    startY: evt.pageY,
    isDragging: false
  };
  $(document).on("mousemove.toolbarDrag", onToolbarDragMove);
  $(document).on("mouseup.toolbarDrag", onToolbarDragEnd);
}
    
function onToolbarDragMove(evt) {
  if (!toolbarDrag) return;
  
  const dx = evt.pageX - toolbarDrag.startX;
  const dy = evt.pageY - toolbarDrag.startY;
  const distance = Math.sqrt(dx*dx + dy*dy);
  const rect = canvas.getBoundingClientRect();
  
  // Coordenadas em rela√ß√£o ao canvas, independentemente do zoom ou pan offset
  const canvasX = (evt.pageX - rect.left) / zoom - panOffset.x;
  const canvasY = (evt.pageY - rect.top) / zoom - panOffset.y;
  
  if (!toolbarDrag.isDragging && distance > 5) {
    toolbarDrag.isDragging = true;
    draggingToolbarType = toolbarDrag.type;
    
    // Inicializa o objeto de preview centralizado no mouse
    draggingNewObj = {
      type: toolbarDrag.type,
      x: canvasX,  // Coordenada j√° ajustada para o pan/zoom
      y: canvasY   // Coordenada j√° ajustada para o pan/zoom
    };
  } else if (toolbarDrag.isDragging) {
    // Atualiza a posi√ß√£o do objeto enquanto arrasta, mantendo centralizado
    draggingNewObj.x = canvasX;
    draggingNewObj.y = canvasY;
  }
  
  draw();
}


function onToolbarDragEnd(evt) {
  if (!toolbarDrag) return;
  
  $(document).off("mousemove.toolbarDrag");
  $(document).off("mouseup.toolbarDrag");
  
  const rect = canvas.getBoundingClientRect();
  const canvasX = (evt.pageX - rect.left) / zoom - panOffset.x;
  const canvasY = (evt.pageY - rect.top) / zoom - panOffset.y;
  
  // Verifica se est√° dentro do canvas
  const viewportX = evt.pageX - rect.left;
  const viewportY = evt.pageY - rect.top;
  const isInsideCanvas = viewportX >= 0 && viewportX <= rect.width && 
                        viewportY >= 0 && viewportY <= rect.height;
  
  if (toolbarDrag.isDragging) {
    if (isInsideCanvas) {
      createObjectAt(toolbarDrag.type, canvasX, canvasY);
    }
    cleanupToolbarDrag();
  } else {
    draggingToolbarType = toolbarDrag.type;
    clickPlacementMode = true;
    if (isInsideCanvas) {
      draggingNewObj = { 
        type: toolbarDrag.type, 
        x: canvasX, 
        y: canvasY 
      };
    }
  }
  
  toolbarDrag = null;
  draw();
}

    function cleanupToolbarDrag() {
      draggingToolbarType = null;
      draggingNewObj = null;
      clickPlacementMode = false;
      toolbarDrag = null;
    }

    
function onCanvasStart(evt) {
  // Fechar o submenu se estiver aberto
  if (submenu) {
    $(submenu).remove();
    submenu = null;
    submenuRect = null;
    
    // Remove o manipulador de eventos
    if (currentSubmenuCloseHandler) {
      document.removeEventListener('click', currentSubmenuCloseHandler);
      currentSubmenuCloseHandler = null;
    }
  }

  evt.preventDefault();
  let pos = getMousePos(evt);

  if (selectedConnection && selectedConnection.iconRect && 
      isInsideRect(pos, selectedConnection.iconRect)) {
    return;
  }

  let hit = getDraggableAt(pos.x, pos.y);

  

  if (hit && hit.type === "resize") {
    isResizing = true;
    resizingObject = hit.element;
    resizeHandleIndex = hit.handleIndex;
    if (resizingObject.objType === "entity") {
      resizingInitial = {
        x: resizingObject.x,
        y: resizingObject.y,
        width: resizingObject.width,
        height: resizingObject.height
      };
    } else if (resizingObject.objType === "attribute" || 
              resizingObject.objType === "derivedAttribute" || 
              resizingObject.objType === "multivaluedAttribute") {
      resizingInitial = {
        x: resizingObject.x,
        y: resizingObject.y,
        ratio: (resizingObject.radiusY || defaultAttributeRadiusY) / (resizingObject.radiusX || defaultAttributeRadiusX)
      };
    } else if (resizingObject.objType === "relationship") {
      resizingInitial = {
        x: resizingObject.x,
        y: resizingObject.y,
        size: resizingObject.size
      };
    } else if (resizingObject.objType === "specialization") {
      resizingInitial = {
        x: resizingObject.x,
        y: resizingObject.y,
        size: resizingObject.size
      };
    } else if (resizingObject.objType === "aggregation") {
      // Inicialize dados para redimensionamento de agrega√ß√£o
      resizingInitial = {
        x: resizingObject.x,
        y: resizingObject.y,
        size: resizingObject.size
      };
    }
    
    if (!resizingObject.selected) {
      clearSelection();
      resizingObject.selected = true;
    }
    return;
  }

  if (hit && hit.type === "breakpoint") {
    isDraggingBreakpoint = true;
    activeBreakpoint = { 
      connection: hit.connection, 
      index: hit.index,
      specialization: hit.specialization || null,
      relationship: hit.relationship || null
    };
    return;
  }

  if (isSpacePressed) {
    isPanning = true;
    panStart = { x: evt.clientX, y: evt.clientY };
    panOffsetStart = { x: panOffset.x, y: panOffset.y };
    return;
  }
  if (clickPlacementMode) {
    createObjectAt(draggingToolbarType, pos.x, pos.y);
    cleanupToolbarDrag();
    draw();
    return;
  }
  if (draggingToolbarType) return;

  if (hit && hit.type === "connection") {
    pendingConnectionHit = { ...hit, startX: pos.x, startY: pos.y };
    breakpointTimeout = setTimeout(() => {
      isDraggingBreakpoint = true;
      pendingConnectionHit = null;
      if (!hit.connection.breakpoints) {
        hit.connection.breakpoints = [];
      }
      if (hit.connection.breakpoints.length === 0) {
        hit.connection.breakpoints.push({ x: pos.x, y: pos.y });
      }
      activeBreakpoint = { 
        connection: hit.connection, 
        index: 0,
        relationship: hit.relationship
      };
      clearSelection();
      draw();
    }, 300);
  }

  if (hit && hit.type === "specialization-connection") {
    pendingConnectionHit = { ...hit, startX: pos.x, startY: pos.y };
    breakpointTimeout = setTimeout(() => {
      isDraggingBreakpoint = true;
      pendingConnectionHit = null;
      if (!hit.connection.breakpoints) {
        hit.connection.breakpoints = [];
      }
      if (hit.connection.breakpoints.length === 0) {
        hit.connection.breakpoints.push({ x: pos.x, y: pos.y });
      }
      activeBreakpoint = { 
        connection: hit.connection, 
        index: 0, 
        specialization: hit.specialization 
      };
      clearSelection();
      draw();
    }, 300);
  }

  if (hit && hit.type === "specialization-connection" && selectedSpecConnection && 
      selectedSpecConnection.iconRect && isInsideRect(pos, selectedSpecConnection.iconRect)) {
    const s = specializations.find(s => s.id === selectedSpecConnection.specializationId);
    if (s) {
      s.connections = s.connections.filter(c => c.entityId !== selectedSpecConnection.entityId || 
                                        c.vertex !== selectedSpecConnection.vertex);
      saveState();
      clearSelection();
      draw();
    }
    return;
  }

  if (hit && hit.type === "aggregation-connection") {
    // Armazenamos as informa√ß√µes do hit para uso posterior
    pendingConnectionHit = { ...hit, startX: pos.x, startY: pos.y };
    
    // Configuramos um timer para detectar um clique longo (para breakpoints)
    breakpointTimeout = setTimeout(() => {
      isDraggingBreakpoint = true;
      pendingConnectionHit = null;
      if (!hit.connection.breakpoints) {
        hit.connection.breakpoints = [];
      }
      if (hit.connection.breakpoints.length === 0) {
        hit.connection.breakpoints.push({ x: pos.x, y: pos.y });
      }
      activeBreakpoint = { 
        connection: hit.connection, 
        index: 0,
        aggregation: hit.aggregation 
      };
      clearSelection();
      draw();
    }, 300);
    
    
  }

  if (hit) {
    switch(hit.type) {
      case "specialization-connection":
        clearSelection();
        selectedSpecConnection = {
          specializationId: hit.specialization.id,
          entityId: hit.connection.entityId,
          vertex: hit.connection.vertex,
          iconRect: null
        };
        draw();
        return;
      case "connection":
        clearSelection();
        selectedConnection = {
          relationshipId: hit.relationship.id,
          entityId: hit.connection.entityId,
          iconRect: null
        };
        draw();
        return;
      case "aggregation-connection":
        clearSelection();
        selectedAggregationConnection = {
          aggregationId: hit.aggregation.id,
          entityId: hit.connection.entityId,
          relationshipId: hit.connection.relationshipId,
          iconRect: null
        };
        draw();
        return;
      case "entity":
      case "attribute":
      case "derivedAttribute":
      case "multivaluedAttribute":
      case "relationship":
      case "specialization":
      case "aggregation":
        // Esta √© a mudan√ßa principal: verificar se Ctrl est√° pressionado
        if (isCtrlPressed) {
          // Alterna a sele√ß√£o do objeto clicado sem afetar outros
          hit.element.selected = !hit.element.selected;
        } else if (!hit.element.selected) {
          // Comportamento padr√£o quando Ctrl n√£o est√° pressionado
          clearSelection();
          hit.element.selected = true;
        }
        let selectedObjects = [...entities, ...attributes, ...relationships, ...specializations, ...aggregations].filter(obj => obj.selected);
        if (selectedObjects.length > 1) {
          isDraggingGroup = true;
          groupMouseStart = pos;
          groupDragData = selectedObjects.map(obj => ({
            obj: obj,
            startX: obj.x,
            startY: obj.y
          }));
          groupBreakpointsData = [];
           // Coleta breakpoints de relacionamentos
          relationships.forEach(r => {
            if (r.selected && r.connections) {
              r.connections.forEach(conn => {
                if (conn.breakpoints) {
                  conn.breakpoints.forEach(bp => {
                    groupBreakpointsData.push({
                      breakpoint: bp,
                      startX: bp.x,
                      startY: bp.y
                    });
                  });
                }
              });
            } else {
              r.connections.forEach(conn => {
                let ent = entities.find(e => e.id === conn.entityId);
                if (ent && ent.selected && conn.breakpoints) {
                  conn.breakpoints.forEach(bp => {
                    groupBreakpointsData.push({
                      breakpoint: bp,
                      startX: bp.x,
                      startY: bp.y
                    });
                  });
                }
              });
            }
          });

          // Coleta breakpoints de especializa√ß√µes ‚Äì fora do loop de relacionamentos!
          specializations.forEach(s => {
            if (s.selected && s.connections) {
              s.connections.forEach(conn => {
                if (conn.breakpoints) {
                  conn.breakpoints.forEach(bp => {
                    groupBreakpointsData.push({
                      breakpoint: bp,
                      startX: bp.x,
                      startY: bp.y
                    });
                  });
                }
              });
            } else if (s.connections) {
              s.connections.forEach(conn => {
                let ent = entities.find(e => e.id === conn.entityId);
                if (ent && ent.selected && conn.breakpoints) {
                  conn.breakpoints.forEach(bp => {
                    groupBreakpointsData.push({
                      breakpoint: bp,
                      startX: bp.x,
                      startY: bp.y
                    });
                  });
                }
              });
            }
          });

          // Adicionar coleta de breakpoints para agrega√ß√µes
          aggregations.forEach(agg => {
            if (agg.selected && agg.connections) {
              agg.connections.forEach(conn => {
                if (conn.breakpoints) {
                  conn.breakpoints.forEach(bp => {
                    groupBreakpointsData.push({
                      breakpoint: bp,
                      startX: bp.x,
                      startY: bp.y
                    });
                  });
                }
              });
            } else if (agg.connections) {
              agg.connections.forEach(conn => {
                let connObj;
                if (conn.entityId) {
                  connObj = entities.find(e => e.id === conn.entityId);
                } else if (conn.relationshipId) {
                  connObj = relationships.find(r => r.id === conn.relationshipId);
                }
                
                if (connObj && connObj.selected && conn.breakpoints) {
                  conn.breakpoints.forEach(bp => {
                    groupBreakpointsData.push({
                      breakpoint: bp,
                      startX: bp.x,
                      startY: bp.y
                    });
                  });
                }
              });
            }
          });
        } else {
          isDraggingObject = true;
          dragObject = hit.element;
          dragOffset = { x: pos.x - hit.element.x, y: pos.y - hit.element.y };
          submenuTimeout = setTimeout(() => {
            if (!isDraggingObject && !isDraggingGroup) {
              showSubmenu(hit.element, pos.x, pos.y);
            }
          }, 100);
        }
        $(canvas).on("mousemove.drag", onCanvasMove);
        $(canvas).on("mouseup.drag", () => {
          $(canvas).off("mousemove.drag");
          $(canvas).off("mouseup.drag");
          onCanvasEnd(evt);
        });
        draw();
        return;
    }
  } else {
    if (!isCtrlPressed) {
      clearSelection();
    }
    isSelecting = true;
    selectionStart = pos;
    selectionRect = { x: pos.x, y: pos.y, width: 0, height: 0 };
  }
}

    function distanceBetween(a, b) {
      return Math.hypot(b.x - a.x, b.y - a.y);
    }

    function getPolylineMidpoint(points) {
      // 1) Calcula o comprimento total
      let totalLen = 0;
      for (let i = 0; i < points.length - 1; i++) {
        totalLen += distanceBetween(points[i], points[i+1]);
      }
      let half = totalLen / 2;

      // 2) Percorre os segmentos at√© achar a metade
      let accum = 0;
      for (let i = 0; i < points.length - 1; i++) {
        let segLen = distanceBetween(points[i], points[i+1]);
        if (accum + segLen >= half) {
          // Achamos o segmento onde fica o meio
          let rest = half - accum;   // quanto falta pra chegar na metade
          let ratio = rest / segLen; // fra√ß√£o do segmento
          return {
            x: points[i].x + ratio * (points[i+1].x - points[i].x),
            y: points[i].y + ratio * (points[i+1].y - points[i].y)
          };
        }
        accum += segLen;
      }

      // Caso n√£o encontre (por arredondamento?), retorna √∫ltimo ponto
      return points[points.length - 1];
    }


   
    function onCanvasMove(evt) {
      evt.preventDefault();
      let pos = getMousePos(evt);
      lastMousePos = pos;

      // Se estiver arrastando um breakpoint, atualiza sua posi√ß√£o
      if (isDraggingBreakpoint && activeBreakpoint) {
        activeBreakpoint.connection.breakpoints[activeBreakpoint.index] = { x: pos.x, y: pos.y };
        draw();
        return;
      }

      if (pendingConnectionHit) {
        let dx = pos.x - pendingConnectionHit.startX;
        let dy = pos.y - pendingConnectionHit.startY;
        if (Math.hypot(dx, dy) > 5) {
          // Cancela clique curto
          clearTimeout(breakpointTimeout);
          breakpointTimeout = null;

          // Cria ou usa o breakpoint existente
          isDraggingBreakpoint = true;
          if (!pendingConnectionHit.connection.breakpoints) {
            pendingConnectionHit.connection.breakpoints = [];
          }

          if (pendingConnectionHit.connection.breakpoints.length === 0) {
            // Se n√£o existir, cria
            pendingConnectionHit.connection.breakpoints.push({ x: pos.x, y: pos.y });
          }
          // Se j√° existir, n√£o criamos outro
          activeBreakpoint = { 
            connection: pendingConnectionHit.connection, 
            index: 0,
            specialization: pendingConnectionHit.specialization // Inclui a especializa√ß√£o se existir
          };

          pendingConnectionHit = null;
          clearSelection();
          draw();
          return;
        }
      }

      if (isPanning) {
        panOffset.x = panOffsetStart.x + (evt.clientX - panStart.x) / zoom;
        panOffset.y = panOffsetStart.y + (evt.clientY - panStart.y) / zoom;
        draw();
        return;
      }
      if (clickPlacementMode) {
        draggingNewObj = { type: draggingToolbarType, x: pos.x, y: pos.y };
        draw();
        return;
      }
      if (draggingToolbarType) return;

      if (isResizing && resizingObject) {
        if (resizingObject.objType === "entity") {
          let init = resizingInitial;
          if (resizeHandleIndex === 0) {
            let newX = pos.x;
            let newY = pos.y;
            let newWidth = (init.x + init.width) - newX;
            let newHeight = (init.y + init.height) - newY;
            if (newWidth < 40) { newWidth = 40; newX = init.x + init.width - 40; }
            if (newHeight < 30) { newHeight = 30; newY = init.y + init.height - 30; }
            resizingObject.x = newX;
            resizingObject.y = newY;
            resizingObject.width = newWidth;
            resizingObject.height = newHeight;
          } else if (resizeHandleIndex === 1) {
            let newY = pos.y;
            let newWidth = pos.x - init.x;
            let newHeight = (init.y + init.height) - newY;
            if (newWidth < 40) newWidth = 40;
            if (newHeight < 30) { newHeight = 30; newY = init.y + init.height - 30; }
            resizingObject.y = newY;
            resizingObject.width = newWidth;
            resizingObject.height = newHeight;
          } else if (resizeHandleIndex === 2) {
            let newX = pos.x;
            let newWidth = (init.x + init.width) - newX;
            let newHeight = pos.y - init.y;
            if (newWidth < 40) { newWidth = 40; newX = init.x + init.width - 40; }
            if (newHeight < 30) newHeight = 30;
            resizingObject.x = newX;
            resizingObject.width = newWidth;
            resizingObject.height = newHeight;
          } else if (resizeHandleIndex === 3) {
            let newWidth = pos.x - init.x;
            let newHeight = pos.y - init.y;
            if (newWidth < 40) newWidth = 40;
            if (newHeight < 30) newHeight = 30;
            resizingObject.width = newWidth;
            resizingObject.height = newHeight;
          }
        } else if (resizingObject.objType === "attribute" || 
             resizingObject.objType === "derivedAttribute" || 
             resizingObject.objType === "multivaluedAttribute") {
          if (resizeHandleIndex === 0 || resizeHandleIndex === 1) {
            let newRadiusX = Math.abs(pos.x - resizingObject.x);
            let newRadiusY = newRadiusX * resizingInitial.ratio;
            if (newRadiusX < 20) {
              newRadiusX = 20;
              newRadiusY = newRadiusX * resizingInitial.ratio;
            }
            resizingObject.radiusX = newRadiusX;
            resizingObject.radiusY = newRadiusY;
          } else if (resizeHandleIndex === 2 || resizeHandleIndex === 3) {
            let newRadiusY = Math.abs(pos.y - resizingObject.y);
            let newRadiusX = newRadiusY / resizingInitial.ratio;
            if (newRadiusY < 10) {
              newRadiusY = 10;
              newRadiusX = newRadiusY / resizingInitial.ratio;
            }
            resizingObject.radiusX = newRadiusX;
            resizingObject.radiusY = newRadiusY;
          }
        } else if (resizingObject.objType === "relationship") {
          let newSize = 2 * Math.max(Math.abs(pos.x - resizingObject.x), Math.abs(pos.y - resizingObject.y));
          if (newSize < 40) newSize = 40;
          resizingObject.size = newSize;
        } else if (resizingObject.objType === "specialization") {
          let newSize = Math.abs(pos.y - resizingObject.y) * (2 / (Math.sqrt(3)/3));
          if (newSize < 40) newSize = 40;
          resizingObject.size = newSize;
        } else if (resizingObject.objType === "aggregation") {
          let newSize = 2 * Math.max(Math.abs(pos.x - resizingObject.x), Math.abs(pos.y - resizingObject.y));
          if (newSize < 40) newSize = 40;
          resizingObject.size = newSize;
        }
        draw();
        return;
      }

      if (isSelecting) {
        selectionRect.x = Math.min(selectionStart.x, pos.x);
        selectionRect.y = Math.min(selectionStart.y, pos.y);
        selectionRect.width = Math.abs(pos.x - selectionStart.x);
        selectionRect.height = Math.abs(pos.y - selectionStart.y);
        draw();
        return;
      }
      // Melhoria no arrastamento de grupos
      if (isDraggingGroup) {
        let dx = pos.x - groupMouseStart.x;
        let dy = pos.y - groupMouseStart.y;
        
        // Atualiza posi√ß√£o de cada objeto
        groupDragData.forEach(item => {
          item.obj.x = item.startX + dx;
          item.obj.y = item.startY + dy;
        });

        // Atualiza posi√ß√£o de cada breakpoint que estiver no "groupBreakpointsData"
        groupBreakpointsData.forEach(bpd => {
          bpd.breakpoint.x = bpd.startX + dx;
          bpd.breakpoint.y = bpd.startY + dy;
        });
        
        draw();
        return;
      }
      if (isDraggingObject && dragObject) {
        dragObject.x = pos.x - dragOffset.x;
        dragObject.y = pos.y - dragOffset.y;
        draw();
        return;
      }
      
      if (isDraggingConnection && draggingConnection) {
        // Se estamos no modo de clique, atualiza apenas o cursor sem desenhar a linha
        if (!relationClickMode) {
          draggingConnection.current = pos;
          draw();
        } else {
          // No modo de clique, apenas atualiza a posi√ß√£o do cursor sem redesenhar
          // constantemente, para evitar flickering
          draggingConnection.current = pos;
          
          // Opcional: voc√™ pode atualizar o cursor para indicar modo de conex√£o
          canvas.style.cursor = "crosshair";
        }
        return;
      }
    }




    // Corre√ß√£o para fun√ß√£o onCanvasEnd() - Parte respons√°vel pela sele√ß√£o de m√∫ltiplos objetos
function onCanvasEnd(evt) {
  evt.preventDefault();
  let pos = getMousePos(evt);

  // Se estava arrastando um breakpoint, finaliza o arraste
  if (isDraggingBreakpoint) {
    isDraggingBreakpoint = false;
    activeBreakpoint = null;
    saveState();
    draw();
    return;
  }

  // Processamento do pendingConnectionHit - para selecionar conex√µes com clique
  if (pendingConnectionHit) {
    clearTimeout(breakpointTimeout);
    breakpointTimeout = null;
    
    if (pendingConnectionHit.type === "specialization-connection") {
      selectedSpecConnection = {
        specializationId: pendingConnectionHit.specialization.id,
        entityId: pendingConnectionHit.connection.entityId,
        vertex: pendingConnectionHit.connection.vertex,
        iconRect: null
      };
    } else if (pendingConnectionHit.type === "connection") {
      selectedConnection = {
        relationshipId: pendingConnectionHit.relationship.id,
        entityId: pendingConnectionHit.connection.entityId,
        iconRect: null
      };
      
    } else if (pendingConnectionHit.type === "aggregation-connection") {
      // Adicione aqui a sele√ß√£o da conex√£o de agrega√ß√£o
      selectedAggregationConnection = {
        aggregationId: pendingConnectionHit.aggregation.id,
        entityId: pendingConnectionHit.connection.entityId,
        relationshipId: pendingConnectionHit.connection.relationshipId,
        iconRect: null
      };
      
    }
    
    pendingConnectionHit = null;
    draw();
    return;
  }

  if (isPanning) {
    isPanning = false;
    return;
  }
  
  if (clickPlacementMode) {
    createObjectAt(draggingToolbarType, pos.x, pos.y);
    cleanupToolbarDrag();
    draw();
    return;
  }
  
  if (draggingToolbarType) return;
  
  if (isResizing) {
    isResizing = false;
    resizingObject = null;
    saveState();
    draw();
    return;
  }
  
  if (isSelecting) {
    // CORRE√á√ÉO: Lista de objetos a serem selecionados
    const objectsToSelect = [];
    
    // ENTIDADES: Verifica quais entidades est√£o dentro da √°rea de sele√ß√£o
    entities.forEach(e => {
      const width = e.width || defaultEntityWidth;
      const height = e.height || defaultEntityHeight;
      
      // Verifica se a entidade intersecta com a √°rea de sele√ß√£o
      if (!(e.x + width < selectionRect.x || 
            e.x > selectionRect.x + selectionRect.width ||
            e.y + height < selectionRect.y || 
            e.y > selectionRect.y + selectionRect.height)) {
        objectsToSelect.push(e);
      }
    });
    
    // ATRIBUTOS: Verifica quais atributos est√£o dentro da √°rea de sele√ß√£o
    attributes.forEach(a => {
      const rx = a.radiusX || defaultAttributeRadiusX;
      const ry = a.radiusY || defaultAttributeRadiusY;
      
      // Verifica se o atributo intersecta com a √°rea de sele√ß√£o
      // Aproximando a elipse com um ret√¢ngulo circunscrito para a verifica√ß√£o
      if (!(a.x + rx < selectionRect.x || 
            a.x - rx > selectionRect.x + selectionRect.width ||
            a.y + ry < selectionRect.y || 
            a.y - ry > selectionRect.y + selectionRect.height)) {
        objectsToSelect.push(a);
      }
    });
    
    // RELACIONAMENTOS: Verifica quais relacionamentos est√£o dentro da √°rea de sele√ß√£o
    relationships.forEach(r => {
      const half = (r.size || relationshipSize) / 2;
      
      // Verifica se o relacionamento intersecta com a √°rea de sele√ß√£o
      if (!(r.x + half < selectionRect.x || 
            r.x - half > selectionRect.x + selectionRect.width ||
            r.y + half < selectionRect.y || 
            r.y - half > selectionRect.y + selectionRect.height)) {
        objectsToSelect.push(r);
      }
    });
    
    // ESPECIALIZA√á√ïES: Verifica quais especializa√ß√µes est√£o dentro da √°rea de sele√ß√£o
    specializations.forEach(s => {
      const half = (s.size || defaultSpecializationSize) / 2;
      
      // Verifica se a especializa√ß√£o intersecta com a √°rea de sele√ß√£o
      if (!(s.x + half < selectionRect.x || 
            s.x - half > selectionRect.x + selectionRect.width ||
            s.y + half < selectionRect.y || 
            s.y - half > selectionRect.y + selectionRect.height)) {
        objectsToSelect.push(s);
      }
    });

    // AGREGA√á√ïES: Verifica quais agrega√ß√µes est√£o dentro da √°rea de sele√ß√£o
    aggregations.forEach(agg => {
      const half = (agg.size || relationshipSize) / 2;
      const rectSize = half * 1.2; // Tamanho do ret√¢ngulo externo da agrega√ß√£o
      
      // Verifica se a agrega√ß√£o intersecta com a √°rea de sele√ß√£o
      if (!(agg.x + rectSize < selectionRect.x || 
            agg.x - rectSize > selectionRect.x + selectionRect.width ||
            agg.y + rectSize < selectionRect.y || 
            agg.y - rectSize > selectionRect.y + selectionRect.height)) {
        objectsToSelect.push(agg);
      }
    });


    
    // CORRE√á√ÉO: Limpa a sele√ß√£o atual apenas se n√£o tivermos a tecla Shift pressionada
    // Nota: Para adicionar suporte a Shift, voc√™ pode verificar evt.shiftKey
    if (!evt.shiftKey) {
      clearSelection();
    }


    if (!isCtrlPressed) {
      clearSelection();
    }
    
    // Seleciona todos os objetos encontrados
    objectsToSelect.forEach(obj => {
      obj.selected = true;
    });
    
    // Limpa estado de sele√ß√£o e redesenha
    isSelecting = false;
    selectionRect = null;
    
    // Se selecionamos pelo menos um objeto, considere isso uma altera√ß√£o de estado
    if (objectsToSelect.length > 0) {
      // N√£o salvamos o estado aqui para n√£o adicionar ao hist√≥rico de desfazer a cada sele√ß√£o
      // saveState(); // Comentado para n√£o adicionar ao hist√≥rico de desfazer
    }
    
    draw();
    return;
  }
  
  if (isDraggingGroup) {
    isDraggingGroup = false;
    groupDragData = [];
    saveState();
    draw();
    return;
  }
  
  if (isDraggingObject) {
    isDraggingObject = false;
    dragObject = null;
    saveState();
    draw();
    return;
  }
  
  if (isDraggingConnection) {
    // Se n√£o estamos no modo de clique, processe o drop normalmente
    if (!relationClickMode) {
      let drop = getDraggableAt(pos.x, pos.y);
      if (drop) {
        handleConnectionDrop(draggingConnection, drop);
      }
      isDraggingConnection = false;
      draggingConnection = null;
      saveState();
      draw();
    }
    // Se estamos no modo de clique, n√£o fa√ßa nada aqui - o handler de clique cuidar√° disso
    return;
  }

  canvas.style.cursor = "default";
}


    canvas.addEventListener("touchstart", onCanvasStart);
    canvas.addEventListener("touchmove", onCanvasMove);
    canvas.addEventListener("touchend", onCanvasEnd);
    canvas.addEventListener("touchcancel", onCanvasEnd);
    canvas.addEventListener("mousedown", onCanvasStart);
    canvas.addEventListener("mousemove", onCanvasMove);
    canvas.addEventListener("mouseup", onCanvasEnd);

    

    let inlineInput = null, inlineSelect = null, inlineSpecSelect = null;

function updateCursor() {
  if (isCtrlPressed) {
    canvas.style.cursor = "pointer"; // ou voc√™ pode usar uma imagem personalizada
  } else {
    canvas.style.cursor = "default";
  }
}


canvas.addEventListener("click", function(evt) {
  let pos = getMousePos(evt);

  // Se estamos no modo de cria√ß√£o de relacionamento, tente completar a rela√ß√£o
  if (isDraggingConnection && draggingConnection) {
    let drop = getDraggableAt(pos.x, pos.y);
    if (drop) {
      handleConnectionDrop(draggingConnection, drop);
      saveState();
      showNotification("Relacionamento criado", "success");
    } else {
      showNotification("Clique em um objeto v√°lido", "error");
    }
    
    // Independentemente do resultado, limpe o estado
    isDraggingConnection = false;
    draggingConnection = null;
    canvas.style.cursor = "default";
    draw();
    return;
  }

  

  // Mostrar o submenu ao clicar na linha
    if (selectedConnection /* e se for identificado um clique na √°rea da conex√£o */) {
    showConnectionSubmenu(selectedConnection, pos.x, pos.y);
    return;
  }
  // Se a conex√£o de especializa√ß√£o foi selecionada:
  if (selectedSpecConnection) {
    showSpecConnectionSubmenu(selectedSpecConnection, pos.x, pos.y);
    return;
  }
  // Se a conex√£o de agrega√ß√£o foi selecionada:
  if (selectedAggregationConnection) {
    showAggregationConnectionSubmenu(selectedAggregationConnection, pos.x, pos.y);
    return;
  }

  


  // Importante: Se temos um pendingConnectionHit, isso significa que nosso onCanvasStart
  // capturou um clique em uma linha ou conex√£o, mas n√£o foi um arraste
  if (pendingConnectionHit) {
    clearTimeout(breakpointTimeout);
    breakpointTimeout = null;
    
    // Determine o tipo de conex√£o para selecionar
    if (pendingConnectionHit.type === "connection") {
      selectedConnection = {
        relationshipId: pendingConnectionHit.relationship.id,
        entityId: pendingConnectionHit.connection.entityId,
        iconRect: null
      };
      
    } else if (pendingConnectionHit.type === "specialization-connection") {
      selectedSpecConnection = {
        specializationId: pendingConnectionHit.specialization.id,
        entityId: pendingConnectionHit.connection.entityId,
        vertex: pendingConnectionHit.connection.vertex,
        iconRect: null
      };
    } else if (pendingConnectionHit.type === "aggregation-connection") {
      // Seleciona a conex√£o de agrega√ß√£o
      selectedAggregationConnection = {
        aggregationId: pendingConnectionHit.aggregation.id,
        entityId: pendingConnectionHit.connection.entityId,
        relationshipId: pendingConnectionHit.connection.relationshipId,
        iconRect: null
      };
      
    }
    
    pendingConnectionHit = null;
    clearSelection(); // Limpar outras sele√ß√µes
    draw();
    return;
  }

  
  //    prossiga com o que voc√™ j√° faz para breakpoints e labelRect etc.
  for (let r of relationships) {
    for (let conn of r.connections) {
      // ...
      // (o seu loop de breakpoints e labelRect)
    }
  }
});



function showConnectionSubmenu(connInfo, x, y) {
  // Cria o submenu
  const submenu = document.createElement("div");
  submenu.className = "submenu";
  document.body.appendChild(submenu);

  // Cria o item para alternar o status "Rel. Fraco" / "Excluir Rel. Fraco"
  const weakItem = document.createElement("div");
  weakItem.className = "submenu-item";

  // Localiza a conex√£o real para saber se j√° est√° marcada como weak.
  let rObj = relationships.find(rr => rr.id === connInfo.relationshipId);
  let connectionObj = rObj ? rObj.connections.find(c => c.entityId === connInfo.entityId) : null;

  if (connectionObj && !connectionObj.weak) {
    weakItem.innerHTML = `<svg class="w-5 h-5" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
  <!-- Losango com borda tracejada -->
  <path d="M12 2 L22 12 L12 22 L2 12 Z" stroke-dasharray="4 2"/>
</svg>
<span class="text-white ml-2">Rel. Fraco</span>`;
  } else {
    weakItem.innerHTML = `<svg class="w-5 h-5" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
  <!-- Losango com borda tracejada -->
  <path d="M12 2 L22 12 L12 22 L2 12 Z" stroke-dasharray="4 2"/>
  <!-- Sobreposi√ß√£o de um X -->
  <line x1="8" y1="8" x2="16" y2="16"/>
  <line x1="16" y1="8" x2="8" y2="16"/>
</svg>
<span class="text-white ml-2">Excluir Rel. Fraco</span>`;
  }
  weakItem.addEventListener("click", function(e) {
    e.preventDefault();
    let r = relationships.find(rr => rr.id === connInfo.relationshipId);
    if (r) {
      let conn = r.connections.find(c => c.entityId === connInfo.entityId);
      if (conn) {
        // Alterna o status weak
        conn.weak = !conn.weak;
      }
    }
    document.body.removeChild(submenu);
    saveState();
    clearSelection();
    draw();
  });
  submenu.appendChild(weakItem);

  // Cria o item "Deletar"
  const deleteItem = document.createElement("div");
  deleteItem.className = "submenu-item";
  deleteItem.innerHTML = `<svg class="w-5 h-5 text-white" fill="none" 
    stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
    <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12"/>
    </svg><span class="text-white ml-2">Deletar</span>`;
  
  // Define a a√ß√£o de clique para deletar a conex√£o
  deleteItem.addEventListener("click", function(e) {
    e.preventDefault();
    // Procura o relacionamento correspondente
    let r = relationships.find(rr => rr.id === connInfo.relationshipId);
    if (r) {
      r.connections = r.connections.filter(c => c.entityId !== connInfo.entityId);
    }
    // Fecha o submenu e atualiza o desenho
    document.body.removeChild(submenu);
    selectedConnection = null;
    saveState();
    clearSelection();
    draw();
  });
  
  submenu.appendChild(deleteItem);
  
  // Posiciona o submenu pr√≥ximo ao clique (ajuste conforme necess√°rio)
  submenu.style.position = "fixed";
  submenu.style.left = (x - 70) + "px";
  submenu.style.top = (y - 50) + "px";
  submenu.style.zIndex = "1050";
  submenu.style.backgroundColor = "#1f2937";
  submenu.style.borderRadius = "8px";
  submenu.style.boxShadow = "0 4px 20px rgba(0, 0, 0, 0.6)";
  submenu.style.padding = "8px";
  submenu.style.display = "flex";
  submenu.style.flexDirection = "column";
  submenu.style.gap = "4px";

  // Adiciona um handler para fechar o submenu ao clicar fora
  setTimeout(() => {
    document.addEventListener("click", function handler(e) {
      if (!submenu.contains(e.target)) {
        document.body.removeChild(submenu);
        document.removeEventListener("click", handler);
      }
    });
  }, 100);
}


function showSpecConnectionSubmenu(connInfo, x, y) {
  // Cria e configura o submenu para conex√µes de especializa√ß√£o
  const submenu = document.createElement("div");
  submenu.className = "submenu";
  document.body.appendChild(submenu);

  const deleteItem = document.createElement("div");
  deleteItem.className = "submenu-item";
  deleteItem.innerHTML = `<svg class="w-5 h-5 text-white" fill="none" stroke="currentColor"
    stroke-width="2" viewBox="0 0 24 24">
    <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12"/>
    </svg><span class="text-white ml-2">Deletar</span>`;
  
  deleteItem.addEventListener("click", function(e) {
    e.preventDefault();
    // Procura a especializa√ß√£o correspondente e remove a conex√£o
    let spec = specializations.find(sp => sp.id === connInfo.specializationId);
    if (spec && spec.connections) {
      spec.connections = spec.connections.filter(c => 
        !(c.entityId === connInfo.entityId && c.vertex === connInfo.vertex)
      );
    }
    document.body.removeChild(submenu);
    selectedSpecConnection = null;
    saveState();
    clearSelection();
    draw();
  });
  
  submenu.appendChild(deleteItem);
  // Posiciona e estiliza o submenu (semelhante √† fun√ß√£o showConnectionSubmenu)
  submenu.style.position = "fixed";
  submenu.style.left = (x - 70) + "px";
  submenu.style.top = (y - 0) + "px";
  submenu.style.zIndex = "1050";
  submenu.style.backgroundColor = "#1f2937";
  submenu.style.borderRadius = "8px";
  submenu.style.boxShadow = "0 4px 20px rgba(0, 0, 0, 0.6)";
  submenu.style.padding = "8px";
  submenu.style.display = "flex";
  submenu.style.flexDirection = "column";
  submenu.style.gap = "4px";
  
  setTimeout(() => {
    document.addEventListener("click", function handler(e) {
      if (!submenu.contains(e.target)) {
        document.body.removeChild(submenu);
        document.removeEventListener("click", handler);
      }
    });
  }, 100);
}

function showAggregationConnectionSubmenu(connInfo, x, y) {
  // Cria e configura o submenu para conex√µes de agrega√ß√£o
  const submenu = document.createElement("div");
  submenu.className = "submenu";
  document.body.appendChild(submenu);

  const deleteItem = document.createElement("div");
  deleteItem.className = "submenu-item";
  deleteItem.innerHTML = `<svg class="w-5 h-5 text-white" fill="none" stroke="currentColor"
    stroke-width="2" viewBox="0 0 24 24">
    <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12"/>
    </svg><span class="text-white ml-2">Deletar</span>`;
  
  deleteItem.addEventListener("click", function(e) {
    e.preventDefault();
    // Procura a agrega√ß√£o correspondente e remove a conex√£o
    let agg = aggregations.find(a => a.id === connInfo.aggregationId);
    if (agg && agg.connections) {
      agg.connections = agg.connections.filter(c => 
        !(c.entityId === connInfo.entityId || c.relationshipId === connInfo.relationshipId)
      );
    }
    document.body.removeChild(submenu);
    selectedAggregationConnection = null;
    saveState();
    clearSelection();
    draw();
  });
  
  submenu.appendChild(deleteItem);
  // Posiciona e estiliza o submenu
  submenu.style.position = "fixed";
  submenu.style.left = (x - 60) + "px";
  submenu.style.top = (y - 10) + "px";
  submenu.style.zIndex = "1050";
  submenu.style.backgroundColor = "#1f2937";
  submenu.style.borderRadius = "8px";
  submenu.style.boxShadow = "0 4px 20px rgba(0, 0, 0, 0.6)";
  submenu.style.padding = "8px";
  submenu.style.display = "flex";
  submenu.style.flexDirection = "column";
  submenu.style.gap = "4px";
  
  setTimeout(() => {
    document.addEventListener("click", function handler(e) {
      if (!submenu.contains(e.target)) {
        document.body.removeChild(submenu);
        document.removeEventListener("click", handler);
      }
    });
  }, 100);
}


function onCanvasContextMenu(evt) {
  evt.preventDefault();
  let pos = getMousePos(evt);
  
  let hit = getDraggableAt(pos.x, pos.y);
  if (hit && (hit.type === "connection" || hit.type === "specialization-connection" || 
              hit.type === "aggregation-connection")) {
    // Para todos os tipos, certifica-se de que exista o array de breakpoints
    if (!hit.connection.breakpoints) {
      hit.connection.breakpoints = [];
    }
    if (hit.connection.breakpoints.length === 0) {
      hit.connection.breakpoints.push({ x: pos.x, y: pos.y });
    }
    saveState();
    draw();
    return;
  }
}

function onCanvasDblClick(evt){
      let pos = getMousePos(evt);
      

      // Primeiro: percorre as conex√µes de agrega√ß√£o
      for (let agg of aggregations) {
        if (agg.connections) {
          for (let i = 0; i < agg.connections.length; i++) {
            let conn = agg.connections[i];
            if (conn.breakpoints && conn.breakpoints.length > 0) {
              for (let j = 0; j < conn.breakpoints.length; j++) {
                let bp = conn.breakpoints[j];
                if (Math.hypot(pos.x - bp.x, pos.y - bp.y) < 8) {
                  // Remove o breakpoint e atualiza o desenho
                  conn.breakpoints.splice(j, 1);
                  saveState();
                  clearSelection();
                  draw();
                  return; // Interrompe para n√£o prosseguir com outros duplos cliques
                }
              }
            }
          }
        }
      }

       // Primeiro: percorre as conex√µes de especializa√ß√£o
      for (let s of specializations) {
        if (s.connections) {
          for (let i = 0; i < s.connections.length; i++) {
            let conn = s.connections[i];
            if (conn.breakpoints && conn.breakpoints.length > 0) {
              for (let j = 0; j < conn.breakpoints.length; j++) {
                let bp = conn.breakpoints[j];
                if (Math.hypot(pos.x - bp.x, pos.y - bp.y) < 8) {
                  // Remove o breakpoint e atualiza o desenho
                  conn.breakpoints.splice(j, 1);
                  saveState();
                  clearSelection();
                  draw();
                  return; // Interrompe para n√£o prosseguir com outros duplos cliques
                }
              }
            }
          }
        }
      }
      
      // Em seguida: percorre as conex√µes de relacionamento
      for (let r of relationships) {
        for (let i = 0; i < r.connections.length; i++) {
          let conn = r.connections[i];
          if (conn.breakpoints && conn.breakpoints.length > 0) {
            for (let j = 0; j < conn.breakpoints.length; j++) {
              let bp = conn.breakpoints[j];
              if (Math.hypot(pos.x - bp.x, pos.y - bp.y) < 8) {
                conn.breakpoints.splice(j, 1);
                saveState();
                clearSelection();
                draw();
                return;
              }
            }
          }
        }
      }

      // Verifica se clicou no label da cardinalidade de uma agrega√ß√£o
      for (let agg of aggregations) {
        if (agg.connections) {
          for (let conn of agg.connections) {
            if (conn.labelRect && isInsideRect(pos, conn.labelRect)) {
              let labelCenterX = conn.labelRect.x + conn.labelRect.width / 2;
              let labelBottomY = conn.labelRect.y + conn.labelRect.height;
              
              showCardinalityEditor(conn, labelCenterX, labelBottomY);
              return;
            }
          }
        }
      }



      let hit = getDraggableAt(pos.x, pos.y);

      

      // Verifica se clicou na linha de conex√£o de agrega√ß√£o
      if (hit && hit.type === "aggregation-connection") {
        // O comportamento deve ser o mesmo do duplo clique na cardinalidade
        if (hit.connection.labelRect && isInsideRect(pos, hit.connection.labelRect)) {
          showCardinalityEditor(
            hit.connection,
            hit.connection.labelRect.x + hit.connection.labelRect.width / 2,
            hit.connection.labelRect.y + hit.connection.labelRect.height
          );
          return;
        }
        
        // Se clicou na linha mas n√£o no label, tamb√©m devemos editar a cardinalidade
        const aggCenter = { x: hit.aggregation.x, y: hit.aggregation.y };
        let targetCenter;
        let target;
        
        if (hit.connection.entityId) {
          target = entities.find(e => e.id === hit.connection.entityId);
          if (target) {
            targetCenter = { x: target.x + target.width/2, y: target.y + target.height/2 };
          }
        } else if (hit.connection.relationshipId) {
          target = relationships.find(r => r.id === hit.connection.relationshipId);
          if (target) {
            targetCenter = { x: target.x, y: target.y };
          }
        }
        
        if (target && targetCenter) {
          const midX = (aggCenter.x + targetCenter.x) / 2;
          const midY = (aggCenter.y + targetCenter.y) / 2;
          showCardinalityEditor(hit.connection, midX, midY);
        }
        return;
      }


    

      if (hit && hit.type === "breakpoint") {
        // Remove o breakpoint clicado
        hit.connection.breakpoints.splice(hit.index, 1);
        saveState();
        clearSelection();
        draw();
        return; // Interrompe a execu√ß√£o para n√£o executar outras a√ß√µes de dblclick
      }

      // Cancela submenu se houver
      if (submenuTimeout) {
        clearTimeout(submenuTimeout);
        submenuTimeout = null;
      }
      if (draggingToolbarType) return;

      


      // 1) Verifica se clicou no label da cardinalidade
      for (let r of relationships) {
        for (let conn of r.connections) {
          if (conn.labelRect && isInsideRect(pos, conn.labelRect)) {
            // Se clicou diretamente no label
            // Calcula uma posi√ß√£o para abrir o seletor
            // (por exemplo, logo abaixo do label)
            let labelCenterX = conn.labelRect.x + conn.labelRect.width / 2;
            let labelBottomY = conn.labelRect.y + conn.labelRect.height;

            showCardinalityEditor(
              conn, 
              labelCenterX, 
              labelBottomY
            );
            return; 
          }
        }
      }




      if (hit) {
        if (hit.type === "entity" || hit.type === "attribute" || hit.type === "relationship" || 
            hit.type === "derivedAttribute" || hit.type === "multivaluedAttribute") {  // Adicionar este caso
          let compX = hit.type === "entity" ? hit.element.x + (hit.element.width || defaultEntityWidth)/2 : hit.element.x;
          let compY = hit.type === "entity" ? hit.element.y + (hit.element.height || defaultEntityHeight)/2 : hit.element.y;
          showInlineEditor(hit.element, compX, compY);
          
        }  else if (hit.type === "specialization") {
          showSpecTypeEditor(hit.element, hit.element.x, hit.element.y);
        } else if (hit.type === "connection") {
          const e = entities.find(en => en.id === hit.connection.entityId);
          if (e) {
            const rCenter = { x: hit.relationship.x, y: hit.relationship.y };
            const eCenter = { x: e.x + e.width/2, y: e.y + e.height/2 };
            const rBoundary = getDiamondBorderPoint(hit.relationship.x, hit.relationship.y, eCenter.x - hit.relationship.x, eCenter.y - hit.relationship.y, hit.relationship.size/2);
            const eBoundary = getRectBorderPoint(eCenter.x, eCenter.y, rCenter.x - eCenter.x, rCenter.y - eCenter.y, e.width/2, e.height/2);
            const midX = (rBoundary.x + eBoundary.x) / 2;
            const midY = (rBoundary.y + eBoundary.y) / 2;
            showCardinalityEditor(hit.connection, midX, midY);
          }
        }
      }

      // Adicionar caso para double-click em uma agrega√ß√£o
      if (hit && hit.type === "aggregation") {
        showInlineEditor(hit.element, hit.element.x, hit.element.y);
      }
    }

    function showInlineEditor(item, compX, compY) {
      if (inlineInput) $(inlineInput).remove();
      
      // 1) Pega o bounding do canvas
      let rect = canvas.getBoundingClientRect();
      
      // 2) Converte (compX, compY) do ‚Äúmundo‚Äù para tela
      let screenX = rect.left + (compX + panOffset.x) * zoom;
      let screenY = rect.top  + (compY + panOffset.y) * zoom;

      // Posicionamento especial para atributos
      if (item.objType === "attribute" || item.objType === "derivedAttribute" || item.objType === "multivaluedAttribute") {
        // Para atributos, posiciona o editor ao lado do c√≠rculo
        screenX = rect.left + ((item.x + ATTR_CIRCLE_RADIUS + ATTR_TEXT_PADDING) + panOffset.x) * zoom;
      }
      
      // 3) Cria o input na posi√ß√£o correta
      inlineInput = $("<input type='text' class='p-2 border rounded shadow focus:outline-none focus:ring-2 focus:ring-blue-500 bg-gray-800 text-white' />")
        .val(item.name)
        .css({
          position: "absolute",
          fontSize: "16px",
          zIndex: 1000,
          width: "160px",
          left: (screenX) + "px",
          top: (screenY - 10) + "px"
        });
      
        $("body").append(inlineInput);
        inlineInput.focus().select();
        
        inlineInput.on("blur", function() {
          item.name = inlineInput.val();
          $(inlineInput).remove();
          inlineInput = null;
          saveState();
          draw();
        }).on("keydown", function(e) {
          if (e.key === "Enter") inlineInput.blur();
        });
    }

    function showSpecTypeEditor(spec, compX, compY) {
      if (inlineSpecSelect) $(inlineSpecSelect).remove();
        let canvasRect = canvas.getBoundingClientRect();
        let screenX = canvasRect.left + (compX + panOffset.x) * zoom;
        let screenY = canvasRect.top + (compY + panOffset.y) * zoom;
        inlineSpecSelect = $("<select class='p-2 border rounded shadow focus:outline-none focus:ring-2 focus:ring-blue-500 bg-gray-800 text-white'></select>")
          .css({
            position: "absolute",
            fontSize: "16px",
            zIndex: 1000,
            width: "100px",
            left: (screenX - 50) + "px",
            top: (screenY - 20) + "px"
          });
      const options = ["T,C", "T,D", "P,C", "P,D"];
      options.forEach(opt => {
        const option = $("<option></option>").val(opt).text(opt);
        if (opt === spec.genType) option.prop("selected", true);
        inlineSpecSelect.append(option);
      });
      $("body").append(inlineSpecSelect);
      inlineSpecSelect.focus();
      inlineSpecSelect.on("change", function() {
        spec.genType = inlineSpecSelect.val();
        $(inlineSpecSelect).remove();
        inlineSpecSelect = null;
        saveState();
        draw();
      }).on("blur", function() {
        $(inlineSpecSelect).remove();
        inlineSpecSelect = null;
      });
    }


    function showCardinalityEditor(connection, compX, compY) {
      if (inlineSelect) $(inlineSelect).remove();

      let rect = canvas.getBoundingClientRect();
      let screenX = rect.left + (compX + panOffset.x) * zoom;
      let screenY = rect.top  + (compY + panOffset.y) * zoom;

      inlineSelect = $("<select class='p-2 border rounded shadow focus:outline-none focus:ring-2 focus:ring-blue-500 bg-gray-800 text-white'></select>")
        .css({
          position: "absolute",
          fontSize: "16px",
          zIndex: 1000,
          width: "100px",
          left: (screenX - 50) + "px",
          top:  (screenY - 20) + "px"
        });

      const options = ["0,N", "1,N", "0,1", "1,1"];
      options.forEach(opt => {
        const option = $("<option></option>").val(opt).text(opt);
        if (opt === connection.cardinality) option.prop("selected", true);
        inlineSelect.append(option);
      });

      $("body").append(inlineSelect);
      inlineSelect.focus();
      inlineSelect.on("change", function() {
        connection.cardinality = inlineSelect.val();
        $(inlineSelect).remove();
        inlineSelect = null;
        saveState();
        draw();
      }).on("blur", function() {
        $(inlineSelect).remove();
        inlineSelect = null;
      });
    }

  

function showSubmenu(element, x, y) {
  // Fun√ß√£o para fechar o submenu visualmente, mantendo estado
  const closeSubmenuVisual = () => {
    if (submenu) {
      $(submenu).remove();
      submenu = null;
      submenuRect = null;
    }
    
    // Tamb√©m remove o manipulador de eventos atual quando o submenu √© fechado
    if (currentSubmenuCloseHandler) {
      document.removeEventListener('click', currentSubmenuCloseHandler);
      currentSubmenuCloseHandler = null;
    }
  };

  // Fechar qualquer submenu existente
  closeSubmenuVisual();
  
  // Criar o novo submenu
  submenu = document.createElement("div");
  submenu.className = "submenu";
  document.body.appendChild(submenu);

  let items = [];
  
  
   // Op√ß√µes comuns para elementos que podem criar relacionamentos
   if (element.objType === "entity" || element.objType === "relationship" || 
      element.objType === "specialization") {
    items.push({
      icon: '<svg class="w-5 h-5 text-white" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101m-.758-4.899a4 4 0 005.656 0l4-4a4 4 0 00-5.656-5.656l-1.1 1.1"/></svg>',
      label: "Relacionar",
      id: "menuRelate",
      action: function(e) {
        // Previne o comportamento padr√£o e propaga√ß√£o
        e.preventDefault();
        e.stopPropagation();
        
        // Remove apenas o visual do submenu, mant√©m o estado
        closeSubmenuVisual();
        
        // Inicia o modo de relacionamento
        isDraggingConnection = true;
        
        // Configura o objeto de conex√£o com origem e destino
        let sourceX = element.x, sourceY = element.y;
        
        // Ajusta para o centro dependendo do tipo
        if (element.objType === "entity") {
          sourceX += (element.width || defaultEntityWidth) / 2;
          sourceY += (element.height || defaultEntityHeight) / 2;
        } else if (element.objType === "relationship") {
          // Relationship j√° √© centrada
        } else if (element.objType === "specialization") {
          // Specialization j√° √© centrada
        } else if (element.objType === "aggregation") {
          // Adicionar l√≥gica de exclus√£o para agrega√ß√µes
          aggregations = aggregations.filter(a => a.id !== element.id);
          attributes = attributes.filter(a => !(a.parentType === "aggregation" && a.parentId === element.id));
        }
        
        // Cria o objeto de conex√£o
        draggingConnection = {
          type: element.objType,
          element: element,
          start: { x: sourceX, y: sourceY },
          current: { x: x, y: y }
        };
        
        
        
        // Mostra ao usu√°rio o que est√° acontecendo
        showNotification("Clique em outro objeto para relacionar", "info");
        
        // Limpa sele√ß√£o e desenha para atualizar
        clearSelection();
        draw();
      }
    });



    // SE FOR UM LOSANGO ENTAO POSSO MUDAR PARA AGREGA√á√ÉO
    if (element.objType === "relationship") {
      items.push({
        icon: '<svg class="w-5 h-5 text-white" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><rect x="6" y="6" width="12" height="12" rx="1" /><polygon points="12 8 16 12 12 16 8 12" /></svg>',
        label: "Mudar para Agrega√ß√£o",
        id: "menuConvertToAggregation",
        action: function(e) {
          e.preventDefault();
          closeSubmenuVisual();
          
          // Criar um novo objeto agrega√ß√£o com os mesmos dados do relacionamento
          const newAgg = {
            id: aggregationIdCounter++,
            x: element.x,
            y: element.y,
            size: element.size || relationshipSize,
            name: element.name,
            connections: [...element.connections], // Copiar as conex√µes existentes
            selected: element.selected,
            objType: "aggregation"
          };
          
          // Adicionar a nova agrega√ß√£o
          aggregations.push(newAgg);
          
          // Transferir os atributos associados ao relacionamento para a agrega√ß√£o
          attributes.forEach(attr => {
            if (attr.parentType === "relationship" && attr.parentId === element.id) {
              attr.parentType = "aggregation";
              attr.parentId = newAgg.id;
            }
          });
          
          // Remover o relacionamento original
          relationships = relationships.filter(r => r.id !== element.id);
          
          // Salvar estado, limpar sele√ß√£o e redesenhar
          saveState();
          clearSelection();
          draw();
        }
      });
    }


    


    


    
    items.push({
      icon: '<svg class="w-5 h-5 text-white" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12"/></svg>',
      label: "Deletar",
      id: "menuDelete",
      action: function(e) {
        e.preventDefault();
        closeSubmenuVisual();
        
        if (element.objType === "entity") {
          entities = entities.filter(e => e.id !== element.id);
          attributes = attributes.filter(a => !(a.parentType === "entity" && a.parentId === element.id));
          relationships.forEach(r => r.connections = r.connections.filter(c => c.entityId !== element.id));
          specializations.forEach(s => s.connections = s.connections.filter(c => c.entityId !== element.id));
        } else if (element.objType === "relationship") {
          relationships = relationships.filter(r => r.id !== element.id);
          attributes = attributes.filter(a => !(a.parentType === "relationship" && a.parentId === element.id));
        } else if (element.objType === "specialization") {
          specializations = specializations.filter(s => s.id !== element.id);
        }
        saveState();
        clearSelection();
        draw();
      }
    });
  }
  

  if (element.objType === "aggregation") {
    items.push({
      icon: '<svg class="w-5 h-5 text-white" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101m-.758-4.899a4 4 0 005.656 0l4-4a4 4 0 00-5.656-5.656l-1.1 1.1"/></svg>',
      label: "Relacionar",
      id: "menuRelate",
      action: function(e) {
        // ... c√≥digo existente para iniciar o relacionamento
        e.preventDefault();
        e.stopPropagation();
        
        closeSubmenuVisual();
        
        // Inicia o modo de relacionamento para a agrega√ß√£o
        isDraggingConnection = true;
        draggingConnection = {
          type: "aggregation",
          element: element,
          start: { x: element.x, y: element.y },
          current: { x: x, y: y }
        };
        
        
        showNotification("Clique em uma entidade ou relacionamento para conectar", "info");
        
        clearSelection();
        draw();
      }
    });
    
    items.push({
      icon: '<svg class="w-5 h-5 text-white" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><polygon points="12 4 20 12 12 20 4 12" /></svg>',
      label: "Mudar para Relacionamento",
      id: "menuConvertToRelationship",
      action: function(e) {
        e.preventDefault();
        closeSubmenuVisual();
        
        // Criar um novo objeto relacionamento com os mesmos dados da agrega√ß√£o
        const newRel = {
          id: relationshipIdCounter++,
          x: element.x,
          y: element.y,
          size: element.size || relationshipSize,
          name: element.name,
          connections: [], // Inicializa com array vazio
          selected: element.selected,
          objType: "relationship"
        };
        
        // Copia as conex√µes da agrega√ß√£o para o relacionamento
        // (mantendo apenas as conex√µes com entidades)
        if (element.connections) {
          element.connections.forEach(conn => {
            if (conn.entityId) {
              newRel.connections.push({
                entityId: conn.entityId,
                cardinality: conn.cardinality,
                breakpoints: conn.breakpoints
              });
            }
          });
        }
        
        // Adicionar o novo relacionamento
        relationships.push(newRel);
        
        // Transferir os atributos associados √† agrega√ß√£o para o relacionamento
        attributes.forEach(attr => {
          if (attr.parentType === "aggregation" && attr.parentId === element.id) {
            attr.parentType = "relationship";
            attr.parentId = newRel.id;
          }
        });
        
        // Remover a agrega√ß√£o original
        aggregations = aggregations.filter(a => a.id !== element.id);
        
        // Salvar estado, limpar sele√ß√£o e redesenhar
        saveState();
        clearSelection();
        draw();
      }
    });

    items.push({
      icon: '<svg class="w-5 h-5 text-white" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12"/></svg>',
      label: "Deletar",
      id: "menuDelete",
      action: function(e) {
        e.preventDefault();
        closeSubmenuVisual();
        
        // Remove a agrega√ß√£o e seus atributos
        aggregations = aggregations.filter(a => a.id !== element.id);
        attributes = attributes.filter(a => !(a.parentType === "aggregation" && a.parentId === element.id));
        
        saveState();
        clearSelection();
        draw();
      }
    })
  }

  // Op√ß√µes para atributos - verifica√ß√£o para todos os tipos de atributos
  if (element.objType === "attribute" || element.objType === "derivedAttribute" || element.objType === "multivaluedAttribute") {
    
    // A op√ß√£o "Definir Chave" s√≥ deve aparecer para atributos simples (n√£o derivados, n√£o multivalorados)
    // Utilizamos explicitamente o objType (mais confi√°vel do que verificar as flags)
    if (!element.derived && !element.multivalued) {
      items.push({
        icon: '<svg class="w-5 h-5 text-white" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M15 7a2 2 0 012 2m4 0a6 6 0 01-7.743 5.743L11 17H9v2H7v2H4a1 1 0 01-1-1v-2.586a1 1 0 01.293-.707l5.964-5.964A6 6 0 1121 9z" /></svg>',
        label: element.primary ? "Remover Chave" : "Definir Chave",
        id: "menuKey",
        action: function(e) {
          e.preventDefault();
          closeSubmenuVisual();
          element.primary = !element.primary;
          saveState();
          clearSelection();
          draw();
        }
      });
    }

    // Op√ß√£o de exclus√£o para todos os tipos de atributos
    items.push({
      icon: '<svg class="w-5 h-5 text-white" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12"/></svg>',
      label: "Deletar",
      id: "menuDelete",
      action: function(e) {
        e.preventDefault();
        closeSubmenuVisual();
        attributes = attributes.filter(a => a.id !== element.id);
        attributes.forEach(a => { if (a.parentType === "attribute" && a.parentId === element.id) a.parentId = null; });
        saveState();
        clearSelection();
        draw();
      }
    });
  }




  
  // Adiciona os itens ao submenu
  items.forEach(item => {
    let div = document.createElement("div");
    div.className = "submenu-item";
    div.id = item.id;
    div.innerHTML = `${item.icon}<span class="text-white ml-2">${item.label}</span>`;
    
    // Aqui √© a mudan√ßa cr√≠tica: n√£o usamos onclick diretamente, mas sim addEventListener
    div.addEventListener("click", item.action);
    
    // Caso especial para o bot√£o relacionar (tamb√©m funciona com drag)
    if (item.id === "menuRelate") {
      div.addEventListener("mousedown", function(e) {
        relationMenuSource = element;
        $(document).on("mousemove.relationDrag", onRelationMenuDragMove);
        $(document).on("mouseup.relationDrag", onRelationMenuDragEnd);
        e.preventDefault();
        e.stopPropagation();
      });
    }
    
    submenu.appendChild(div);
  });

  // Define o ret√¢ngulo de representa√ß√£o do elemento para posicionar o menu
  let rect = element.objType === "entity" 
      ? { x: element.x, y: element.y, width: element.width || defaultEntityWidth, height: element.height || defaultEntityHeight }
      : (element.objType === "attribute" || element.objType === "derivedAttribute" || element.objType === "multivaluedAttribute") 
          ? { x: element.x - (element.radiusX || defaultAttributeRadiusX), 
              y: element.y - (element.radiusY || defaultAttributeRadiusY), 
              width: (element.radiusX || defaultAttributeRadiusX) * 2, 
              height: (element.radiusY || defaultAttributeRadiusY) * 2 }
          : element.objType === "relationship" 
              ? { x: element.x - (element.size || relationshipSize)/2, 
                  y: element.y - (element.size || relationshipSize)/2, 
                  width: element.size || relationshipSize, 
                  height: element.size || relationshipSize }
              : { x: element.x - (element.size || defaultSpecializationSize)/2, 
                  y: element.y - (element.size || defaultSpecializationSize)/2, 
                  width: element.size || defaultSpecializationSize, 
                  height: element.size || defaultSpecializationSize };

  // Obt√©m a posi√ß√£o do canvas na p√°gina
  let canvasRect = canvas.getBoundingClientRect();
  
  // Converte coordenadas do mundo para coordenadas da tela
  let screenX = canvasRect.left + (rect.x + panOffset.x) * zoom;
  let screenY = canvasRect.top + (rect.y + panOffset.y) * zoom;
  let screenWidth = rect.width * zoom;
  let screenHeight = rect.height * zoom;
  
  // Calcula a posi√ß√£o para o submenu
  let submenuX = screenX + (screenWidth / 2);
  let submenuY = screenY + screenHeight + 5;
  
  // Centraliza o submenu horizontalmente
  submenuX -= submenu.offsetWidth / 2;
  
  // Ajusta se o submenu sair da tela
  if (submenuX < 5) submenuX = 5;
  if (submenuX + submenu.offsetWidth > window.innerWidth - 5) 
      submenuX = window.innerWidth - submenu.offsetWidth - 5;
  
  // Se for ficar abaixo da tela, coloca acima do objeto
  if (submenuY + submenu.offsetHeight > window.innerHeight - 5) 
      submenuY = screenY - submenu.offsetHeight - 5;
  
  // Posiciona o submenu na tela
  submenu.style.position = "fixed";
  submenu.style.left = `${submenuX}px`;
  submenu.style.top = `${submenuY}px`;
  submenu.style.zIndex = "1050";
  
  // Estiliza o submenu
  submenu.style.backgroundColor = "#1f2937";
  submenu.style.borderRadius = "8px";
  submenu.style.boxShadow = "0 4px 20px rgba(0, 0, 0, 0.6)";
  submenu.style.padding = "8px";
  submenu.style.display = "flex";
  submenu.style.flexDirection = "column";
  submenu.style.gap = "4px";
  
  // Estiliza os itens do submenu
  for (let i = 0; i < submenu.children.length; i++) {
    submenu.children[i].style.padding = "8px 12px";
    submenu.children[i].style.borderRadius = "6px";
    submenu.children[i].style.cursor = "pointer";
    submenu.children[i].style.display = "flex";
    submenu.children[i].style.alignItems = "center";
    submenu.children[i].style.whiteSpace = "nowrap";
    submenu.children[i].style.transition = "background 0.2s";
    
    // Adiciona evento hover
    submenu.children[i].addEventListener("mouseover", function() {
      this.style.backgroundColor = "rgba(255, 255, 255, 0.1)";
    });
    submenu.children[i].addEventListener("mouseout", function() {
      this.style.backgroundColor = "transparent";
    });
  }
  
  // Salva a posi√ß√£o para detec√ß√£o de cliques
  submenuRect = {
    x: submenuX - canvasRect.left,
    y: submenuY - canvasRect.top,
    width: submenu.offsetWidth,
    height: submenu.offsetHeight
  };


  // Cria um novo manipulador de eventos para este submenu espec√≠fico
  currentSubmenuCloseHandler = function(e) {
    // Verifica se o clique foi fora do submenu
    if (submenu) {
      const submenuElement = submenu;
      const clickedInsideSubmenu = e.target === submenuElement || submenuElement.contains(e.target);
      
      if (!clickedInsideSubmenu) {
        closeSubmenuVisual();
      }
    }
  };

  // Adiciona o listener com um pequeno atraso para n√£o capturar o clique atual
  setTimeout(() => {
    document.addEventListener('click', currentSubmenuCloseHandler);
  }, 100);
}


// 2. Adicione esta nova fun√ß√£o para iniciar o modo de relacionamento por clique
function startClickRelationMode(element) {
  // Limpa qualquer estado de relacionamento ativo
  if (isDraggingConnection && draggingConnection) {
    isDraggingConnection = false;
    draggingConnection = null;
    canvas.style.cursor = "default";
    $(canvas).off("click.relationClick");
  }
  
  // Configura o novo estado de relacionamento por clique
  isDraggingConnection = true;
  relationClickMode = true;
  
  // Informa√ß√µes sobre o elemento de origem
  const centerX = element.objType === "entity" ? 
    element.x + (element.width || defaultEntityWidth)/2 : 
    element.x;
  const centerY = element.objType === "entity" ? 
    element.y + (element.height || defaultEntityHeight)/2 : 
    element.y;
  
  // Configura o objeto draggingConnection
  draggingConnection = {
    type: element.objType,
    element: element,
    start: { x: centerX, y: centerY },
    current: { x: centerX, y: centerY }  // Inicialmente igual ao ponto de in√≠cio
  };
  
  
  
  // Desenha a tela para mostrar o elemento selecionado
  clearSelection();
  draw();
  
  // Adiciona um handler para o pr√≥ximo clique que completar√° o relacionamento
  $(canvas).off("click.relationClick").on("click.relationClick", function(clickEvt) {
    // Importante: verifica se ainda estamos no modo de relacionamento
    if (!isDraggingConnection || !relationClickMode) return;
    
    const clickPos = getMousePos(clickEvt);
    const targetDrop = getDraggableAt(clickPos.x, clickPos.y);
    
    // Se clicou em um objeto v√°lido, cria a rela√ß√£o
    if (targetDrop) {
      // Tenta criar a rela√ß√£o
      handleConnectionDrop(draggingConnection, targetDrop);
      
      // Salva o estado
      saveState();
      
      // Mostra notifica√ß√£o de sucesso (opcional)
      showNotification("Relacionamento criado com sucesso!", "success");
    } else {
      // Opcional: notifica que nenhum objeto v√°lido foi selecionado
      showNotification("Clique em um objeto v√°lido para relacionar", "info");
    }
    
    // Limpa o estado de conex√£o independentemente do resultado
    exitClickRelationMode();
  });
  
  // Adicionamos tamb√©m um handler de movimento para atualizar o preview
  $(canvas).on("mousemove.relationPreview", function(moveEvt) {
    if (isDraggingConnection && relationClickMode && draggingConnection) {
      const movePos = getMousePos(moveEvt);
      draggingConnection.current = movePos;
      draw();
    }
  });
  
  // Exibe uma mensagem para o usu√°rio
  showNotification("Clique em outro objeto para criar o relacionamento", "info");
}


// 3. Adicione esta fun√ß√£o para limpar o modo de relacionamento por clique
function exitClickRelationMode() {
  isDraggingConnection = false;
  relationClickMode = false;
  draggingConnection = null;
  canvas.style.cursor = "default";
  
  // Remove os handlers tempor√°rios
  $(canvas).off("click.relationClick");
  $(canvas).off("mousemove.relationPreview");
  
  // Redesenha o canvas
  draw();
}

// Adiciona um listener para fechar o submenu ao clicar fora dele
const closeSubmenuHandler = function(e) {
  // Verifica se o clique foi fora do submenu
  if (submenu) {
    const submenuElement = submenu;
    const clickedInsideSubmenu = e.target === submenuElement || submenuElement.contains(e.target);
    
    if (!clickedInsideSubmenu) {
      $(submenu).remove();
      submenu = null;
      submenuRect = null;
      document.removeEventListener('click', closeSubmenuHandler);
    }
  }
};

// Adiciona o listener com um pequeno atraso para n√£o capturar o clique atual
setTimeout(() => {
  document.addEventListener('click', closeSubmenuHandler);
}, 100);

// Fun√ß√£o para lidar com o arrastar do relacionamento a partir do menu
function onRelationMenuDragMove(evt) {
  // Se tivermos um objeto de origem para o relacionamento
  if (relationMenuSource) {
    // Inicia o arraste do relacionamento se ainda n√£o come√ßou
    if (!isDraggingConnection) {
      isDraggingConnection = true;
      
      // Remove o menu
      if (submenu) {
        $(submenu).remove();
        submenu = null;
        submenuRect = null;
      }
      
      // Cria o objeto de conex√£o para desenhar a linha
      const sourceElement = relationMenuSource;
      const pos = getMousePos(evt);
      
      draggingConnection = {
        type: sourceElement.objType,
        element: sourceElement,
        start: { 
          x: sourceElement.x + (sourceElement.width || sourceElement.size || 0)/2, 
          y: sourceElement.y + (sourceElement.height || sourceElement.size || 0)/2 
        },
        current: { x: pos.x, y: pos.y }
      };
      
      // Limpa sele√ß√£o e redesenha
      clearSelection();
      draggingRelationFromMenu = true;
    }
    
    // Atualiza a posi√ß√£o atual para desenhar a linha
    if (isDraggingConnection && draggingConnection) {
      const pos = getMousePos(evt);
      draggingConnection.current = pos;
      draw();
    }
  }
}

// Fun√ß√£o para finalizar o arraste do relacionamento
function onRelationMenuDragEnd(evt) {
  // Remove os handlers de evento
  $(document).off("mousemove.relationDrag");
  $(document).off("mouseup.relationDrag");
  
  // Se estivermos arrastando uma conex√£o
  if (isDraggingConnection && draggingConnection && draggingRelationFromMenu) {
    const pos = getMousePos(evt);
    let drop = getDraggableAt(pos.x, pos.y);
    
    // Processa o drop da conex√£o (como no onCanvasEnd)
    if (drop) {
      handleConnectionDrop(draggingConnection, drop);
    }
    
    // Limpa os estados
    isDraggingConnection = false;
    draggingConnection = null;
    draggingRelationFromMenu = false;
    
    // Salva e redesenha
    saveState();
    draw();
  }
  
  // Reseta a vari√°vel de origem
  relationMenuSource = null;
}

// Fun√ß√£o auxiliar para processar a conex√£o ap√≥s o arraste
function handleConnectionDrop(draggingConnection, drop) {
  if (draggingConnection.type === "entity" && drop.type === "entity") {
    let source = draggingConnection.element;
    let target = drop.element;
    
    // Cria relacionamento entre duas entidades
    let sourceCenter = { 
      x: source.x + (source.width || defaultEntityWidth) / 2, 
      y: source.y + (source.height || defaultEntityHeight) / 2 
    };
    let targetCenter = { 
      x: target.x + (target.width || defaultEntityWidth) / 2, 
      y: target.y + (target.height || defaultEntityHeight) / 2 
    };
    let midX = (sourceCenter.x + targetCenter.x) / 2;
    let midY = (sourceCenter.y + targetCenter.y) / 2;
    
    let newR = {
      id: relationshipIdCounter++,
      x: midX,
      y: midY,
      size: relationshipSize,
      name: "Rel.",
      connections: [],
      selected: false,
      objType: "relationship"
    };
    
    relationships.push(newR);
    newR.connections.push({ entityId: source.id, cardinality: "1,1" });
    newR.connections.push({ entityId: target.id, cardinality: "1,1" });
  } 
  else if (draggingConnection.type === "relationship" && drop.type === "entity") {
    // Adiciona entidade ao relacionamento
    draggingConnection.element.connections.push({ 
      entityId: drop.element.id, 
      cardinality: "1,1" 
    });
  } 
  else if (draggingConnection.type === "entity" && drop.type === "relationship") {
    // Adiciona entidade ao relacionamento
    if (!drop.element.connections.find(conn => conn.entityId === draggingConnection.element.id)) {
      drop.element.connections.push({ 
        entityId: draggingConnection.element.id, 
        cardinality: "1,1" 
      });
    }
  } 
  else if (draggingConnection.type === "specialization" && drop.type === "entity") {
    // Conecta especializa√ß√£o √† entidade
    let spec = draggingConnection.element;
    let vertices = getSpecializationVertices(spec);
    let pos = getMousePos(event);
    let distances = vertices.map(v => Math.hypot(v.x - pos.x, v.y - pos.y));
    let vertexIndex = distances.indexOf(Math.min(...distances));
    
    if (!spec.connections) spec.connections = [];
    if (!spec.connections.find(conn => conn.vertex === vertexIndex && conn.entityId === drop.element.id)) {
      spec.connections.push({ 
        vertex: vertexIndex, 
        entityId: drop.element.id 
      });
    }
  } 
  else if (draggingConnection.type === "entity" && drop.type === "specialization") {
    // Conecta entidade √† especializa√ß√£o
    let spec = drop.element;
    let vertices = getSpecializationVertices(spec);
    let pos = getMousePos(event);
    let distances = vertices.map(v => Math.hypot(v.x - pos.x, v.y - pos.y));
    let vertexIndex = distances.indexOf(Math.min(...distances));
    
    if (!spec.connections) spec.connections = [];
    if (!spec.connections.find(conn => conn.vertex === vertexIndex && conn.entityId === draggingConnection.element.id)) {
      spec.connections.push({ 
        vertex: vertexIndex, 
        entityId: draggingConnection.element.id 
      });
    }
  }  




  // L√≥gica completa para conex√µes de agrega√ß√£o com entidades
  if (draggingConnection.type === "aggregation" && drop.type === "entity") {
    if (!draggingConnection.element.connections) {
      draggingConnection.element.connections = [];
    }
    
    // Verifica se a conex√£o j√° existe
    if (!draggingConnection.element.connections.find(c => c.entityId === drop.element.id)) {
      draggingConnection.element.connections.push({ 
        entityId: drop.element.id, 
        cardinality: "1,1" 
      });
    }
  } 
  // Conex√µes de entidades com agrega√ß√µes
  else if (draggingConnection.type === "entity" && drop.type === "aggregation") {
    if (!drop.element.connections) {
      drop.element.connections = [];
    }
    
    // Verifica se a conex√£o j√° existe
    if (!drop.element.connections.find(c => c.entityId === draggingConnection.element.id)) {
      drop.element.connections.push({ 
        entityId: draggingConnection.element.id, 
        cardinality: "1,1" 
      });
    }
  }
  // Conex√µes entre agrega√ß√µes e relacionamentos
  else if (draggingConnection.type === "aggregation" && drop.type === "relationship") {
    if (!draggingConnection.element.connections) {
      draggingConnection.element.connections = [];
    }
    
    // Verifica se a conex√£o j√° existe
    if (!draggingConnection.element.connections.find(c => c.relationshipId === drop.element.id)) {
      draggingConnection.element.connections.push({ 
        relationshipId: drop.element.id, 
        cardinality: "1,1" 
      });
    }
  } 
  // Conex√µes entre relacionamentos e agrega√ß√µes
  else if (draggingConnection.type === "relationship" && drop.type === "aggregation") {
    if (!drop.element.connections) {
      drop.element.connections = [];
    }
    
    // Verifica se a conex√£o j√° existe
    if (!drop.element.connections.find(c => c.relationshipId === draggingConnection.element.id)) {
      drop.element.connections.push({ 
        relationshipId: draggingConnection.element.id, 
        cardinality: "1,1" 
      });
    }
  }
}


function getSubmenuHit(x, y) {
      if (!submenu || !isInsideRect({x,y}, submenuRect)) return null;
      let items = submenu.children;
      for (let i = 0; i < items.length; i++) {
        let rect = items[i].getBoundingClientRect();
        let canvasRect = canvas.getBoundingClientRect();
        let itemRect = {
          x: rect.left - canvasRect.left,
          y: rect.top - canvasRect.top,
          width: rect.width,
          height: rect.height
        };
        if (isInsideRect({x,y}, itemRect)) {
          return { action: items[i].onclick };
        }
      }
      return null;
    }

    // Listener para ESC e Delete (exclus√£o dos objetos selecionados)
    document.addEventListener("keydown", function(e) {
      if (e.key === "Escape") {
        // Se estiver em modo de relacionamento, cancela
        if (isDraggingConnection) {
          exitClickRelationMode();
        }
        
        // Se estiver arrastando algo do toolbar, limpa
        if (draggingToolbarType) {
          cleanupToolbarDrag();
          draw();
        }
      } else if (e.key === "Delete") {
        deleteSelectedObjects();
      }
    });


    function deleteSelectedObjects() {

      
      // 1) Exclui entidades selecionadas
      const deletedEntityIds = entities.filter(e => e.selected).map(e => e.id);
      // 2) Exclui relacionamentos selecionados
      const deletedRelationshipIds = relationships.filter(r => r.selected).map(r => r.id);

      // 3) Filtra fora as entidades e relacionamentos deletados
      entities = entities.filter(e => !e.selected);
      relationships = relationships.filter(r => !r.selected);
      specializations = specializations.filter(s => !s.selected);

      // 4) Filtra atributos que pertenciam a entidades/relacionamentos removidos
      attributes = attributes.filter(a => {
        if (a.selected) return false; // se o atributo em si estiver selecionado, exclui
        if (a.parentType === "entity" && deletedEntityIds.includes(a.parentId)) return false;
        if (a.parentType === "relationship" && deletedRelationshipIds.includes(a.parentId)) return false;
        return true;
      });

      // 5) Remove das connections qualquer entidade deletada
      relationships.forEach(r => {
        r.connections = r.connections.filter(c => !deletedEntityIds.includes(c.entityId));
      });

      // 6) Remove das conex√µes de especializa√ß√£o qualquer entidade deletada
      specializations.forEach(s => {
        if (s.connections) {
          s.connections = s.connections.filter(c => !deletedEntityIds.includes(c.entityId));
        }
      });

      // 7) Se houver selectedConnection (linha) selecionada, remove a conex√£o
      if (selectedConnection) {
        let r = relationships.find(rr => rr.id === selectedConnection.relationshipId);
        if (r) {
          // Filtra fora a conex√£o cujo entityId √© o selecionado
          r.connections = r.connections.filter(conn => conn.entityId !== selectedConnection.entityId);
        }
        selectedConnection = null; 
      }

      // 8) Se houver selectedSpecConnection (linha de especializa√ß√£o) selecionada, remove tamb√©m
      if (selectedSpecConnection) {
        let s = specializations.find(sp => sp.id === selectedSpecConnection.specializationId);
        if (s && s.connections) {
          s.connections = s.connections.filter(conn =>
            !(conn.entityId === selectedSpecConnection.entityId && conn.vertex === selectedSpecConnection.vertex)
          );
        }
        selectedSpecConnection = null;
      }

      // Exclui agrega√ß√µes selecionadas
      const deletedAggregationIds = aggregations.filter(a => a.selected).map(a => a.id);
      aggregations = aggregations.filter(a => !a.selected);
      
      // Atualiza atributos para remover refer√™ncias a agrega√ß√µes exclu√≠das
      attributes = attributes.filter(a => {
        if (a.selected) return false;
        if (a.parentType === "aggregation" && deletedAggregationIds.includes(a.parentId)) return false;
        return true;
      });

       // Limpar vari√°veis de sele√ß√£o de conex√£o
      selectedConnection = null;
      selectedSpecConnection = null;
      selectedAggregationConnection = null;

      // 9) Salva estado, limpa sele√ß√£o e redesenha
      saveState();
      clearSelection();
      draw();
    }


    document.getElementById("btnEntity").addEventListener("mousedown", (e) => startToolbarDrag("entity", e));
    document.getElementById("btnAttribute").addEventListener("mousedown", (e) => startToolbarDrag("attribute", e));
    document.getElementById("btnDerivedAttribute").addEventListener("mousedown", (e) => startToolbarDrag("derivedAttribute", e));
    document.getElementById("btnRelationship").addEventListener("mousedown", (e) => startToolbarDrag("relationship", e));
    document.getElementById("btnSpecialization").addEventListener("mousedown", (e) => startToolbarDrag("specialization", e));
    
    
    function exportDiagram() {
        // 1. Calcular os limites reais do diagrama (encontrar min/max de todos os objetos)
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        
        // Processar entidades
        entities.forEach(e => {
            minX = Math.min(minX, e.x);
            minY = Math.min(minY, e.y);
            maxX = Math.max(maxX, e.x + (e.width || defaultEntityWidth));
            maxY = Math.max(maxY, e.y + (e.height || defaultEntityHeight));
        });
        
        // Processar atributos
        attributes.forEach(a => {
            const rx = a.radiusX || defaultAttributeRadiusX;
            const ry = a.radiusY || defaultAttributeRadiusY;
            minX = Math.min(minX, a.x - rx);
            minY = Math.min(minY, a.y - ry);
            maxX = Math.max(maxX, a.x + rx);
            maxY = Math.max(maxY, a.y + ry);
        });
        
        // Processar relacionamentos
        relationships.forEach(r => {
            const half = (r.size || relationshipSize) / 2;
            minX = Math.min(minX, r.x - half);
            minY = Math.min(minY, r.y - half);
            maxX = Math.max(maxX, r.x + half);
            maxY = Math.max(maxY, r.y + half);
            
            // Verificar tamb√©m os breakpoints das conex√µes
            r.connections.forEach(conn => {
                if (conn.breakpoints) {
                    conn.breakpoints.forEach(bp => {
                        minX = Math.min(minX, bp.x);
                        minY = Math.min(minY, bp.y);
                        maxX = Math.max(maxX, bp.x);
                        maxY = Math.max(maxY, bp.y);
                    });
                }
            });
        });
        
        // Processar especializa√ß√µes
        specializations.forEach(s => {
            const vertices = getSpecializationVertices(s);
            vertices.forEach(v => {
                minX = Math.min(minX, v.x);
                minY = Math.min(minY, v.y);
                maxX = Math.max(maxX, v.x);
                maxY = Math.max(maxY, v.y);
            });
            
            // Verificar tamb√©m os breakpoints das conex√µes
            if (s.connections) {
                s.connections.forEach(conn => {
                    if (conn.breakpoints) {
                        conn.breakpoints.forEach(bp => {
                            minX = Math.min(minX, bp.x);
                            minY = Math.min(minY, bp.y);
                            maxX = Math.max(maxX, bp.x);
                            maxY = Math.max(maxY, bp.y);
                        });
                    }
                });
            }
        });
        
        // Adicionar uma margem
        const margin = 50;
        minX -= margin;
        minY -= margin;
        maxX += margin;
        maxY += margin;
        
        // Calcular dimens√µes
        const diagramWidth = maxX - minX;
        const diagramHeight = maxY - minY;
        
        // 2. Criar um canvas de exporta√ß√£o com o tamanho correto
        const exportScale = 2; // Fator de escala para maior qualidade
        const exportCanvas = document.createElement("canvas");
        exportCanvas.width = diagramWidth * exportScale;
        exportCanvas.height = diagramHeight * exportScale;
        
        const exportCtx = exportCanvas.getContext("2d");
        exportCtx.clearRect(0, 0, exportCanvas.width, exportCanvas.height);
        
        // 3. Ajustar a transforma√ß√£o para incluir toda a √°rea do diagrama
        exportCtx.scale(exportScale, exportScale);
        exportCtx.translate(-minX, -minY);
        
        // 4. Desenhar o conte√∫do
        drawAll(exportCtx);
        
        // 5. Converter para URL de dados e criar o link de download
        const dataUrl = exportCanvas.toDataURL("image/png");
        const link = document.createElement("a");
        link.href = dataUrl;
        
        // Nome do arquivo com data e hora atual
        const now = new Date();
        const dateStr = now.toISOString().slice(0, 10).replace(/-/g, "");
        const timeStr = now.toTimeString().slice(0, 8).replace(/:/g, "");
        link.download = `diagrama_er_${dateStr}_${timeStr}.png`;
        
        link.click();
    }
    
    
    // Configura√ß√£o dos bot√µes de zoom
    document.getElementById("btnIncreaseZoom").addEventListener("click", () => {
      // Incrementa o zoom (por exemplo, 10% cada vez)
      zoom = Math.min(zoom * 1.1, 3.0);  // Limita o zoom m√°ximo a 3x
      draw();
    });

    document.getElementById("btnDecreaseZoom").addEventListener("click", () => {
      // Decrementa o zoom (por exemplo, 10% cada vez)
      zoom = Math.max(zoom / 1.1, 0.3);  // Limita o zoom m√≠nimo a 0.3x
      draw();
    });
    

    resizeCanvas();
    saveState();
    draw();
  </script>
</body>
</html>